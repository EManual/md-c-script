[
  {
    "table" : "c_basic",
    "columns" : [
      "id",
      "title",
      "content",
      "importance",
      "showFlag",
      "version"
    ],
    "data" : [
      [
        0,
        "C语言基础",
        "",
        9,
        100,
        1
      ],
      [
        1,
        "C语言简介",
        "Ｃ语言是在70年代初问世的。1978年由美国电话电报公司(AT&T)贝尔实验室正式发表了Ｃ语言。早期的C语言主要是用于Unix系统。由于Ｃ语言的强大功能和各方面的优点逐渐为人们认识，到了八十年代，C开始进入其它操作系统，并很快在各类大、中、小和微型计算机上得到了广泛的使用，成为当代最优秀的程序设计语言之一。由于C语言与Unix的密切关系，C语言也成为Linux下的最流行的高级语言，实际上Linux系统的绝大部分代码是用C语言写的。",
        8,
        100,
        1
      ],
      [
        2,
        "C语言特点",
        "C语言的强大生命力归功于C语言的优秀特点，归纳起来，C语言主要特点如下：\r\n1）C语言非常简洁，而且重视实用性，关键字少，一共只有32个。因此c语言书写的程序长度短，减少了输入的工作量。\r\n2）C语言表达能力很强，其他高级语言难于表达的运算表达式使用C语言可以很容易地实现。这是内于c语言的运算符非常丰富，共有34种运算符，包含的范围很广泛，可以用来构建类型多样化的表达式。在C语言中括号、赋值符号、强制类型转换等被视为运算符，灵活使用各种运算符和表达式可以实现非常复杂的运算功能。\r\n3）C语言易于描述复杂的数据结构。Ｃ语言的数据类型有；整型、实型、字符型、数组类型、指针类型、结构体类型、共用体类型等，可以方便的描述各种常用的数据结构，如链表、树、图等，这使得Ｃ语言在开发大型的系统和应用程序方面有很强的优势。Ｃ语言的一大特色就是可以进行灵活的指针操作，这就使Ｃ语言程序可以完成其他高级语言难于实现的功能，并保证了极高的运行效率。\r\n4）Ｃ语言非常接近于硬件，允许直接访问物理地址，并能进行位操作，能够以更容易理解的方式实现汇编语言的大部分功能。Ｃ语言具有高级语言和低级语言的双重特性，既可以作为系统的描述和开发语言，又是通用的程序设计语言。现在流行的操作系统一般由Ｃ语言编写绝大多数的代码，而非常接近硬件并对性能要求严格的部分才由汇编来完成。\r\n5）Ｃ语言编写的代码编译生成的目标代码质量非常高，程序运行效率一般只比汇编程序生成的目标代码低10％—20％。C语言有非常优秀的编译系统可以选择，程序员可以把大部分的优化工作交给编译程序完成。\r\n6）Ｃ语言具有由函数集合所构成的模块化结构。函数是Ｃ语言代码的基本构成部分。开发者可以将一个大型程序分割成若干部分或函数，并分别由不同的人员同时编写，因此，Ｃ语言也是一种具有高度结构化和模块化特性的语言。\r\n7）Ｃ语言编写的程序非常容易移植，到目前为止，几乎所有的操作系统平台上都有Ｃ语言的编译系统，而且Ｃ语言具有统一的标准，大大简化了软件在不同平台的移植工作。\r\n但是，Ｃ语言也存在缺点，比如：\r\n1）Ｃ语言的语法检查不严格，虽然这样可以给程序员更大的灵活性，但是这样会使程序员养成不良的编程习惯，并导致程序存在隐含的错误。这个特点使得Ｃ语言对程序员的程序设计思想和技能要求较高。\r\n2）Ｃ语言的指针操作非常灵活，不正确的使用会造成程序运行的严重错误，甚至会造成系统不稳定。\r\n随着Linux的不断发展，C语言作为Linux系统的主要编程语言应用越来越广泛，下面将逐步介绍在Linux系统上如何运用C语言进行软件开发。",
        8,
        100,
        1
      ],
      [
        3,
        "C语言程序结构",
        "在第2章中，已经给出了简单的C语言程序例子。在此我们仍以几个简单的例子来\r\n仅供参考\r\n说明C语言源程序结构的特点，这几个程序由简到难，表现了Ｃ语言源程序在组成结构上的特点。从这些例子中了解到组成一个C源程序的基本部分和书写格式。\r\n例0.1：在屏幕上输出\"Hello，world！\"\r\n[code=java]\r\n#include <stdio.h>\r\nmain() #[Tags]\/*主函数*\/#\r\n{\r\n\t#printf(#[Fields]\"Hello world!\\n\"#); #[Tags]\/*调用标准库函数，显示引号中的内容*\/#\r\n#}\r\n[\/code]\r\n这是第2章中给出的最简单的C程序，其执行结果是在终端屏幕上显示一行信息：\r\n[code=java]\r\nHello world!\r\n[\/code]\r\n下面，对上面的程序进行说明。\r\n程序的第一行#include 称为文件包含命令，它指的是一个程序把另一个指定文件的内容包含进来，扩展名为.h 的文件称为头文件或首部文件。书写时，可以使用引号也可以用尖括号。例如：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\n[\/code]\r\n或\r\n[code=java]\r\n#include <stdio.h>\r\n[\/code]\r\n都是在程序中把文件stido.h的内容(引号或尖括号是一定要的)包含进来。文件名是用双引号还是尖括号，其含义并不一样。使用尖括号时，C编译系统首先在系统指定的目录中寻找包含文件，如果没有找到，就到当前工作目录中去寻找，这是引用系统提供的包含文件所采用的方法。而使用双引号时，C编译系统只在用户指定的目录下和当前目录下寻找包含文件。\r\n在程序设计中，文件包含语句是非常有用的。一般C系统中带有大量的.h文件，用户可根据不同的需要将相应的.h文件包含进来。\r\nstdio.h是关于标准输入输出的头文件，它是由系统提供的，其中定义了标准输入和输出库函数的许多信息。可以说，一般的C程序都离不开这条语句。\r\n所有的C程序都是由一个或多个函数构成，其中必须只能有一个主函数main。程序从主函数开始执行，当执行到调用函数的语句时，程序将控制转移到调用函数中执行，执行结束后，再返回主函数中继续运行，直至程序执行结束。C程序的函数是由编译系统提供的标准函数（如printf、scanf等）和由用户自己定义的函数等。虽然从技术上讲，主函数不是C语言的一个成分，但它仍被看做是其中的一部分。\r\n花括号{}括起来构造函数的语句，称为函数体。在这个例子中，函数体只有一条函数调用语句printf。和其它高级语言一样，C语言的语句也是用来向计算机系统发出操作指令的。一条语句经过编译后生成若干条机器指令。一个为实现特定目的的程序应包含若干条语句，即一个C程序可以由若干个源程序文件（分别编译的文件模块）组成，一个源文件可以由若干个函数和预编译命令组成，一个函数又由数据定义和执行语句两部分组成。\r\nprintf 函数是一个由系统定义的标准函数，可在程序中直接调用。printf函数的功能是把要输出的内容（本例中是Hello world!）送到显示器去显示。\\n为转义字符，代表换行的意思，后面还会进一步介绍。\r\nC语言中一个语句一般占一行，语句的最后跟着一个分号“;”，C语言规定在每条语句最后必须加一个分号“;”表示该语句的结束。分号称为终结符，单独一个分号也可构成一个语句，这就是空语句。如果不加分号，编译程序会提示错误。\r\n程序中\/ * . . . . . * \/表示对程序的说明（称为注释），可以方便程序的阅读。注释不参与程序的运行，它可以加在程序的任何位置，注释文字可以是任意字符，如汉字、拼音、英文等。\r\n下面再看一个较为复杂的程序。\r\n例0.2：输入圆柱体的半径和高度，计算圆柱体的体积。\r\n[code=java]\r\n#include <stdio.h>\r\nmain()\r\n{\r\n\t#[Keywords]float #radius,height,vol; #[Tags]\/*定义浮点型变量*\/#\r\n\t#[Keywords]float #volume(float,#[Keywords]float#); #[Tags]\/*声明volume函数*\/#\r\n\t#printf(#[Fields]\"Please input the radius and height:\\n\"#);\r\n\t#scanf(#[Fields]\"%f %f\"#,&radius,&height); #[Tags]\/*调用库函数，从键盘输入radius,height的值*\/#\r\n\t#vol=volume(radius,height); #[Tags]\/* 调用volume函数，计算圆柱体的体积*\/#\r\n\t#printf(#[Fields]\"volume= %f\\n\"#,vol);\r\n#}\r\n#[Keywords]float #volume(#[Keywords]float #r, #[Keywords]float #h) #[Tags]\/*定义volume函数*\/#\r\n{\r\n\t#[Keywords]float #temp; #[Tags]\/*定义函数内部使用的变量temp*\/#\r\n\t#[Keywords]float #pi=3.1415926; #[Tags]\/*定义圆周率pi *\/#\r\n\t#temp=pi*r*r*h; #[Tags]\/*计算体积*\/#\r\n\t#[Keywords]return #temp; #[Tags]\/*返回计算出的体积值*\/#\r\n#}\r\n[\/code]\r\n例0.2 比例0.1复杂一些，它包含了main函数和一个根据半径和高度计算圆柱体体积的volume函数。\r\nmain函数的第一条语句是变量说明语句。前面已经说过函数由数据定义和执行语句两部分组成，变量说明即为数据定义的一部分。在C语言中，所有变量都必须先说明后使用，说明通常放在函数开始处的可执行语句之前。说明用于声明变量的性质，它由一个类型名与若干所要说明的变量组成，例如：\r\n[code=java]\r\n#[Keywords]float #radius,height,vol;\r\n[\/code]\r\n就定义了radius，height，vol是浮点数变量（即我们通常所说的实数变量），其中，float是类型标识符，表示所列变量为浮点数变量，radius，height，vol是变量名，在本程序中分别代表圆柱体的半径，高度和体积。关于类型标识符与变量在后面的内容将会详细介绍。\r\n在变量定义语句之后，volume函数的声明语句。因为函数volume是在main函数定义之后才定义的，并且在main函数中要调用volume函数。如果对volume函数不加以声明，编译系统会不知道volume函数的类型，因而无法编译。函数声明的目的就是告诉编译系统，main函数里调用的vol函数的参数类型以及返回类型，使得程序可以正常编译。函数声明语句中的的第1个float表示函数的返回值类型是浮点数类型，volume是函数名，括号中的2个float说明volume函数的参数类型是浮点型。\r\n在volume函数声明语句之后是printf函数和scanf函数，它们用来输出相关信息和获得从键盘输入的圆柱体的半径和高度值，并把值赋给radius和height变量。\r\n获得圆柱体的半径和高度值之后，main函数以此作为参数，调用volume函数，计算得出圆柱体的体积，并把结果通过赋值运算符“=”赋给变量vol。\r\nmain函数的最后一条语句是输出圆柱体的体积值。\r\n仅供参考\r\nmain函数后面是函数volume的定义，包括函数返回值和函数参数的定义，在本程序中函数返回值类型是float型，2个参数分别代表圆柱体的半径和高度，它们也是float型。\r\nvolume函数的第1条语句是变量定义语句，定义了一个浮点型变量temp，用来保存计算得出的结果值。第2条语句也是变量定义语句，定义了圆周率pi的大小，并且给pi赋了初值。第3条语句是根据半径和高度，计算圆柱体的体积，并把计算出的值赋给变量temp，其中“*”代表乘法运算。volume函数的最后一条语句是返回圆柱体的体积。关于函数的定义和调用在后面会进一步介绍，读者在此只须了解函数可以完成一定的功能，由一系列语句组成即可。\r\n编译链接后，运行本程序时，首先在终端上给出提示：输入半径和高度，从键盘键入数据，如1，3，按下回车键，程序给出运行结果：\r\n[code=java]\r\nPlease input the radius and height:\r\n1 3\r\nvolume= 9.424778\r\n[\/code]\r\n从以上2个例子中可以看出，所有的C程序为函数模块结构，所有的C程序都是由一个或多个函数构成。从技术上讲，纯粹由程序员自己编写的语句构成C语言程序是可能的，但这却是罕见的。因为所有的C编译程序都提供能完成各种常用任务的函数—函数库（如printf、scanf等）。C编译程序的实现者已经编写了大部分常见的通用函数。当我们调用一个别人编写的函数时编译程序“记忆”它的名字。随后，“链接程序”把我们编写的程序同标准函数库中找到的目标码结合起来，这个过程称为“链接”。\r\n编写程序时用到的函数，许多都可以在标准函数库中找到。它们是可以简单地组合起来的程序构件。编写了一个经常要用的函数之后，可将其放入库中备用。",
        8,
        100,
        1
      ],
      [
        100,
        "数据类型、运算符与表达式",
        "",
        9,
        101,
        1
      ],
      [
        101,
        "数据类型、运算符与表达式",
        "计算机的基本功能是进行数据处理，一种语言支持的数据类型越丰富，它的应用范围就越广。C语言可以提供丰富的数据类型，不仅能表达并处理基本的数据（如整形、实数、字符等），还可以组织成复杂的数据结构（如链表、树等）。\r\n在Ｃ语言中，数据类型可分为：基本数据类型，构造数据类型，指针类型三大类。基本数据类型可分为整形、浮点型、双精度浮点型、字符型。构造类型可分为数组类型、结构体类型和共用体类型以及枚举类型。在C语言中，每一种数据类型都有一个标识符与之相对应，称之为类型名。\r\nC语言的运算符非常丰富，主要有以下几类：算术运算符、关系运算符、逻辑运算符、位运算符和其他一些用于完成特殊任务的运算符。Ｃ语言中运算符和表达式数量之多， 在高级语言中是少见的。正是丰富的运算符和表达式使Ｃ语言功能十分完善。这也是Ｃ语言的主要特点之一。\r\nＣ语言的运算符不仅具有不同的优先级，而且还有一个特点，就是它的结合性。在表达式中，各运算量参与运算的先后顺序不仅要遵守运算符优先级别的规定，还要受运算符结合性的制约，以便确定是自左向右进行运算还是自右向左进行运算。这种结合性是其它高级语言的运算符所没有的，因此也增加了Ｃ语言的复杂性。",
        8,
        101,
        1
      ],
      [
        102,
        "标识符",
        "所谓标识符，实际上就是一个字符序列。在C语言中，标识符用来标记常量、变量、数据类型、函数及程序的名字。在C语言中构成标识符必须将合下列语法规则：\r\n1、以字母或下划线“_”中任一字符打头。\r\n2、在第一个字符之后，可以是任意的字母、下划线或数字组成的字符序列，这个序列可以是空串。\r\nC语言中的标识符可以分为下述3类：\r\n[color=blue]1、关键字\r\n关键字是用来说明C语言中某一固定含义的字。float是关键字，它用以说明变量是浮点类型。C语言中一共有如下32个关键字：\r\n[code=java]\r\nint char float double short long unsigned struct union auto extern register static typedef goto return sizeof break continue if else do while switch case default enum for void const volatile enum\r\n[\/code]\r\n这些关键字为C语言专用字，不得赋予其它含义。C语言中的习惯是用小写字母，所有这些关键字也都是由小写字母构成的。\r\n[color=blue]2、特定字\r\n特定字是具有特定含义的标识符，主要有如下7个：\r\n[code=java]\r\ndefine include undef ifdef ifndef endif line\r\n[\/code]\r\n它们主要用在C语言的预处理程序中，这些标识符虽然不是关键字，但由于给这些字赋予了特定含义，所以人们习惯把它们也看作是关键字。因此在程序中不能把这些特定字当作一般标识符使用。\r\n[color=blue]3、一般标识符\r\n通常是用户根据前面所提到标识符构成规则定义的标识符，根据标识符的构成规则，下列用户定义字都是合法的标识符：\r\n[code=java]\r\nHello, valid, VALID_identifier, Also_valid, _hello, a1, b_2a, _100\r\n[\/code]\r\n用户定义的标识符没有固定含义只有给出说明后才具有特定的含义。在数学中，我们用罗马字母表示常量或变量，在C语言中，凡是要命名的对象(如变量、常量、函数、数据类型等)，都用标识符来标识其名字。\r\nC语言中大小写字母是具有不同的含义的，例如name和NAME就代表不同的标识符。在选取标识符时不仅要保证正确性，还要考虑容易区分，不易混淆。例如数字1和字母i在一起，就不易辨认。在取名时，应使名字有很清楚的含义。比如：用标识符area表示“面积”，用标识符length或len表示长度等。对一个可读性好的程序，其中标识符必须选择恰当，取名统一规范，使读者一目了然。",
        8,
        101,
        1
      ],
      [
        103,
        "基本数据类型",
        "C语言提供了四种基本数据类型它们是整型(int)、浮点型（float）、双精度浮点型(double)和字符型(char)。被说明为int型的变量可包含整数值。被说明为float型和double型的变量都可用来存储浮点数(带小数点的数)，只不过double型的精度是float型的两倍。\r\nchar型的变量都可用来存储一个字符，包括字母、数字字符、标点符号等。\r\n数据有常量和变量之分。常量是指在运算过程中，其值不变的量，可以是一个具体的值，也可以定义一个标识符来代表，即符号常量。变量的值在运算过程可以改变。每个变量都应有一个唯一的名称，并根据其类型在存储器中占一定的存储单元，以便存放其值。",
        8,
        101,
        1
      ],
      [
        104,
        "数值常量",
        "C语言中使用的数值常量有2种：整数和浮点小数。\r\n[color=blue]1、整数常量\r\n整数常量可以用十进制数、八进制数和十六进制数形式表示。\r\n十进制整数常量由阿拉伯数字0~9和负号组成，如235，64，-5等。\r\n八进制整数常量以0开头，后随若干个阿拉伯数字0~7所组成，如0564，034分别表示十进制数的372和28。\r\n十六进制整数常量以0x开头，后随若干个0~9和A~F之间的数字所组成，如0xF表示十进制数的15，0x13B表示十进制数的315。\r\n[color=blue]2、浮点常量\r\nC语言中的浮点小数描述的是实数，可以采用十进制小数形式或者指数形式表示。\r\n十进制小数形式包含整数部分、小数点和小数部分。例如：1.45、-34.0、.56、0.0等，其中需要注意的是小数点不能省略。\r\n指数形式：包含尾数部分、字母E或e和阶码。例如：1.35E10、1.25e-5分别表示、101.3510×51.2510?×。需要注意的是：尾数部分不能省、阶码必须是整数。",
        8,
        101,
        1
      ],
      [
        105,
        "字符型常量",
        "C语言把字符型常量分为两种类型：字符常量和字符串。\r\n[color=blue]1、字符常量\r\n字符常量的表现形式是由单引号括起来的一个字符，例如：\r\n[code=java]\r\n#[Fields]'a'#,#[Fields]'B'#,#[Fields]'-'#,#[Fields]'1'#\r\n[\/code]\r\n其中单引号、双引号和反斜杠的表现形式比较特殊，分别是''','',''，这种字符称为转义字符。在C语言中转义字符被认为是具有特殊意义的单个字符。常见的以开头的专业字符如表3-1所示。\r\n[code=java]\r\n表 3-1 常用转义字符表\r\n转义字符\t功能\r\n\\n\t\t回车换行符，光标移动到下一行行首。\r\n\\r\t\t回车不换行，光标移动到本行行首。\r\n\\t\t\t横向跳格（8位为一格，光标跳到下一格起始位置）。\r\n\\b\t\t退一格，光标1往左移动一格。\r\n\\f\t\t走纸换页。\r\n\\\\\t\t输出反斜杠字符“”。\r\n\\'\t\t输出单引号字符“'”。\r\n\\\\\"\t\t输出双引号字符“”。\r\n\\ddd\t三位八进制数ddd对应的ASCII码字符。\r\n\\xhh\t两位十六进制数hh对应的ASCII码字符。\r\n[\/code]\r\n[color=blue]2、字符串\r\n字符串是由双引号括起来的字符序列，例如：\r\n[code=java]\r\n#[Fields]\"Hello world!\"#,#[Fields]\"C program\"#,#[Fields]\"120.45\"#\r\n[\/code]\r\n等都是字符串。\r\n不要将字符常量与字符串混为一谈。’a’是字符常量，而“a”是字符串，二者有本质的区别。C系统自动在每一个字符串的末尾加一个字符串结束标志，系统据此判断字符串是否结束。字符串结束标志是一个ASCII码值为0的字符，即‘\\0’。从ASCII码表中可以看到ASCII码为0的字符是空操作字符．它不引起任何控制动作，也不是一个可显示的字符。如果有一个字符串“CHINA”，则它在内存中占6个字节，最后一个字符为‘＼0’。但在输出时不输出‘\\0’，所以字符串“CHINA”有效的字符个数是5。",
        8,
        101,
        1
      ],
      [
        106,
        "变量",
        "变量的值可以改变，C语言中所有的变量使用前必须先定义，说明变量类型。对于每个变量都必须确定其数据类型。定义就是用来规定一组变量的数据类型。\r\n[color=blue]1、变量的定义\r\n变量定义的形式如下：\r\n[code=java]\r\n类型标识符变量名,1 变量名2, …, 变量名n;\r\n[\/code]\r\n其中，类型标识符用以说明变量的数据类型，对于基本数据类型来说，它可以是int、float、double和char，分别表示整形、浮点型、双精度型和字符型。例如：\r\n[code=java]\r\n#[Keywords]int #i, j, k;\r\n#[Keywords]float #length;\r\n#[Keywords]double #height;\r\n#[Keywords]char c;\r\n[\/code]\r\n分别说明变量i、j和k是整形的，变量length是浮点型的，变量height是双精度型的，变量c是字符型的。变量名是用户自定义的一般标识符。\r\n变量在定义时要注意以下几个问题：\r\n1）允许在一个类型标识符后，说明多个相同类型的变量。类型标识符与变量名之间至少用一个空格间隔，各变量名之间用逗号间隔，最后一个变量名之后必须以“；”号结尾。\r\n2）变量定义必须放在变量使用之前。一般放在函数体的开头部分。变量名在同一函数内不允许作两次说明。例如，下面函数中对变量a的说明显然是不正确的：\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]int #a;\r\n\t#[Keywords]float #a;\r\n\t#…\r\n#}\r\n[\/code]\r\n3）变量的命名要符合C语言规定的标识符命名规则，即只能由字母、数字和下划线组成，首字符必须为字母或下划线。此外，C语言中规定的有特殊用途的关键字，如int、float、if等，不能作为变量名称。如a、b3、stu等是正确的，而2cd、tea-1、sh#3、if、else、while、float等是错误的。\r\n4）C语言中大小写是敏感的，即int和Int是不同的，Int不是关键字可以做变量名。\r\n但习惯上，C中的变量一般用小写字母表示。\r\n5）变量的数据类型决定了它的存储类型，即该变量占用的存储空间。所以定义变量类型就是为了给该变量分配存储空间，以便存放数据。\r\n基本的变量类型及其存储空间如表3-2所示。\r\n[code=java]\r\n表 3-2 基本数据类型表\r\n类型\t名称\t存储空间\t取值范围\t\t\t\t\t\t实例\r\nint\t\t整型\t4个字节\t\t- 2147483648~ 2147483647的整数\tint i,j;\r\nfloat\t单精度浮点型\t4个字节\t实数，有效位数6~7位\t\t\tfloat x;\r\ndouble\t双精度浮点型\t8个字节\t实数，有效位数15~16位\t\tdouble y;\r\nchar\t字符型\t1个字节\tASCII码字符，或-128~127的整数\t\tchar c;\r\n[\/code]\r\n变量的类型决定了它可以存放的数据范围，所以在处理数据时，一定要先考虑清楚数据的特征和范围，再确定使用何种类型变量存放数据。\r\n[color=blue]2、变量的赋值\r\n在定义一个变量时，系统自动根据变量类型分配了存储空间。但是当变量的值即存储在该空间的值并未给出时，其值可能是一个内存中的随机值，所以变量需要预置一个值，即赋值。赋值操作通过赋值运算符“=”把右边的值赋给左边的变量：\r\n变量名=表达式;\r\n其执行过程为：\r\n1） 计算赋值运算符“=”右边表达式的值（表达式在下一节介绍）；\r\n2） 将值赋给左边的变量。\r\n例如：\r\n[code=java]\r\na=3; b=b+2; c=3*5-1;\r\n[\/code]\r\n其中需要注意的是：\r\n1）数学中的“=”符号不同于C语言中的赋值运算符“=”，在C语言中，b=b+2是成立的，它表示变量b+2的值赋给变量b。在C语言中判断2个数是否相等时使用符号“==”。\r\n2）如果赋值时“=”两侧的类型不一致，系统将做如下处理：将实数赋给一个整型变量时，如将1.2赋给int型变量啊，即a=0.9，系统会自动舍弃小数部分，此时a=3。\r\n3）将整数赋给一个浮点型变量时，如将34赋给float型变量c，即c=12，系统将保持数值不变并且以浮点小数形式存储到变量中，此时c=12.000000。\r\n4）当字符型数据赋给一个整型变量时，如将'A'赋给int型变量x，即x='A'，不同的系统实现的情况不同，一般当该字符的ASCII值小于127时，系统将整型变量的高字节置0，低字节存放该字符的ASCII值，所以此时的x=字符A的ASCII值65。\r\n例0.4：下面的程序给出了一个赋值时类型自动转换的示例。\r\n[code=java]\r\n#include <stdio.h>\r\nmain()\r\n{\r\n\t#[Keywords]int #a,b;\r\n\t#[Keywords]float #c;\r\n\t#a=1.2;\r\n\t#c=34;\r\n\t#b=#[Fields]'B'#;\r\n\t#printf(#[Fields]\"a= %d,c=%f ,b=%d\\n\"#,a,c,b);\r\n#}\r\n[\/code]\r\n在上面的程序中，实数1.2赋给整型变量a，舍弃小数保留整数部分。整数34赋给浮点型变量c，转换为等值的浮点小数形式。大写字母B的ASCII码的十进制形式为66，小于127，因此b=66。程序的运行结果如下：\r\n[code=java]\r\na= 1,c=34.000000 ,b=66\r\n[\/code]\r\n变量在定义的同时也可以赋初值，称做变量的初始化。例如：\r\n[code=java]\r\nint a,b=0;等价于 int a,b; b=0;\r\nfloat c=1.1,d=2.2; 等价于float c,d; c=1.1; d=2.2;\r\n[\/code]\r\n字符型变量的值可以是字符型数据、介于-128~127的整数或者转义字符。\r\n计算机存储的是二进制数，所以将一个字符数据存放到一个字符变量中，实际上存储的是该字符对应的ASCII码的二进制形式。例如大写字符A的ASCII码用二进制表示是01000001、十进制的标识是65、八进制的标识是101、十六进制的标识是41，即字符型常量'A'、十进制整数65、转义字符'\\101'或'\\x41'与二进制码01000001相同，因此这四种形式的数据在计算机中的存储形式相同，赋给一个字符型变量的结果也相同。",
        8,
        101,
        1
      ],
      [
        107,
        "类型修饰符",
        "上述介绍的基本类型可以带修饰性前缀，即类型修饰符，用来适用更多不同特点的数据处理的需要，扩大C语言基本数据类型的使用范围。C语言共有4种类型修饰符：long（长型）、short（短型）、signed（有符号型）、unsigned（无符号型）。short型和long型用于整型和字符型，其中long型还可以用于双精度型。short型不常用，对于不同机型取值范围不同，这里不再介绍。long int（简写为long）型的存储长度为4个字节，范围为，用于存储整数超过int型取值范围的情况。long double型存储长度16个字节，约24位有效数字，取值范围超过double型的数据。31312~21?\r\n例如：\r\n[code=java]\r\n#[Keywords]long #[Keywords]int #a;\r\nunsigned #[Keywords]int #b;\r\nshort #[Keywords]int #c;\r\n[\/code]\r\n分别表示a是长整型，b是无符号整型，c是短整型数据。\r\n有符号型signed和无符号型unsigned适用于char型、int型和long型三种类型，区别在于它们的最高位是否作为符号位。unsigned char型取值范围为0~255，unsigned int（简写为unsigned）型取值范围未0~65535，unsigned long型取值范围为。",
        8,
        101,
        1
      ],
      [
        108,
        "运算符和表达式",
        "C语言是一种表达式语言。表达式是由运算符和运算分量构成的，运算符是一个表示对数据进行特定运算的符号，参加运算的数据本身就叫运算分量，运算符对运算分量进行运算。例如：\r\n[code=java]\r\n5+4-2\r\n[\/code]\r\n是一个表达式，符号“+”和“-”就是运算符，常数5、4和2即为运算分量，和日常用法一样，符号“+”和“-”分别表示加法和减法，因此，上面这个表达式通知C编译程序加或减这些常数。运算符进行运算的运算分量的个数称为运算符的目数，只有一个运算分量的运算符称为单目运算符，有两个运算分量的运算符称为双目运算符，有三个运算分量的运算符称为三目运算符。例如：“+”这个运算符有两个运算分量，故为双目运算符。",
        8,
        101,
        1
      ],
      [
        109,
        "运算符的种类",
        "Ｃ语言的运算符可分为以下几类：\r\n1、算术运算符\r\n用于各类数值运算。包括加(+)、减(-)、乘(*)、除(\/)、求余(或称模运算，%)、自增(++)、自减(--)共7种。\r\n2、关系运算符\r\n用于比较运算。包括大于(>)、小于(<)、等于(==)、大于等于(>=)、小于等于(<=)和不等于(!=)6种。\r\n3、逻辑运算符\r\n用于逻辑运算。包括与(&&)、或(||)、非(!)3种。\r\n4、位操作运算符\r\n参与运算的量，按二进制位进行运算。包括位与(&)、位或(|)、位非(~)、位异或(^)、左移(<<)、右移(>>)6种。\r\n5、赋值运算符\r\n用于赋值运算，分为简单赋值(=)、复合算术赋值(+=,-=,*=,\/=,%=)和复合位运算赋值(&=,|=,^=,>>=,<<=)三类共11种。\r\n6、条件运算符\r\n这是一个三目运算符，用于条件求值(?:)。\r\n7、逗号运算符\r\n用于把若干表达式组合成一个表达式(，)。\r\n8、指针运算符\r\n用于取内容(*)和取地址(&)2种运算。\r\n9、求字节数运算符\r\n用于计算数据类型所占的字节数(sizeof)。\r\n10、特殊运算符\r\n有括号()，下标[]，成员(->，.)等几种。\r\n在本节的后面部分小节中，集中介绍算术运算符、逻辑运算符、赋值运算符、条件运算符以及逗号运算符，其它运算符在后面各节中另行介绍。",
        8,
        101,
        1
      ],
      [
        110,
        "优先级和结合性",
        "分为两种，即左结合性(自左至右)和右结合性(自右至左)。例如算术运算符的结合性是自左至右，即先左后右。如有表达式x-y+z则y应先与“-”号结合，执行x-y运算，然后再执行+z的运算。这种自左至右的结合方向就称为“左结合性”。而自右至左的结合方向称为“右结合性”。最典型的右结合性运算符是赋值运算符。如x=y=z,由于“=”的右结合性，应先执行y=z再执行x=(y=z)运算。Ｃ语言运算符中有不少为右结合性，应注意区别，以避免理解错误。表0.1列出了各运算符的优先级和结合性。\r\n[code=java]\r\n表3-1 运算符的优先级和结合性\r\n优先级\t运算符\t结合性\r\n15\t(), [ ], . , ->\t右\r\n14\t!, ~, ++, --, +, -, &, *(类型名), sizeof\t左\r\n13\t*, \/, %\t左\r\n12\t+, -\t右\r\n11\t<<, >>\t右\r\n10\t<, <=, >, >=\t右\r\n9\t==, !=\t右\r\n8\t&\t右\r\n7\t^\t右\r\n6\t|\t右\r\n5\t&&\t右\r\n4\t||\t右\r\n3\t?:\t左\r\n2\t=, *=, \/=, %=, +=,-=, >>=, <<=, &=, ^=, |=\t左\r\n1\t,\t右\r\n[\/code]",
        8,
        101,
        1
      ],
      [
        111,
        "算术运算符和算术表达式",
        "1、算术运算符\r\n[color=blue]基本的算术运算符有：\r\n1、加法运算符“+”，加法运算符为双目运算符，即应有两个量参与加法运算。如a+b,4+8 等，具有左结合性。\r\n2、减法运算符“-”，减法运算符为双目运算符，具有左结合性。但“-”也可作负值运算符，此时为单目运算，如-x，-5 等，具有右结合性。\r\n3、乘法运算符“*”，乘法运算符为双目运算，具有左结合性。\r\n4、除法运算符“\/”，除法运算符为双目运算，具有左结合性。参与运算量均为整型时，结果也为整型，舍去小数。如果运算量中有一个是实型，则结果为双精度实型。\r\n5、求余运算符（模运算符）“%”，求余运算符为双目运算，具有左结合性。要求参与运算的量均为整型。求余运算的结果等于两数相除后的余数。\r\n6、自增、自减运算符\r\n自增运算符记为“++”，其功能是使变量的值自增1。自减运算符记为“--”，其功能是使变量值自减1。自增、自减运算符均为单目运算，都具有右结合性。可有以下几种形式：\r\n1）++i：i自增1 后再参与其它运算。\r\n2）--i： i自减1后再参与其它运算。\r\n3）i++：i参与运算后，i的值再自增1。\r\n4）i--： i 参与运算后，i的值再自减1。\r\n2、算术表达式\r\n算术表达式是由算术运算符和括号连接起来的式子， 以下是算术表达式的例子：\r\n[code=java]\r\na+b (a*2)\/c (x+r)*8-(a+b)\/7 ++i sin(x)+sin(y) (++i)-(j++)+(k--)\r\n[\/code]",
        8,
        101,
        1
      ],
      [
        112,
        "关系运算符及表达式",
        "关系运算符有6个，“>”、“<”、“==”、“>=”、“<=”、“!=”，分别表示“大于”、“小于”、“等于”和“大于等于”、“小于等于”和“不等于”，其中，“==”和“!=”的优先级为9，其它运算符优先级为10。它们都是双目运算符，都是左结合的，如果两个运算分量不同，要进行类型转换。注意，C语言中“=”是赋值运算符，而“==”才是真正的等号。表达式的运算分量是基本数据类型，表达式的值是整型，如表达式成立，值为1，否则为0。C语言中，总是用非0值表示“真”，用0表示“假”。",
        8,
        101,
        1
      ],
      [
        113,
        "逻辑运算符与逻辑表达式",
        "逻辑运算符主要用于关系表达式所构成的条件的复合，条件的复合从根本上来说有三种：第一种是“两个条件都成立”，这就是两个条件的“与”运算；第二种是“两个条件至少有一个成立”，这就是两个条件的“或”运算；还有一种是“某个条件不成立”，这就是一个条件的“非”运算，它们在C语言中分别用运算符“&&”、“||”和“!”表示。\r\n逻辑运算符的运算对象是简单数据类型（除数组和结构外的任何类型），“&&”、“||”是双目运算符，“!”是单目运算符。它们的运算结果是int型的，一般说来只有“0”和“1”两个值。对于“&&”，计算时只有当两个运算对象都不为0时表达式的值为1，其他情况表达式的值都为0；对于“||”，计算时只有当两个运算对象都为0时表达式的值为0，其他情况表达式的值都为1。\r\n“&&”和“||”还有一个特别的性质，它们是严格从左至右进行运算的，当运算到一定程度，表达式的值可以被确定时，就不再运算下去。例如，在计算表达式\r\n[code=java]\r\n((y=3)>4)&&((y=5)<7)\r\n[\/code]\r\n时，表达式(y＝3)的值为3，显然((y＝3)＞4)的值为0，对于“&&”，计算时只有当两个运算对象只要一个为0时表达式的值即为0，此时表达式的值已经确定，所以就不对((y=5)＜)7求值了，执行此表达式后y的值为3而不为5。",
        8,
        101,
        1
      ],
      [
        114,
        "复合赋值符及表达式",
        "在赋值符“=”之前加上其它二目运算符可构成复合赋值符。如+=，-=，*=,／=，%=，<<=，>>=，&=，^=，|=。构成复合赋值表达式的一般形式为：\r\n[code=java]\r\n变量 双目运算符=表达式\r\n[\/code]\r\n它等效于：\r\n[code=java]\r\n变量=变量运算符 (表达式)\r\n[\/code]\r\n例如： a+=5 等价于a=a+5；x*=y+7等价于x=x*(y+7)； r%=p 等价于r=r%p。\r\n复合赋值符这种写法，对初学者可能不习惯， 但十分有利于编译处理，能提高编译效率并产生质量较高的目标代码。",
        8,
        101,
        1
      ],
      [
        115,
        "条件运算符与条件表达式",
        "条件运算符“?:”是C语言中唯一的一个三目运算符，由它组成的表达式的形式为\r\n[code=java]\r\n表达式1? 表达式2: 表达式3\r\n[\/code]\r\n计算条件表达式时，首先计算表达式1，如果表达式1的值不为0(即条件为真)，计算表达式2，条件表达式的值为表达式2的值；如果表达式1的值为0(即条件为假)，计算表达式3，条件表达式的值为表达式3的值。条件表达式值的类型总是表达式2和表达式3的类型中较高的类型。必要时要进行类型转换。\r\n条件运算符的优先级为3，右结合。",
        8,
        101,
        1
      ],
      [
        116,
        "逗号运算符和逗号表达式",
        "Ｃ语言中逗号“，”也是一种运算符，称为逗号运算符。其功能是把两个表达式连接起来组成一个表达式， 称为逗号表达式。其一般形式为：\r\n[code=java]\r\n表达式1, 表达式2\r\n[\/code]\r\n逗号表达式的求值过程是分别求两个表达式的值，并以表达式2 的值作为整个逗号表达式的值。例如：\r\n[code=java]\r\na=b,c;\r\n[\/code]\r\n分别对b和c求值，最后以c的值为整个表达式的值，所以执行上述语句后a=c。\r\n对于逗号表达式还要说明几点：\r\n1）逗号表达式一般形式中的表达式1 和表达式2 也可以又是逗号表达式。例如：表达式1，(表达式2，表达式3) 形成了嵌套情形。因此可以把逗号表达式扩展为以下形式： 表达式1，表达式2，…表达式n 整个逗号表达式的值等于表达式n 的值。\r\n2）程序中使用逗号表达式，通常是要分别求逗号表达式内各表达式的值，并不一定要求整个逗号表达式的值。\r\n3）并不是在所有出现逗号的地方都组成逗号表达式，如在变量说明中，函数参数表中逗号只是用作各变量之间的间隔符。",
        8,
        101,
        1
      ],
      [
        117,
        "数据类型转换",
        "C语言中不同数据类型的取值范围不同，在进行混合运算时需要进行类型转换。\r\n[color=blue]1、自动类型转换\r\nC语言规定，不同类型的数据在参加运算前会自动转换成相同的类型，再进行运算。转换的规则是：如果运算的数据有float型或double型，自动转换成double型再运算，结果为double型。如果运算的数据中无float型或double型，但是有long型，数据自动转换成long型再运算，结果为long型，其余情况为int型。\r\n[color=blue]2、强制类型转换\r\n在C语言中也可以使用强制类型转换符，强制表达式的值转换为某一特定类型。强制类型转换形式为：\r\n[code=java]\r\n(类型) 表达式\r\n[\/code]\r\n强制类型转换最主要的用途之一是满足一些运算对类型的特殊要求，例如求余运算符“%”，要求运算符两侧的数据为整型，如（int）2.5%3；其次是为了防止整数除法中的小数部分丢失，例如：\r\n[code=java]\r\n#[Keywords]int #a=3,b=2;\r\n#[Keywords]float #c;\r\nc=(#[Keywords]float#)a\/b;\r\n[\/code]\r\n此时，c的值为1.500000。如果不用强制类型转换，即c=a\/b，结果为1.000000。\r\n仅供参考\r\n需要注意的是，在强制类型转换时，原来变量的类型并未发生变化，如上例中(float) a的值为float型的0.0，但是a的类型不变，仍然为整型数据3。",
        8,
        101,
        1
      ],
      [
        200,
        "基本语句与输入输出",
        "",
        9,
        102,
        1
      ],
      [
        201,
        "C语言语句概述",
        "C语言程序是由函数组成的，而函数包含数据定义部分和执行部分，执行部分即由语句组成。和其它高级语言一样，C语言的语句用来向计算机发出操作命令。程序应该包括数据描述（由数据定义部分来实现）和数据操作（由语句来实现）。数据描述主要定义数据结构（用数据类型表示）和数据初值。数据操作的任务是对已提供的数据进行加工处理。\r\nC语句可以分为以下五类：\r\n[color=blue]1、控制语句\r\n它可完成一定的控制功能，C语言中只有9种控制语句，它们是：\r\n1） if（）~else~ （条件语句）\r\n2）for（）~ （循环语句）\r\n3）while（）~ （循环语句）\r\n4）do~while（） （循环语句）\r\n5）continue （结束本次循环语句）\r\n6）break （终止执行switch或循环语句）\r\n7）switch （多分支选择语句）\r\n8）goto （跳转语句）\r\n9）return （从函数返回语句）\r\n上面9种语句中的括号（）表示其中是一个条件，根据该条件的值决定程序的流程，~表示内嵌的语句。例如：\r\n[code=java]\r\n#[Keywords]if#(x>y) z=x;\r\n#[Keywords]else #z=y;\r\n[\/code]\r\n是一个条件语句。\r\n[color=blue]2、函数调用语句\r\n由一次函数调用加一个分号构成一个语句，例如：\r\n[code=java]\r\nprintf(#[Fields]\"Hello, world!\\n\"#);\r\n[\/code]\r\n[color=blue]3、表达式语句\r\n一个表达式的最后加上一个分号就构成一个表达式语句。如由赋值表达式及其构成的一个赋值语句分别如下：\r\n[code=java]\r\ni＝1 （是表达式，不是语句）\r\ni＝l; （是一个赋值语句）\r\n[\/code]\r\n[color=blue]4、空语句\r\n下面是一个空语句：\r\n[code=java]\r\n;\r\n[\/code]\r\n即只有一个分号的语句，它不进行任何操作。空语句常用作程序执行流程的跳转目标，或循环语句中的循环体（循环体是主语句，表示循环体什么也不做）。\r\n[color=blue]5、复合语句\r\n可以把若干语句用{}括起来构成复合语句。例如\r\n[code=java]\r\n{t=x; x=y; y=t;}\r\n[\/code]\r\n{}中包含3个赋值语句，但用{}括起来后构成复合语句，注意该复合语句作为一个语句使用，经常用于条件语句和循环语句中。还要注意的是{}中的最后一个语句的最后一个分号不能忽略不写。",
        8,
        102,
        1
      ],
      [
        202,
        "数据的输出",
        "数据的输出一般以终端显示器(屏幕)为处理对象。即把程序中的原始数据、中间结果或者最后结果送至终端显示器显示输出。与其它高级语言不同，C语言本身并没有提供输入和输出语句，而是由C语言编译系统在标淮函数库中定义了一些输入和输出函数，程序中的键盘输入和显示输出是通过调用库函数实现的。\r\n由于C语言编译系统中的“stdio.h”头文件中包含了与标准输入输出有关的变量定义和相应的宏定义，所以，在利用标准库函数进行输入输出时，一般需要用编译预处理命令#include将头文件“stdio.h”包含到用户源文件中。\r\n下面介绍如何利用标准库函数来进行标准输入输出，先讨论输出部分。\r\n[color=blue]字符输出函数putchar\r\nputchar函数的作用是向终端显示器输出一个字符，共一般调用形式如下：\r\n[code=java]\r\n#[Keywords]char #a;\r\n#[Keywords]putchar #(a);\r\n[\/code]\r\n被输出对象a放在（）中，作为putchar函数的输入，其作用是把输出对象作为一个字符的ASCII码值，将该字符输出到屏幕当前光标位置上。输出对象可以是字符型、整型变量或常量。\r\n[color=blue]格式输出函数printf\r\n上述的putchar函数只能输出单个字符，而不能输出其它类型的数据。printf函数是具有格式控制的输出函数，可以用于输出C语言中任意类型的数据．而且可以一次同时输出多个相同类型或不同类型的数据。其一般调用形式如下：\r\nprintf(格式控制，输出表列);\r\n该函数括号内包括两部分：\r\n[color=blue]1）格式控制\r\n格式控制是用双引号括起来的字符串，也称为“格式控制转换字符串”，其中包括格式说明和需要原样输出的普通字符。格式说明部分由“％”和格式控制字符组成，如％c、%d和%f等，其作用是将要输出对象转换成指定的格式后输出。\r\nprintf函数中使用的格式字符如表3-3所示：\r\n[code=java]\r\n表 3-3 printf函数中使用的格式字符\r\n格式字符\t作用\r\nd\t以十进制形式输出带符号的整数，输出长整型数据时，使用ld。\r\no\t以八进制无符号形式输出整数，输出长整型数据时，使用lo。\r\nx\t以十六进制无符号形式输出整数，输出长整型数据时，使用lx。\r\nu\t以十进制无符号形式输出整数，输出长整型数据时，使用lu。\r\nc\t以字符形式输出单个字符。\r\nf\t以十进制形式输出单、双精度浮点数(注意输出双精度double型数据时，也用格式f，而不是d)。\r\ne\t以指数(科学记数法)形式输出单、双精度浮点数。\r\ns\t输出指定的字符串。\r\n[\/code]\r\n[color=blue]2）输出表列\r\nprintf函数中的输出表列用以指明输出对象，即要输出的数据，它们可以是常量、变量、表达式或函数值。\r\n若有整型变量变量i=1，j=2和实型变量k=0.1，则\r\n[code=java]\r\nprintf(#[Fields]\"i=%d, j=%d, k=%f\"#,i,j,k);\r\n[\/code]\r\n中的格式控制字符串为\"i=%d,j=%d,k=%f\"，其中除％和后续的一个字符作为格式控制字符外，其它字符原样输出。若输出遇到一个格式控制字符时，就要依次到输出表列中寻找一个输出对象，在光标当前位置把输出对象按格式控制字符指定的格式输出。因此上述函数的输出结果为i=1，j=2，k=0.1，注意用％f输出实型数据时，默认输出6位小数。\r\n格式控制字符的选用应与输出对象的数据类型一致，否则不能得到正确结果。格式控制字符的个数一般也应与输出对象的个数相等，若不相等，编译时不会给出错误提示，但是可能出现不正常的输出结果。若格式控制字符的个数少于输出对象的个数，则依次输出格式控制字符个数的输出对象，多余的输出对象无效；若格式控制字符的个数多于输出对象的个数，也依次输出格式控制字符个数的数据，但只有前面的几个（即输出对象个数）数据有效，而后续的输出数据为随机值，是无效的。\r\n若要输出百分号“％”，如要输出\r\n[code=java]\r\n1\/4＝25%\r\n[\/code]\r\n则格式如下：\r\n[code=java]\r\nprintf(#[Fields]\"1\/4=%d%%\"#,25);\r\n[\/code]\r\n其中的％d用以输出25，而％％用以输出一个的百分号。",
        8,
        102,
        1
      ],
      [
        203,
        "数据的输入",
        "本节中数据的输入以终端键盘为处理对象，即程序接收用户从键盘输入的数据。\r\n[color=blue]字符输入函数getchar\r\n与putchar函数相对应，getchar函数的作用是接收从键盘输入的单个字符。当程序执行到该函数时，将等待用户从键盘输入一个字符，然后再继续后续程序的执行。其一般调用形式如下：\r\n[code=java]\r\n#[Keywords]char #a;\r\ngetchar (a);\r\n[\/code]\r\n例0.5：下面给出了使用getchar函数的程序。\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n\t#[Keywords]char #a;\r\n\t#a=getchar();\r\n\t#putchar(a);\r\n\t#printf(#[Fields]\"\\n\"#);\r\n#}\r\n[\/code]\r\n程序执行到getchar后将等待用户输入字符，然后putchar再将刚才输入的字符显示到屏幕上。\r\n[color=blue]格式输入函数scanf\r\ngetchar函数只能接收从键盘输入的单个字符，与printf函数相对应，scanf函数是具有格式控制的输入函数，可以用于输入C语言中任意类型的数据，而且可以一次同时输入多个相同类型或不同类型的数据。共一般调用形式如下：\r\nscanf(格式控制，输入地址表列);\r\n该函数括号内包括两部分：\r\n[color=blue]1、格式控制\r\n格式控制是用双引号括起来的字符串，也称为“格式控制转换字符串”，其中包括格式说明和需要原样输入的普通字符。格式说明部分中“％”和格式控制字符组成，如％c、％d和％f等，共作用是将输入的数据转换成指定的格式后存入到地址表列所指向的变量中。\r\nscanf函数中使用的格式字符与printf函数中使用的一样。\r\n[color=blue]2、输入地址表列\r\n输入地址表列用以指明键盘输入数据的保存位置，即输入对象，它必须是地址形式，如变量的地址。如果有多个输入对象，则多个输入地址之间用逗号隔开。在C语言中变量的地址可以内取地址运算符“＆”得到，如变量a的地址可写成&a。关于地址概念的详细介绍，请参见后续“指针”一节。\r\n例0.6：利用scanf函数，从键盘中输入2个整数，1个浮点数和一个字符，代码如下：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n\t#[Keywords]int #i,j;\r\n\t#[Keywords]float #c;\r\n\t#[Keywords]char #a;\r\n\t#scanf(#[Fields]\"i=%d,j=%d,%f,%c\"#,&i,&j,&c,&a);\r\n\t#printf(#[Fields]\"i=%d,j=%d, f=%f,a= %c\\n\"#,i,j,c,a);\r\n#}\r\n[\/code]\r\n上述程序执行到scanf函数时，需要用户从键盘输入数据，才能继续执行后续语句。程序执行结果如下：\r\n[code=java]\r\ni=2,j=3,1.5,c #[Tags]\/*此处为用户输入数据*\/#\r\ni=2,j=3, f=1.500000,a= c #[Tags]\/*程序输出结果*\/#\r\n[\/code]\r\n在使用scanf函数时还应注意以下问题：\r\n1）scanf函数中的每个输入格式控制符，都必须在输入参数表列中有一个输入对象与之对应，且格式符必须与相应的输入对象类型一致，即把输入数据保存到对应的输入对象中。\r\n2）当格式控制符之间没有任何字符时，在输入数据时，键盘输入的数据之间可以用空格、回车或Tab键间隔。如果格式符之间包含其它字符，则应输入与这些字符相同的字符作为间隔，如上例中的“i=2”、“j=3”和“，”，即格式符之间的其它字符必须原样输入，否则不能把数据存入相应的输入对象。\r\n应该注意，在输入字符型数据时，由于任何字符都能作为有效字符输入，因此，不必用空格、回车或Tab键作为间隔。\r\n3）可以在格式符的前面指定输入数据所占的宽度，系统能自动按此宽度裁取相应宽度的数据。如：\r\n[code=java]\r\nscanf(#[Fields]\"%3d,%2d\"#,&i,&j);\r\n[\/code]\r\n当键盘输入12345时，系统能自动地把123赋给变量i，将345赋给变量j。这种方式也可用于字符型数据的输入，但不能用于实型数据的输入。如\r\n[code=java]\r\nscanf(#[Fields]\"%6.3f\"#,&c)\r\n[\/code]\r\n是非法的，不能企图通过程盘输入123456而使f的值为120.456，即输入实型数据时不能规定精度。\r\n4）需要再次强调的是，用以指明输入对象的输入地址表列必须是地址形式，如要把键盘输入保存到变量中，则要用变量的地址，而不是变量名。如果只写变量名，编译不会出错，但程序执行时，就会出现混乱。请在学习后续章节中的指针等内容后，仔细加以体会。\r\n例0.7：编写程序，输入长方体的长、宽、高，计算长方体的表面积和体积。\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n\t#[Keywords]float #length,width,height;\r\n\t#[Keywords]float #area,volume;\r\n\t#printf(#[Fields]\"Input length,width,height:\\n\"#);\r\n\t#scanf(#[Fields]\"%f,%f,%f\"#,&length,&width,&height);\r\n\t#area=2*(length*width+length*height+width*height); \/*计算长方体表面积*\/\r\n\t#volume=length*width*height; \/*计算长方体体积*\/\r\n\t#printf(#[Fields]\"%f,%f,%f\\n\"#,length,width,height);\r\n\t#printf(#[Fields]\"The surface area is %f, volume is %f\\n\"#,area,volume);\r\n#}\r\n[\/code]\r\n执行到scanf函数时，需要用户从键盘输入长方体的长、宽、高，然后计算相应的表面积和体积，最后输出输入的长、宽、高以及表面积和体积。",
        8,
        102,
        1
      ],
      [
        300,
        "流程控制",
        "",
        9,
        103,
        1
      ],
      [
        301,
        "流程控制",
        "通常的计算机程序总是由若干条语句组成，从执行方式上看，从第一条语句到最后一条语句完全按顺序执行，是简单的顺序结构；若在程序执行过程当中，根据用户的输入或中间结构去执行不同的任务则为选择结构；如果在程序的某处，需要根据某些条件重复的执行某项任务若干次或直到满足或不满足某条件为止，则是循环结构。大多数情况下，程序都不会是简单的顺序结构，而是顺序、选择、循环三种结构的复杂组合。\r\nC语言中，有一组相关的控制语句，用以实现选择与循环结构，本节进行简单介绍。",
        8,
        103,
        1
      ],
      [
        302,
        "条件控制语句",
        "在程序的三种基本结构中，第二种即为选择结构，其基本特点是：程序的流程由多路分支组成，在程序的一次执行过程中，根据不同的情况，只有一条支路被选中执行，而其他分支语句被直接跳过。\r\nC语言中，提供if语句和switch语句选择结构，if语句用于两者选一的情况，而switch用于多分支选一的情形。\r\n[code=java]if语句\r\nif条件选择语句是用来判定所给定的条件是否满足，根据判定的结果（真或假）决定给出的两种操作之一。\r\nif语句的一般形式如下：\r\n[code=java]\r\n#[Keywords]if#(表达式)\r\n\t语句1\r\n#[Keywords]else#\r\n\t语句2\r\n[\/code]\r\nif语句的执行过程是：首先计算表达式的值，若表达式的值为真（即表达式为非零值），则执行语句1，若表达式的值为假（即表达式的值为零），则执行语句2。如：\r\n[code=java]\r\n#[Keywords]if#(a==1)\r\n\tb=2;\r\n#[Keywords]else#\r\n\tb=0;\r\n[\/code]\r\n当a等于1时，b的值为2，否则b的值为0。\r\n在使用if语句时，需要注意以下几个问题：\r\n1）if后的圆括号中除了可以用关系表达式和逻辑表达式作为判断的条件外，还可以是任意类型的表达式，如算术表达式。例如if(a+ b)是以a+b的值是否为0作为判断的条件，而1f(!(a+b))则以a+b的值是否为非零作为判断的条件。\r\n2）在if语句中可以省略else和语句2部分，这时if语句的形式如下：\r\n[code=java]\r\nif(表达式) 语句1\r\n[\/code]\r\n它是上述一般if语句的一种特殊情况，执行过程是：当表达式的值为真的，执行语句1，否则直接转到此if语句的下一条语句去执行。\r\n3）if语句也可用相应的由条件表达式构成的赋值语句来实现。如以下if语句\r\n[code=java]\r\n#[Keywords]if#(表达式1)\r\n\ta＝表达式2;\r\n#[Keywords]else#\r\n\ta=表达式3;\r\n[\/code]\r\n可以用下面的赋值语句实现：\r\n[code=java]\r\na＝表达式1? 表达式2:表达式3;\r\n[\/code]\r\n4）在if语句中，语句1和语句2既可以是单个语句，也可以是出多个语句组成。但当语句1和语句2是由多个语组成时，需要用花括号{}括起来，构成复合语句，因为在C语言中，复合语句当成一个语句来处理。\r\n5）if语句本身可以嵌套使用。也就是说，if语句中的语句1和语句2还可以是if语句。如：\r\n[code=java]\r\n#[Keywords]if#(…)\r\n\t#[Keywords]if#(…)\r\n\t\t语句1\r\n\t#[Keywords]else#\r\n\t\t语句2\r\n#[Keywords]else #\r\n\t#[Keywords]if#(…)\r\n\t\t语句3\r\n\t#[Keywords]else#\r\n\t\t语句4\r\n[\/code]\r\n由于if语句中的else可以省略，所以，当if语句嵌套使用时，会出现if与else的配对问题。如：\r\n[code=java]\r\n#[Keywords]if#(…)\r\n\t#[Keywords]if#(…)\r\n\t\t语句1\r\n#[Keywords]else#\r\n[\/code]\r\n在上面的语句中，有两个if和一个else，显然else与不同的if配对，则语句的执行效果不同。虽然eIse在书写上与第一个if对齐，但实际上它不与第一个if配对。C语言规定，else总是与其前面最近且未配对的if配对，而与书写对齐方式无关。根据此规定，上面语句中的else与第二个if配对，等效于\r\n[code=java]\r\n#[Keywords]if#(…)\r\n{ \t#[Keywords]if#(…)\r\n\t\t语句1\r\n\t#[Keywords]else#\r\n\t\t语句2\r\n}\r\n[\/code]\r\n如果要改变这种默认的配对关系，使得else与第一个if配对，可以在相应的if语句中加上花括号{}来确定新的配对关系，如：\r\n[code=java]\r\n#[Keywords]if#(…)\r\n{\t#[Keywords]if#(…)\r\n\t\t语句1\r\n}\r\n#[Keywords]else#\r\n\t语句2\r\n[\/code]\r\n6）嵌套的if语句有一种特殊形式，用以处理多种不同的情况：\r\n[code=java]\r\n#[Keywords]if#(表达式1) 语句1\r\n#[Keywords]else if#(表达式2) 语句2\r\n#[Keywords]else if#(表达式3) 语句3\r\n…\r\n#[Keywords]else if#(表达式i) 语句i\r\n#[Keywords]else #语句j\r\n[\/code]\r\n当嵌套的if语句较多时，程序冗长，结构相对复杂，不明显直观，降低了程序的可读性，可以改用下节介绍的switch多分支选择语句来处理。",
        8,
        103,
        1
      ],
      [
        303,
        "switch语句",
        "上节介绍的if条件选择语句—般适用于两路选择，即在两个分支中选择其中一个分支执行，虽然可以用嵌套的if语句或不嵌套的多个if语句来实现多路选择，但这样使得程序冗长，可读性降低。C语言中的swithc多分支选择语句，可更方便地直接用于多分支选挥。\r\nswitch多分支选择语句的—般形式如下：\r\n[code=java]\r\n#[Keywords]switch#(表达式)\r\n{ \t#[Keywords]case #常量表达式1: 语句1\r\n\t#[Keywords]case #常量表达式2: 语句2\r\n\t#[Keywords]case #常量表达式3: 语句3\r\n\t…\r\n\t#[Keywords]case #常量表达式k: 语句k\r\n\t#[Keywords]default#: 语句k+1\r\n}\r\n[\/code]\r\nswitch语句的执行过程是，当switch后面（）中的表达式的值与某一个case后面的常量表达式的值相等时，就执行此case后面的语句。若所有case中的常量表达式的值都没有与该表达式的值匹配的，就执行default后面的语句。\r\n需要说明的是：\r\n1）switch后面（）中的表达式，可以是整型或字符型表达式，也可以是枚举型数据。作为多分支选择判断的条件必须是整型、字符型或枚举型表达式，即其值为整数。\r\n2）每一个case后面跟的是一个常量表达式，不能是变量表达式。即switchh后面（）中的表达式只能与常量表达式的值进行匹配比较。\r\n3）每一个case的常量表达式的值必须互不相同，否则就会出现矛盾的现象（对表达式的值，有多个匹配对象，就有两种或多种执行方案）\r\n4）执行完一个case后面的语句后，流程控制转移到下—个case继续执行。“case常量表达式”只是起语句标号作用，并不是在该处进行判断。在执行switch语句时，根据switch后面表达式的值找到匹配的入口地址，就从此标号开始执行，不再进行判断。因此，应该在执行一个case分支后，要使流程跳出switch语句的执行，即终止switch的执行。可以用一个break语句来实现，即在每一个case后的语句之后加上break语句。\r\n在case后面可以包含一个以上语句，但可以不必用花括号括起来作为复合语句，因为系统会自动执行本case后的所有语句。当然，加上花括号构成复合语句也可以。\r\n例0.8：输入10以内的数字，输出对应的英文单词，即1输出one，2输出two，3输出three …。\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n\t#[Keywords]int #a;\r\n\t#printf(#[Fields]\"input integer number(<10): \"#);\r\n\t#scanf(#[Fields]\"%d\"#,&a);\r\n\t#[Keywords]switch #(a){\r\n\t\t#[Keywords]case #1:printf(#[Fields]\"one\\n\"#);#[Keywords]break#;\r\n\t\t#[Keywords]case #2:printf(#[Fields]\"two\\n\"#);#[Keywords]break#;\r\n\t\t#[Keywords]case #3:printf(#[Fields]\"three\\n\"#);#[Keywords]break#;\r\n\t\t#[Keywords]case #4:printf(#[Fields]\"four\\n\"#);#[Keywords]break#;\r\n\t\t#[Keywords]case #5:printf(#[Fields]\"five\\n\"#);#[Keywords]break#;\r\n\t\t#[Keywords]case #6:printf(#[Fields]\"six\\n\"#);#[Keywords]break#;\r\n\t\t#[Keywords]case #7:printf(#[Fields]\"seven\\n\"#);#[Keywords]break#;\r\n\t\t#[Keywords]case #8:printf(#[Fields]\"eight\\n\"#);#[Keywords]break#;\r\n\t\t#[Keywords]case #9:printf(#[Fields]\"nine\\n\"#);#[Keywords]break#;\r\n\t\t#[Keywords]default#:printf(#[Fields]\"error\\n\"#);\r\n\t#}\r\n#}\r\n[\/code]\r\n程序执行结果如下：\r\n[code=java]\r\ninput integer number(<10): 3 #[Tags]\/*输入数字3*\/#\r\nthree #[Tags]\/*程序输出结果*\/#\r\ninput integer number(<10): 11 #[Tags]\/*输入数字11*\/#\r\nerror #[Tags]\/*程序输出结果*\/#\r\n[\/code]",
        8,
        103,
        1
      ],
      [
        304,
        "循环控制语句-for语句",
        "循环控制结构是程序中的另一个基本结构。循环结构可以使我们只写很少的语句而让计算机反复执行，从而完成大量雷同的计算。\r\nC语言提供了for语句、while语句、do…while语句实现循环结构。\r\n[color=blue]for语句\r\nfor语句的一般格式为：\r\n[code=java]\r\n#[Keywords]for #( 初始表达式; 循环条件; 循环表达式)\r\n\t循环体\r\n[\/code]\r\n说明：\r\n1）初始表达式，用于循环开始前，为循环变量设置初始值。\r\n2）循环条件是一个逻辑表达式，若该式取值为真，即条件满足，则继续执行循环，否则，执行循环体后的语句。\r\n3）循环表达式定义了每次循环时，循环变量的变化情况。\r\n4）循环体可以是一条语句或一组语句，若是一组语句，需要用{}括起来。\r\n例0.9：用for循环语句打印输出1~10。\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n\t#[Keywords]int #i;\r\n\t#for(i=1;i<=10;i++)\r\n\t#printf(#[Fields]\"%d\\n\"#,i);\r\n#}\r\n[\/code]\r\n上述程序的执行过程是：\r\n1）计算初始表达式（i=1）。\r\n2）判断循环条件（i<=10?），若满足，则执行；否则，退出循环。\r\n3）执行循环。\r\n4）返回第2)步。\r\n在整个for 循环过程中，初始表达式只计算一次，循环条件和循环表达式则可能计算多次。循环体可能多次执行，也可能一次都不执行。\r\n例0.10：用for语句计算1+2+…+1000。\r\n[code=java]\r\n#include <stdio.h>\r\nmain()\r\n{\r\n\t#[Keywords]int #i,sum=0;\r\n\t#[Keywords]for#(i=1;i<=1000;i++)\r\n\t#sum+=i;\r\n\t#printf(#[Fields]\"1+2+...+1000= %d\\n\"#,sum);\r\n#}\r\n[\/code]\r\n在for循环中，循环变量的值可以带动循环体中。在上面的程序中，sum+=i；等同于sum=sum+i；是C语言中更简练、更常用的形式，程序执行结果如下：\r\n[code=java]\r\n1+2+...+1000= 500500\r\n[\/code]",
        8,
        103,
        1
      ],
      [
        305,
        "while语句",
        "while循环语句的一般形式下：\r\n[code=java]\r\n#[Keywords]while #( 表达式)\r\n\t语句\r\n[\/code]\r\n其执行过程是：先计算while后面圆括号内表达式的值，如果其值为“真”(非0)，则执行语句部分(即循环体)。然后，再次计算while后面圆括号内表达式的值，并重复上述过程，直到表达式的值为“假”(0)时，退出循环，并转向该循环语句下面的后续语句去执行。如上面计算1+2+…+1000用while语句可表示为：\r\n[code=java]\r\n#[Keywords]int #i=1,sum=0;\r\n#[Keywords]while#(i<=1000)\r\n\t#{sum+=i;i++;#}\r\n[\/code]\r\n使用while语句时，应注意以下几个问题：\r\n1）while后面圆括号内的表达式用作循环判断条件，以决定是执行循环体还是退出循环。该表达式可以是比较表达式和逻辑表达式，也可以是其它任意表达式。如whlle(i=1){…}，表达式i=1为赋值表达式，其值为1，即循环条件永远为“真”，故该循环是死循环。\r\n2）while语句的特点是先判断表达式的值，然后执行循环体中的语句，即先判断，后执行，用来实现“当”型循环结构。因此，当执行到while循环语句时，若表达式的值一开始就为“假”，则循环体—次也不执行。\r\n3）当循环体由多个语句织成时，必须用花括号{}把它们括起来作为一条复合语句，即在C语言中总是只把while()后的第一条语句作为循环体。\r\n例0.11：用while语句计算10！。\r\n[code=java]\r\n#include <stdio.h>\r\nmain()\r\n{\r\n\t#[Keywords]int #i=1,result=1;\r\n\t#while(i<=10)\r\n\t#{\r\n\t\t#result*=i;\r\n\t\t#i++;\r\n\t#}\r\n\t#printf(#[Fields]\"10!=%d\\n\"#,result);\r\n#}\r\n[\/code]\r\n程序的执行结果如下：\r\n[code=java]\r\n10!=3628800\r\n[\/code]",
        8,
        103,
        1
      ],
      [
        306,
        "do-while语句",
        "do-while语句的一般形式如下：\r\n[code=java]\r\n#[Keywords]do#\r\n\t#循环体语句\r\n#[Keywords]while #(表达式);\r\n[\/code]\r\n其执行过程如下：先执行作为循环体的语句，再计算圆括号内表达式的值，若表达式的值为“真”，则再次执行循环体。如此循环，直到表达式的值为“假”时，结束循环，并转到do-while语句下面的后续语句去执行。如计算1+2+…+1000用do-while语句可表示为：\r\n[code=java]\r\n#[Keywords]int #i=1,sum=0;\r\n#[Keywords]do#\r\n{ \r\n\t#sum+=i;\r\n\t#i++;\r\n#}\r\n#[Keywords]while#(i<=1000);\r\n[\/code]\r\n在书写上应该注意，while后面圆括号中的右因括号“)”的后面还有一个分号“；”，不能遗漏。\r\ndo-while语句的特点是先执行循环体中的语句，然后判断表达式的值，即先执行，后判断，用来实现“直到”型循环结构：因此，循环体语句至少被执行一次，这—点同while语句有所区别。其他注意事项同while语句在此不在赘述。\r\n例0.12：用do-while语句计算1+1\/2+…+1\/1000的和。\r\n[code=java]\r\n#include <stdio.h>\r\nmain()\r\n{\r\n\t#[Keywords]int #i=1;\r\n\t#[Keywords]float #sum=0;\r\n\t#[Keywords]do#{\r\n\t\t#sum+=1.0\/i;\r\n\t\t#i++;\r\n\t#}\r\n\t#[Keywords]while#(i<=1000);\r\n\t#printf(#[Fields]\"1+1\/2+...+1\/1000= %f\\n\"#,sum);\r\n#}\r\n[\/code]\r\n由于计算中带有浮点数，因此sum定义为float型。程序执行结果如下：\r\n[code=java]\r\n1+1\/2+...+1\/1000= 7.485478\r\n[\/code]",
        8,
        103,
        1
      ],
      [
        307,
        "循环的嵌套",
        "一个循环的循环体中有另一个循环叫循环嵌套。这种嵌套过程可以有很多重。一个循环外面仅包围一层循环叫二重循环；一个循环外面包围两层循环叫三重循环；一个循环外面包围多层循环叫多重循环。\r\n三种循环语句for、while、do-while可以互相嵌套自由组合。但要注意的是，各循环必须完整，相互之间绝不允许交叉。\r\n例0.13：在屏幕上输出5行由“*”构成的三角形图案。\r\n[code=java]\r\n#include <stdio.h>\r\nmain()\r\n{\r\n\t#[Keywords]int #i,j;\r\n\t#[Keywords]for#(i=1;i<=5;i++)\r\n\t#{\r\n\t\t#[Keywords]for#(j=1;j<=i;j++)\r\n\t\t#printf(#[Fields]\"*\"#);\r\n\t\t#printf(#[Fields]\"\\n\"#);\r\n\t#}\r\n#}\r\n[\/code]\r\n上面的程序中包含了2重for循环，内层循环根据外层循环变量i的值，输出每一行对应的“*”，在每次内层循环结束后，外层循环输出换行符，然后继续下一次内层循环，直至输出所有的“*”。程序的执行结果如下：\r\n[code=java]\r\n*\r\n**\r\n***\r\n****\r\n*****\r\n[\/code]\r\n读者可以自行用while、do-while循环嵌套语句实现上面的程序，在此不再赘述。",
        8,
        103,
        1
      ],
      [
        308,
        "goto、break和continue语句",
        "程序中的语句通常总是按顺序方向，或按语句功能所定义的方向执行的。如果需要改变程序的正常流向，可以使用本小节介绍的转移语句。在Ｃ语言中提供了4种转移语句：goto,break,continue和return。其中的return语句只能出现在被调函数中， 用于返回主调函数，我们将在函数一章中具体介绍。本小节介绍前三种转移语句。\r\n[color=blue]1、goto语句\r\ngoto 语句也称为无条件转移语句，其一般格式如下：\r\n[code=java]\r\ngoto 语句标号;\r\n[\/code]\r\n其中语句标号是按标识符规定书写的符号，放在某一语句行的前面，标号后加冒号“：”。语句标号起标识语句的作用，与goto语句配合使用。如：\r\n[code=java]\r\nlabel: i++;\r\n…\r\ngoto label;\r\n[\/code]\r\nＣ语言不限制程序中使用标号的次数，但各标号不得重名。goto 语句的语义是改变程序流向， 转去执行语句标号所标识的语句。\r\ngoto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。但是，在现代程序设计中一般不主张使用goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。因此现在程序中极少见到goto语句的使用。\r\n[color=blue]2、break语句\r\n前面已经介绍，break语句能够跳出switch语句，转入switch语句的下一语句执行。在while、do-while、for循环语句中，一般通过对作为循环条件的表达式的检测来决定是否终止执行循环。此外，在循环体中，也可以利用break语句来立即终止循环的执行。\r\nbreak语句的一般形式如下：\r\n[code=java]\r\nbreak;\r\n[\/code]\r\n其执行过程是终止包含它的switch或循环语句的执行，即跳出这2种语言，而转动下一语句执行。如：\r\n[code=java]\r\n#[Keywords]int #i,sum=1;\r\n#[Keywords]for#(i=1;;i++)\r\n#{\r\n\t#sum*=i;\r\n\t#if(i==10) #[Keywords]break#;\r\n#}\r\n[\/code]\r\n在此for语句中省略了循环条件表达式，即循环条件永远为“真”，利用循环体中的break语句来终止该循环语句的执行。\r\n使用break语句时应注意以下问题：\r\n1）break语句只能用于循环语句或switch语句中，且一般与if语句一起使用。如：\r\n[code=java]\r\nif(…) break;\r\n[\/code]\r\n该语句一定位于循环体中或switch语句中，当if(…)中的表达式为“真”，则break语句跳出的不是if语句，而是跳出包含此if语句的循环语句或switch语句。\r\n2）对于嵌套的循环语句或嵌套的switch语句，break只能跳出（或终止）它所在的那一层循环或switch语句，而不能同时跳出多层循环语句或switch语句。\r\n[color=blue]3、continue语句\r\ncontinue语句的作用与break语句有些类似，也是用来控制程序流程，但它只能出现在循环体中，而不能出现任switch语句中。它的作用在于跳过循环体中该conthue语句后面的其它语句，并立即开始下一轮循环条件的判定。所以它与break语句不同，并不终止整个循环语句的执行。\r\ncontinue语句的一般形式如下：\r\n[code=java]\r\ncontinue;\r\n[\/code]\r\n其执行过程是：结束本次循环，即跳过循环体中该continue语句后面的语句，而立即进行下一次是否继续执行循环的判定。对于while和do-while语句来说，也就是立即求解作为循环条件的表达式，而对于for语句来说，也就是立即求解循环表达式。\r\n例0.14：输出100以内能被6整除的整数。\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n\t#[Keywords]int #i;\r\n\t#[Keywords]for#(i=6;i<=100;i++)\r\n\t#{\r\n\t\t#[Keywords]if #(i%6!=0)\r\n\t\t#[Keywords]continue#;\r\n\t\t#printf(#[Fields]\"%d \"#,i);\r\n\t#}\r\n\t#printf(#[Fields]\"\\n\"#);\r\n#}\r\n[\/code]\r\n上述程序利用求余运算符“%”判断能否被6整除，若能整除，则输出该整数，否则进行下一次循环。程序执行结果为：\r\n[code=java]\r\n6 12 18 24 30 36 42 48 54 60 66 72 78 84 90 96\r\n[\/code]",
        8,
        103,
        1
      ],
      [
        400,
        "函数",
        "",
        9,
        104,
        1
      ],
      [
        401,
        "函数",
        "在C语言中，函数是程序的基本组成单位，因此可以很方便地用函数作为程序模块来实现C语言程序。\r\n利用函数，不仅可以实现程序的模块化，程序设计得简单和直观，提高了程序的易读性和可维护性，而且还可以把程序中普通用到的一些计算或操作编成通用的函数，以供随时调用，这样可以大大地减轻程序员的代码工作量。\r\n在Ｃ语言中可从不同的角度对函数分类：\r\n1、从函数定义的角度看，函数可分为库函数和用户定义函数两种。\r\n1）库函数\r\n由Ｃ系统提供，用户无须定义，也不必在程序中作类型说明，只需在程序前包含有该函数原型的头文件即可在程序中直接调用。在前面各节的例题中用到printf、scanf、getchar、putchar等函数均属此类。\r\n2）用户定义函数\r\n由用户按需要写的函数。对于用户自定义函数， 不仅要在程序中定义函数本身， 而且在主调函数模块中还必须对该被调函数进行类型说明，然后才能使用。\r\n2、Ｃ语言的函数兼有其它语言中的函数和过程两种功能，从这个角度看，又可把函数分为有返回值函数和无返回值函数两种。\r\n1）有返回值函数\r\n此类函数被调用执行完后将向调用者返回一个执行结果， 称为函数返回值。如数学函数即属于此类函数。由用户定义的这种要返回函数值的函数，必须在函数定义和函数说明中明确返回值的类型。\r\n2）无返回值函数\r\n此类函数用于完成某项特定的处理任务，执行完成后不向调用者返回函数值。这类函数类似于其它语言的过程。由于函数无须返回值，用户在定义此类函数时可指定它的返回为“空类型”，空类型的说明符为“void”。\r\n3、从主调函数和被调函数之间数据传送的角度看又可分为无参函数和有参函数两种。\r\n1）无参函数\r\n函数定义、函数说明及函数调用中均不带参数。主调函数和被调函数之间不进行参数传送。此类函数通常用来完成一组指定的功能，可以返回或不返回函数值。\r\n2）有参函数\r\n也称为带参函数。在函数定义及函数说明时都有参数， 称为形式参数(简称为形参)。在函数调用时也必须给出参数， 称为实际参数(简称为实参)。进行函数调用时，主调函数将把实参的值传送给形参，供被调函数使用。\r\n4、Ｃ语言提供了极为丰富的库函数， 这些库函数如表3-4所示。\r\n[code=java]\r\n表 3-4 C语言提供的库函数\r\n函数\t作用\r\n字符类型分类函数\t用于对字符按ASCII 码分类：字母，数字，控制字符，分隔符，大小写字母等。\r\n转换函数\t用于字符或字符串的转换；在字符量和各类数字量 (整型， 实型等)之间进行转换；在大、小写之间进行转换。\r\n目录路径函数\t用于文件目录和路径操作。\r\n诊断函数\t用于内部错误检测。\r\n图形函数\t用于屏幕管理和各种图形功能。\r\n输入输出函数\t用于完成输入输出功能。\r\n字符串函数\t用于字符串操作和处理。\r\n内存管理函数\t用于内存管理。\r\n数学函数\t用于数学函数计算。\r\n日期和时间函数\t用于日期，时间转换操作。\r\n进程控制函数\t用于进程管理和控制。\r\n其它函数\t用于其它各种功能。\r\n[\/code]\r\n以上各类函数不仅数量多，而且有的还需要硬件知识才会使用，因此要想全部掌握则需要一个较长的学习过程。应首先掌握一些最基本、最常用的函数，再逐步深入。由于篇幅关系，本书只介绍了很少一部分库函数， 其余部分读者可根据需要查阅有关手册。",
        8,
        104,
        1
      ],
      [
        402,
        "函数定义",
        "C语言函数定义的一般形式是：\r\n[code=java]\r\n类型说明符函数名 (数据类型形式参数1, 数据类型形式参数2, …, 形式参数n)\r\n{\r\n\t说明部分 \/*函数体*\/\r\n\t语句部分\r\n}\r\n[\/code]\r\n类型说明符定义了函数中返回语句返回值的类型，函数返回值不能是数组，也不能是函数，除此之外任何合法的数据类型都可以是函数的类型。在很多情况下都不要求无参函数有返回值，此时函数类型符可以写为void。当一个函数没有明确说明类型时，C语言的编译程序自动将整型（int）作为这个函数的缺省类型，缺省类型适用于很大一部分函数。当有必要返回其它类型数据时，需要分两步处理：首先，必须给函数以明确的类型说明符；其次，函数类型的说明必须处于对它的首次调用之前。只有这样，C编译程序才能为返回非整型的值的函数生成正确代码。\r\n函数名是用户自定义的标识符，是C语言函数定义中惟一不可省略的部分，需符合C语言对标识符的规定，即由字母，数字或下划线组成，用于标识函数，并用该标识符调用函数。另外，函数名本身也有值，它代表了该函数的入口地址，使用指针调用该函数时，将用到此功能。\r\n形式参数用于主调函数利被调函数之间进行数据的传递。需要对形式参数进行类型说明。形式参数表可以是空的，表示该函数为无参函数，即调用该函数时，不需要参数；形式参数表也可以由逗号分开的多个形式参数组成，表示该函数为有参函数，即调用该函数时，需要为其提供参数。形式参数表说明可以有两种表示形式：\r\n[code=java]\r\n类型说明符函数名 (数据类型形式参数1, 数据类型形式参数2, …, 数据类型形式参数n)\r\n{ … }\r\n[\/code]\r\n或：\r\n[code=java]\r\n类型说明符函数名 (形式参数1,形式参数2, …, 形式参数n)\r\n数据类型形式参数1;\r\n数据类型形式参数2;\r\n…\r\n数据类型形式参数n;\r\n{ … }\r\n[\/code]\r\n不管形式参数表中是否有参数，都要用左、右圆括号括起来。形式参数可以是变量、数组、指针等，但不能是表达式或常量，因为形式参数用来存放从主调函数传递的实参的值，需要有相应的存储空间。\r\n在函数体的说明部分主要对本函数中用到的有关变量进行定义，说明变量的数据类型，以便后面的语句正确使用变量。函数内定义的变量不可以与形参同名。函数体的语句部分完成函数应的规定的运算，执行的规定的动作，集中体现函数的功能。\r\n应该指出的是，在Ｃ语言中，所有的函数定义，包括主函数main在内，都是平行的，函数定义的位置必须放在所有函数的外部。也就是说，在一个函数的函数体内， 不能再定义另一个函数， 即不能嵌套定义。但是函数之间允许相互调用，也允许嵌套调用。\r\n习惯上把调用者称为主调函数。函数还可以自己调用自己，称为递归调用。main函数是主函数，它可以调用其它函数，而不允许被其它函数调用。因此，Ｃ程序的执行总是从main函数开始，完成对其它函数的调用后再返回到main函数，最后由main函数结束整个程序。一个Ｃ源程序必须有，也只能有一个主函数main。",
        8,
        104,
        1
      ],
      [
        403,
        "返回语句",
        "C语言中的返回语句有下列形式：\r\n[code=java]\r\n#[Keywords]return #表达式;\r\n[\/code]\r\n返回语句的作用有两个，一是把控制返回给调用者(函数)，另一是向调用者传递有关信息。例如：\r\n[code=java]\r\n#[Keywords]retrun#;\r\n#[Keywords]return #-1;\r\n#[Keywords]retrun #x+y;\r\n#[Keywords]retrun #++x;\r\n[\/code]\r\n上例中第一个语句没有返回任何值，只是把控制返回给了调用者，而其余的既返回了控制，又返回了值。\r\n一个函数中的返回语句可以有一个、多个或没有，若在执行一个函数时没遇到return语句，则从这个函数的末尾一个语句后返回，或者可以认为函数体大括号“}”前有一个无形的return语句(不带返回值)。\r\n所有非空值的函数都会返回一个值。我们编写的程序中大部分函数属于三种类型。第一种类型是简单计算型－函数设计成对变量进行运算，并且返回计算值。计算型函数实际上是一个“纯”函数，例如sqrt函数（开方运算）和sin函数（正弦运算）。第二类函数处理信息，并且返回一个值，仅以此表示处理的成功或失败。例如write函数，用于向磁盘文件写信息。如果写操作成功了，write函数返回写入的字节数，当函数返回-1时，标志写操作失败。最后一类函数没有明确的返回值。实际上这类函数是严格的过程型函数，不产生值。\r\n对于具有返回值的函数，调用者可以使用这个值，也可以不使用这个值。例如程序段：\r\n[code=java]\r\ngetchar();\r\nc = getchar();\r\n[\/code]\r\n其中第一个getchar执行一次就得到一个字据，但程序不对这个返回值做任何处理，而把接下去第二个getchar得到的字符赋给变量c。\r\n例0.15：编写求1+2+…+n的函数。\r\n[code=java]\r\n#[Keywords]double #fsum (#[Keywords]int #n)\r\n{\r\n\t#[Keywords]int #i;\r\n\t#[Keywords]double #tempsum=0;\r\n\t#[Keywords]if#(n<=0)\r\n\t#{\r\n\t\t#printf(#[Fields]\"Input number is error! %d<=0\\n\"#,n);\r\n\t\t#[Keywords]return #-1.0;\r\n\t#}\r\n\t#[Keywords]for#(i=1;i<=n;i++)\r\n\t\t#tempsum+=i;\r\n\t#[Keywords]return #tempsum;\r\n#}\r\n[\/code]\r\n在上面的程序中，double fsum(int n)是函数的首部，其中fsum是函数名，在它前面的double是类型名，用来说明函数返回值的类型是双精度型。在本例中只有一个形式参数n，其类型为int。\r\n函数体中，除形式参数外，用到的其它变量必须在说明部分进行定义，这些变量(包括形式参数)，只在函数被调用时才临时开辟存储单元、当退出函数时，这些临时开辟的存储单元全被释放掉，因此，这种变量只在函数体内部起作用，与其它函数体中的变量互不相关，它们可以和其它函数中的变量同名。函数体中的说明部分，就像在main函数中那样，总是放在函数体中所有可执行语句之前。fsum函数中定义了一个int类型的变量i、一个double类型的变量tempsum，当退出fsum函数后，这些变量，包括形式参数n所占的存储单元都不再保留。\r\nfsum函数中有两处出现return语句，函数中通过for循环进行连加，求出1+2+…+n，并把结果放在变量tempsum中，最后的return tempsum语句，使流程返回到调用该函数的地方，并把所求得的的值带回，fsum函数的if语句中还有一个语句return -1.0；，在此表示如果n的值小于0，则不能求连加，在退出函数时同时返回-1.0作为出错的标志。",
        8,
        104,
        1
      ],
      [
        404,
        "函数的调用",
        "函数的一般调用形式为：\r\n[code=java]\r\n函数名(实在参数1, 实在参数2, …, 实在参数n)\r\n[\/code]\r\n其中，实在参数是函数调用时，主调函数为被调函数提供的原始数据。若实在参数(简称实参)的个数多于一个时，各实在参数之间用逗号隔开。若函数无形参，调用形式为：\r\n[code=java]\r\n函数名()\r\n[\/code]\r\n函数名后的一对园括号不可少。\r\n可用两种方式调用函数：\r\n1）当所调用的函数用于求出某个值时，函数的调用可作为表达式出现在允许表达式出现的任何地方。例如对于以上的fsum函数，若x为double变量，可用以下语句调用fsum函数，求出10的连加：\r\n[code=java]\r\nx=fsum(10);\r\n[\/code]\r\nfsum函数也可以出现在if语句中作为进行判断的表达式：\r\n[code=java]\r\n#[Keywords]if#(fsum(n)<0) …\r\n[\/code]\r\n2）函数的调用也可作为一条独立的语句，如\r\n[code=java]\r\n函数名(实在参数表);\r\n[\/code]\r\n注意最后有一个分号。\r\n函数调用时的语法要求如下：\r\n1）调用函数时，函数名必须与所调用的函数名字完全一致。\r\n2）实在参数的个数必须与形式参数的个数一致，实在参数可以是表达式，在类型上应按位置与形式参数一一对应匹配。如果类型不匹配，C编译程序按赋值兼容的规则进行转换，若实在参数和形式参数的类型不赋值兼容，通常并不给出出错信息，且程序仍然执行，只是不会得到正确的结果。因此对于初学者来说应该特别注意实在参数和形式参数的类型匹配。\r\n3）C语言规定：函数必须先定义，后调用(函数的返回值类型为im或char时除外)。\r\n如，如果想在main函数中调用0.6.1节的fsum函数、在源程序中它们的位置应该如下：\r\n[code=java]\r\n#[Keywords]double #fsum(#[Keywords]int #n)\r\n{ … #}\r\nmain()\r\n{\r\n\t#[Keywords]int #a;\r\n\t#[Keywords]double #x;\r\n\t#…\r\n\t#x=fsum(a);\r\n\t#…\r\n#}\r\n[\/code]\r\n如果被调用函数的返回值为int或char类型，则被调用函数的定义也可以放在调用的位置之后，例如:\r\n[code=java]\r\nmain()\r\n{\r\n\t…\r\n\tf1();\r\n\t…\r\n}\r\nf1() {…}\r\n[\/code]\r\n4）C程序中，函数可以直接或间接地自己调用自己，称为递归调用。递归是以自身定义的过程。也可称为“循环定义”。\r\n例1：利用递归方法计算n!。\r\n[code=java]\r\nfactor(#[Keywords]int #n) #[Tags]\/* 递归调用方法* \/#\r\n{\r\n\t#[Keywords]int #answer；\r\n\t#[Keywords]if #(n==1)\r\n\t#[Keywords]return #(1);\r\n\t#answer=factor(n-1)*n; #[Tags]\/* 函数自身调用* \/#\r\n\t#[Keywords]retrun #answer;\r\n#}\r\n[\/code]\r\n当用参数1调用factor( )时，函数返回1；除此之外的其它值调用将返回factor(n-1) * n这个乘积。为了求出这个表达式的值，用（n-1）调用factor()一直到n等于1，调用开始返回。",
        8,
        104,
        1
      ],
      [
        405,
        "调用函数和被调用函数之间的数据传递",
        "C语言中，调用函数和被调用函数之间的数据可以通过三种方式进行传递：\r\n1）实在参数和形式参数之间进行数据传递。\r\n2）通过return语句把函数值返回调用函数。\r\n3）通过全局变量(有关全局变量的内容将在下一节介绍)。\r\n在C语言中，数据只能从实在参数单向传递给形式参数，称为‘按值”传递。也即是说，当简单变量作为实在参数时，用户不能在函数中改变对应实在参数的值。\r\n例0.16：以下程序说明了函数参数之间的单向传递。\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]int #a=1;\r\n\t#printf(#[Fields]\"a1=%d\\n\"#,a);\r\n\t#fadd(a);\r\n\t#printf(#[Fields]\"a4=%d\\n\"#,a);\r\n#}\r\nfadd(#[Keywords]int #n)\r\n{\r\n\t#printf(#[Fields]\"a2=%d\\n\"#,n);\r\n\t#n+=3;\r\n\t#printf(#[Fields]\"a3=%d\\n\"#,n);\r\n#}\r\n[\/code]\r\n程序运行结果如下：\r\n[code=java]\r\na1=1\r\na2=1\r\na3=4\r\na4=1\r\n[\/code]\r\n当程序从main函数开始运行时，按定义在内存中开辟了1个int类型的存储单元a且赋初值为1，fadd函数调用之前的printf语句输出结果验证了a的值。当调用fadd函数之后，程序的流程转向fadd函数，这时系统为fadd函数的形参n分配了另外1个临时的存储单元，同时把实参a的值传送给对应的形参n，因此实参和形参虽然同名，但它们却占用不同的存储单元。\r\n当进入fadd函数后，首先执行一条printf语句，输出fadd函数中的n的值，因为未对它们进行任何操作，故仍输出1，当执行了赋值语句n+=3；之后，接着又执行一条printf语句，再一次输出fadd函数中的n的值，输出结果为4；fadd函数执行完后，这时fadd函数中的n变量将消失，并且流程返回到main函数；最后执行main函数中最后一条printf语句，输出了a的值，由输出结果可见main函数中的a的值在调用fadd函数后没有任何变化。\r\n以上程序运行的结果证实了在调用函数时，实参的值将传送给对应的形参，但形参值的变化不会影响对应的实参。",
        8,
        104,
        1
      ],
      [
        406,
        "变量的作用域",
        "C程序结构是模块式的。即一个C源程序是由一个主函数和零个、—个或多个其他函数组成，那么编写函数时，如何命名变量?不同函数中定义的变量是否允许同名?不同的函数能否共享同一组数据？这些问题必须从“变量的作用域”角度来解答。所谓变量的作用域就是指变量能被有效引用的范围。据此，C语言将变量分为“局部变量”和“全局变量”。\r\n[color=blue]1、局部变量\r\n在函数(包括main函数)内部或复合语句内部定义的一切变量(包括形式参数)都是局部变量，它们的作用域仅限于自身所在的函数内部或复合语句内部，出界便无效。因此在不同函数中定义的变量即便同名，仍代表不同的对象。\r\n[color=blue]2、全局变量\r\n在函数外部定义的变量称为“全局变量”。全局变量的作用域为从定义变量的位置开始直至程序结束。因此，全局变量能够供其后面的一切函数引用。\r\n例0.17：下面的程序说明了全局变量的例子。\r\n[code=java]\r\n#[Keywords]int #i=1;\r\nf1()\r\n{\r\n\t#i++;\r\n#}\r\nmain()\r\n{\r\n\t#printf(#[Fields]\"i1=%d\\n\"#,i);\r\n\t#f1();\r\n\t#printf(#[Fields]\"i2=%d\\n\"#,i);\r\n#}\r\n[\/code]\r\n程序的运行结果为：\r\n[code=java]\r\ni1=1\r\ni2=2\r\n[\/code]\r\n因为主函数和f1函数中均未定义名字为i的变量。所以在它们的函数体中出现的变量名i均为程序首部定义的全局变量，在调用f1函数之前，i的值为1，调用之后，i的值已被修改为2，所以i在主函数中的输出值为第1次为1，第2次为2。",
        8,
        104,
        1
      ],
      [
        407,
        "变量的生存期",
        "从变量的作用域原则出发，可以将变量分为全局变量和局部变量；换一个方式，从变量的生存期来分，可将变量分为动态存储变量及静态存储变量。\r\n[color=blue]1、动态存储变量\r\n动态存储变量可以是函数的形式参数、局部变量、函数调用时的现场保护和返回地址。这些动态存储变量在函数调用时分配存储空间，函数结束时释放存储空间。动态存储变量的定义形式为在变量定义的前面加上关键字“auto”，如：\r\n[code=java]\r\nauto #[Keywords]int #a,b,c;\r\n[\/code]\r\n“auto”也可以省略不写。事实上，我们已经使用的变量均为省略了关键字“auto”的动态存储变量。有时为了提高速度，可以将局部的动态存储变量定义为寄存器型的变量，定义的形式为在变量的前面加关键字“register”，例如：\r\nregister float a,b,c;\r\n这样一来的好处是：将变量的值无需存入内存，而只需保存在C P U内的寄存器中，以使速度大大提高。由于CPU内的寄存器数量是有限的，不可能为某个变量长期占用。因此，一些操作系统对寄存器的使用做了数量的限制。或多或少，或根本不提供，用自动变量来替代。\r\n[color=blue]2、静态存储变量\r\n在编译时分配存储空间的变量称为静态存储变量，其定义形式为在变量定义的前面加上关键字“static”，例如：\r\nstatic int i=10; 仅供参考\r\n定义的静态存储变量无论是做全程量或是局部变量，其定义和初始化在程序编译时进行。作为局部变量，调用函数结束时，静态存储变量不消失并且保留原值。\r\n例0.18：静态存储变量的使用\r\n[code=java]\r\nmain( )\r\n{\r\n\t#inf f( );\r\n\t#[Keywords]int #j;\r\n\t#[Keywords]for #(j=1; j<=3; j++)\r\n\t#printf (#[Fields]\"%d\\n\"#，f( ))；\r\n#}\r\n#[Keywords]int #f( )\r\n{\r\n\t#[Keywords]static #[Keywords]int #i=0;\r\n\t#i + + ;\r\n\t#[Keywords]return #i;\r\n#}\r\n[\/code]\r\n程序运行结果：\r\n[code=java]\r\n1\r\n2\r\n3\r\n[\/code]\r\n从上述程序看，函数f被三次调用，由于局部变量x是静态存储变量，它是在编译时分配存储空间，故每次调用函数f时，变量x不再重新初始化，保留加1后的值，得到上面的输出。",
        8,
        104,
        1
      ],
      [
        500,
        "编译预处理",
        "",
        9,
        105,
        1
      ],
      [
        501,
        "编译预处理",
        "在C语言中，我们常常会遇到以“#”号开头的语句，如常量定义语句#define PI 0.14159及文件包含语句#include <stdio.h>，这类语句统称为编译预处理命令。\r\n所谓“编译预处理”就是C编译程序对C源程序进行编译前，由编译顶处理程序对这类编译预处理命令进行处理的过程。将预处理结果和源程序一起再进行通常的编译处理，就得到目标代码。\r\nC语言的预处理命令有：#define，#undef，#include，#if，#else等。\r\n按其功能共分为以下三类：\r\n1）宏定义\r\n2）文件包含\r\n3）条件编译\r\n为了与一般C语言语句相区别，这些命令必须在一行的开头以“#”号开始，末尾不再加“；”号，以区别于C语言的其他语句。这些由预处理命令组成的预处理命令行的语法与C语言中其他部分的语法无关，它们可以根据需要出现在程序的开始及结束部分，其作用一直持续到源文件的末尾，或其他结束其作用的语句出现的位置。本章下面将重点介绍#define、#include等常用命令的应用。",
        8,
        105,
        1
      ],
      [
        502,
        "不带参数的宏定义",
        "不带参数的宏定义命令行形式如下：\r\n[code=java]\r\n#define 宏名替换文本\r\n[\/code]\r\n在define、“宏名”和“替换文本”之间用空格隔开。例如：\r\n[code=java]\r\n#define LENGTH 300\r\n[\/code]\r\n其中标识符LENGTH称为“宏名”，是用户自定义的标识符，不能与同在一段程序中的其他标识符同名。编译时，编译预处理程序对源程序中所有名为LENGTH的标识符用300来替换，这个替换过程称为宏展开。\r\n例0.19：不带参数的宏定义。\r\n[code=java]\r\n#define PI 0.14159\r\nmain()\r\n{\r\n\t#[Keywords]float #r=2.1area;\r\n\t#area=PI*r*r;\r\n\t#printf(#[Fields]\"The Area is %f\\n\"#,area);\r\n#}\r\n[\/code]\r\n上面的程序是求一个圆的面积，在程序的第一行定义了名为PI的宏，圆的半径r=2.1。以上程序的运行结果是：\r\n[code=java]\r\nThe Area is 10.854412\r\n[\/code]\r\n从以上例子可以看到：\r\n仅供参考\r\n1）“宏名”一般用大写字母表示．以示与普通变量名的区别，当然这井非语法上的规定，也可以用小写字母。如：\r\n[code=java]\r\n#define pi 0.14159。\r\n[\/code]\r\n2）使用宏名替代一个字符串，其中一个主要的目的是减少程序中重复书写某些字符串的工作量，比如在程序中一些不太好记忆的参数，重复书写容易出错且很繁琐，这时用宏名来代替该字符串就可以使程序简单明了。其次当程序的一些常量需要改变时，如果没有宏名，那么整个程序用到该常量的地方都需人工一一修改，若用宏名，则只需改变宏定义命令行，一改全改。如在程序开头有以下宏定义：\r\n[code=java]\r\n#define NUM 1000\r\n[\/code]\r\n若需要更改NUM参数的值为100，则只需将#define语句改为：\r\n[code=java]\r\n#define NUM l00\r\n[\/code]\r\n这样就提高了程序的可移植性。\r\n3）同一个宏名不能重复定义。如：\r\n[code=java]\r\n#define PI 0.14159\r\n#define PI 0.1416\r\n[\/code]\r\n二条语句不能同时出现在一段程序中。\r\n4）宏定义是用宏名代替一个字符串，也就是简单的置换，并不作语法检查。如：\r\n[code=java]\r\n#define PI 0.14159\r\n[\/code]\r\n中的0.14159如果输入时不小心将数字1误输为字母i，那么在替换时也照样代入，只有在对已作宏展开后的源程序编译链接时才会出现错误。\r\n5）宏定义与一般C语言语句不同，末尾不能加分号，否则会连分号一起置换。\r\n6）可以用林#undef命令终止宏定义的作用域。一般而言，一个宏定义，从被定义开始直至文件末尾，全程有效。若要更改其作用域则可以用#undef命令。如：\r\n[code=java]\r\n#define AAA 10\r\nmain()\r\n{\r\n...\r\n}\r\n#undef AAA\r\n[\/code]\r\n在#undef AAA语句后，AAA的作用域终止，不能再使用未定义的标识符AAA。",
        8,
        105,
        1
      ],
      [
        503,
        "带参数的宏定义",
        "在C语言程序设计中，宏定义还可以用于带参数的宏。带参数的宏定义的一般形式为：\r\n[code=java]\r\n#define 宏名(参数表) 字符串\r\n[\/code]\r\n“字符串”中包含“参数表”中所指定的参数。\r\n例0.20：带参数的宏的定义\r\n[code=java]\r\n#define cube(x) (x*x*x)\r\nmain()\r\n{\r\n\t#[Keywords]double #f;\r\n\t#[Keywords]float #a=2.5;\r\n\t#f=cube(a);\r\n\t#printf(#[Fields]\"f=%f\\n\"#,f);\r\n#}\r\n[\/code]\r\n运行结果为：\r\n[code=java]\r\nf=15.625000\r\n[\/code]\r\n上面这段程序里“f=cube(a);”语句的含义是用宏定义语句中的字符串(x*x*x)代替cube(x)这个宏名，即等价于f=a*a*a；而且在替换过程中用实际参数a代替宏定义中的参数x，这有点类似于函数定义时的形式参数在函数被调用时被实际参数替换一样。但是有一点不同，函数的形式参数与实际参数必须是预先定义好的同一种类型，即如果cube(x)是一个函数，那么形式参数x有——个预先定义好的类型，在后面的程序调用语句cube(a)中a必须是与x同样的类型，否则就会出错。然而与函数相比，带参数的宏定义就不受此限制，即带参数的宏对参数的类型不敏感。所以，有时可以利用带参数的宏这一特点来写一些简单而常用的函数。\r\n从形式上，带参数的宏定义和函数似乎容易混淆，从上面的例子可以看到，二者在程序中起的作用、以及书写规范上，确实存在一定的相似之处，然而，二者并不相同，主要有以下区别：\r\n1）函数在调用时，先求出实参表达式的值，再用这个值赋给形式参数；但带参数的宏定义仅仅进行字符替换。\r\n2）函数调用是在程序运行时分配临时内存单元；而宏展开是在编译时进行，展开时不分配内存单元，不进行值传递。\r\n3）宏替换不占运行时间，只占编译时间；函数调用占运行时间。\r\n4）宏替换后使源程序增长；而函数调用不会使源程序增长。\r\n5）在使用带参数的宏的时候，对带参数的宏的展开只是用语句中宏名后的实参字符串代替#define命令中的形参，这与函数参数传递时，实参将值传递给形参不同，在编写带参数的宏时需加以注意。",
        8,
        105,
        1
      ],
      [
        504,
        "文件包含",
        "在编写C语言程序时，可以把宏定义语句按照功能不同分别存人不同的文件，当需要某一类宏定义时，就无需在程序中重新定义，只要把这些宏定义所在的文件，包含在程序的开头就可以了。\r\n文件包含就是在一个文件中，包含另外一个文件的全部内容，用#include命令来实现文件包含的功能。\r\ninclude命令的形式如下：\r\n[code=java]\r\n#include \"文件名\"或 #include <文件名>\r\n[\/code]\r\n如果文件名是用双引号括起来的，系统将先在源程序所在的目录内查找指定的包含文件，如果找不到，再按系统指定的标准方式到相关的目录去寻找。如果文件名用尖括号括起来，则系统将直接按照指定的标准方式到相关的目录中去查找。在预编译时，预编译程序将用指定文件中的内容来替换此命令行。\r\n文件包含在使用时应注意：\r\n1）一条文件包含命令只能包含一个文件。如果需要包含多个文件，就必须使用多条文件包含命令。\r\n例如，如果要包含两个文件file1.h和file2.h就不能这样写：\r\n[code=java]\r\n#include #[Fields]\"file1.h,file2.h\"#\r\n[\/code]\r\n或\r\n[code=java]\r\n#include #[Fields]\"file1.h\"# ,#[Fields]\"file2.h\"#\r\n[\/code]\r\n必须写成：\r\n[code=java]\r\n#include #[Fields]\"file1.h\"#\r\n#include #[Fields]\"file2.h\"#\r\n[\/code]\r\n其先后顺序与文件内容无关。但如果一个文件要使用另一个文件的内容，则后者文件应写在前面，即如果file1.h要使用file2.h文件中的内容，则文件包含语句必须按如下顺序写：\r\n[code=java]\r\n#include #[Fields]\"file2.h\"#\r\n#include #[Fields]\"file1.h\"#\r\n[\/code]\r\n2）文件包含的定义是可以嵌套的，文件包含的嵌套是指一个被包含的文件中还可以包含其他文件。\r\n3）被包含的文件常以.h结尾，这类文件中往往是程序所需要的一些说明、定义，如符号常量的定义、类型定义、带参数的宏定义、数组、结构、共用体和枚举的定义等等，以及外部变量的定义、函数的定义或说明。但是被包含的文件可以是任意的文件，不一定是.h文件，也可以是C语言源文件。",
        8,
        105,
        1
      ],
      [
        505,
        "条件编译",
        "条件编译是指编译时对源程序的某种控制。在一定的条件下，源程序中的某些特殊语句参加编译，而在另一种条件下，同样的这些语句不参加编译，也即C语言的语句是否有效要根据是否满足条件编译语句中设置的条件来决定，这就称为条件编译。\r\n[color=blue]常用命令及其格式\r\n1）#ifdef命令\r\n[code=java]\r\n#ifdef 标识符\r\n\t程序段1\r\n#else\r\n\t程序段2\r\n#endif\r\n[\/code]\r\n其功能是：当“标识符”已经被定义过(通常是用#define命令定义)，则对“程序段l”进行编译，否则编译“程序段2”。其中“#else”部分根据具体要求可以省略，即也可以为如下形式：\r\n[code=java]\r\n#ifdef 标识符\r\n#endif\r\n[\/code]\r\n2）#ifndef命令\r\n[code=java]\r\n#ifndef 标识符\r\n\t程序段1\r\n#else\r\n\t程序段2\r\n#endif\r\n[\/code]\r\n其功能是：若“标识符”未被定义，则编译“程序段”，否则编译“程序段2”。正好与第一种形式的作用相反。\r\n3）#if命令\r\n[code=java]\r\n#if 表达式\r\n\t程序段1\r\n#else\r\n\t程序段2\r\n#endif\r\n[\/code]\r\n该格式中“#if表达式”语句与前两种格式不同，if是关键字，“表达式”是常量表达式。其功能是：当“表达式”的值非0时．“程序段1”参加编译，否则“程序段2”参加编译。当然，根据需要，也可以没有else语句，即简化为如下格式：\r\n[code=java]\r\n#if 表达式\r\n\t程序段\r\n#endif\r\n[\/code]\r\n[color=blue]条件编译命令的应用\r\n使用条件编译命令可以对源程序的内容进行选择性的编译，比如在调试程序的时候，通常希望输出一些调试用的情息，而在调试完毕后，就不再需要输出这些信息了。\r\n在学习编译预处理命令前，有一个解决方法是在调试程序的时候增加一些输出语句，而在调试完毕，生成最终需要的可执行文件时，再将源程序改动，删去这些语句，这种作法比较麻烦，在删除的过程中容易误删程序本身需要的语句，或少删了本来作为调试用的的语句，影响最终得到的可执行文件的运行与输出效果。另外，如果这段程序再需要调试时，又得把那些凋试语句逐一加上去。掌握条件编译语句后，可以用这类命令来辅助程序调试。\r\n例如，在程序开头定义一个符号常数DEBUG(值为l或0)，在程序任何需要设置调试信息之处，加入以下信息：\r\n[code=java]\r\n#if DEBUG\r\n\t调试代码\r\n#endif\r\n[\/code]\r\n这里定义DEBUG为1时，为调试状态，即输出跟踪信息。在调试时，程序中定义DEBUG的语句为：\r\n[code=java]\r\n#define DEBUG 1\r\n[\/code]\r\n而调试结束后，将这条语句改为：\r\n[code=java]\r\n#define DEBUG 0\r\n[\/code]\r\n那么凡是加入\r\n[code=java]\r\n#if DEBUG\r\n\t调试代码\r\n#endif\r\n[\/code]\r\n的地方，调试代码便不再起作用。\r\n这样，只需修改#define DEBUG这一条语句，便达到了自动删除或增加程序中众多调试语句的效果。",
        8,
        105,
        1
      ],
      [
        506,
        "预定义宏",
        "如前所述，可以用#define定义程序需要的符号常量即自定义宏，但是下列标识符不可以出现在辑#define与#undef命令中：\r\n[code=java]\r\n__STDC__\r\n__FILE__\r\n__LINE__\r\n__DATE__\r\n__TIME__\r\n[\/code]\r\n这是由于上述标识符是C编译器预先定义好的宏，当预处理器遇到这样的宏时，同样将其转换为相应的代码。如果实现是标准的，则宏__STDC__含有十进制常量1。如果它含有任何其它数，则实现是非标准的。__FILE__表示源文件的名字。__LINE__表示源文件当前的行号。__DATE__宏指令含有形式为月\/日\/年的串，表示源程序被预编译的日期，源程序编译到目标代码的时间作为串包含在__TIME__中。串形式为时：分：秒。\r\n可以在程序中使用这些已经定义好的宏名，正如使用我们自己定义的宏一样，例如：\r\n[code=java]\r\nprintf(#[Fields]\"Today is %s\\n\"#,__DATE__);\r\n[\/code]\r\n执行上述语句就可以输出程序编译时当前系统日期。",
        8,
        105,
        1
      ],
      [
        507,
        "运算符#和##",
        "在ANSI C中，有两个仅用于宏替换的运算符：#和##。\r\n在带参数的宏替换中，如果有带#的形参，那么在宏扩展时实参应替换该#与形参，且将实参加上双引号，变为实际的字符串变量，即#形参被“实参”代替。如包含下列宏定义的源程序：\r\n[code=java]\r\n#define STRING(i) #i\r\n…\r\nprintf(STRING(example\\n));\r\n[\/code]\r\n将被替换为：\r\n[code=java]\r\nprintf(#[Fields]\"example\\n\"#);\r\n[\/code]\r\n即形参#i被实参example\\n加上双引号变为“example\\n”替换。\r\n而当另一个宏替换的运算持号##出现在宏替换中时，它起的作用是：##被删除，它连接的前后两个词法单位会合而为一，如果##附近有空格，也将会披消除，这种方式通常用来构造标识符。如：\r\n[code=java]\r\n#define LINKSTRING(str1,str2) str1##str2\r\n[\/code]\r\n则LINKSTRING(file,name)将在宏替换时变成filename。",
        8,
        105,
        1
      ],
      [
        600,
        "数组",
        "",
        9,
        106,
        1
      ],
      [
        601,
        "数组的概念",
        "在许多应用中，需要存储和处理大量数据。在这今涉及的问题中，我们能够利用少量的存储单元，处理大量的数据。这是因为我们能够处理每一个单独的数据项，然后再重复使用存储该数据项的存储单元。例如求一个班学生的平均成绩，每个成绩被存储在一个存储单元中，完成对该成绩的处理。在读入下一个成绩时，原来的成绩消失。这种办法允许处理大量成绩，而不必为每一个成绩分配单独的存储单元。然而，一旦某个成绩被处理，在后面就不能再重新使用它了。\r\n在有些应用中，为了其后的处理，需要保存数据项。例如，要计算和打印—个班学生的平均成绩以及每个成绩与平均成绩的差。在这种情况下，在计算每个差之前，必须先算出平均成绩。因此，必须能够两次考查学生成绩。首先计算平均成绩，然后计算每个成绩与这个平均成绩的差。我们不愿意两次输入学生成绩，我们希望在第一步时，将每个学生的成绩保存于单独的存储单元中，以便在第二步时重新使用它们。在输入数据项时，用不同的名字引用每—个存储单元将是烦琐的。如果有100个成绩要处理，将需要一个长的输入语句，其中每个变量名被列出一次。也需要100个赋值语句，以便计算每个成绩与平均成绩的差。\r\n数组的使用将简化大批量数据的存储和处理。具有相同类型的—批数据看成是一个整体，叫做数组。给数组取一个名字叫数组名。所以数组名代表一批数据，而以前使用的简单变量代表一个数据。数组中的每一个数据称为数组元素，它可通过顺序号（下标）来区分。\r\n例如，一个班60名学生的成绩组成一个数组a，每个学生的成绩分别表示为：\r\n[code=java]\r\na[0],a[1],a[2],…,a[i],a[59]\r\n[\/code]\r\n又如某集团5个公司全年销售收入组成数组b，每个公司每月的销售收入分别表示为：\r\n[code=java]\r\nb[0][0],b[0][1],b[0][2],…,b[0][11]\r\nb[1][0],b[1][1],b[1][2],…,b[1][11]\r\n…\r\nb[4][0],b[4][1],b[4][2],…,b[4][11]\r\n[\/code]\r\n在上例中，区分a数组的元素需要一个顺序号，故称为一维数组，而区分b数组的元素需要两个顺序号，故称为二维数组。\r\n引入数组的概念后，可以用循环语句控制下标的变化，利用单个语句，就可输入各个数据项。例如，输入90名学生的成绩，可描述为：\r\n[code=java]\r\n#[Keywords]for#(i=0;i<90;i++)\r\n\t#scanf(#[Fields]\"%d\"#,&a[i]);\r\n[\/code]\r\n一旦各个数据项存于数组中，将能随时引用任一数据项，而不必重新输入该数据项。",
        0,
        106,
        1
      ],
      [
        602,
        "一维数组",
        "[color=blue]1、一维数组的定义\r\n一维数组的定义形式为：\r\n[code=java]\r\n类型标识符数组名[常量表达式]；\r\n[\/code]\r\n其中，类型标识符指明数组元素的类型。数组名是用户自定义的标识符。方括号中的常量表达式的值表示数组元素的个数。常量表达式中可以包括整数常量和符号常量以及由它们组成的常量表达式，但必须是整型。\r\n例如数组定义：\r\n[code=java]\r\n#[Keywords]int #a[10];\r\n[\/code]\r\n表示定义了一个数组名为a的数组，一维，有10个元素，每个元素都是整型。\r\n[color=blue]2、一维数组元素的引用形式为：\r\n[code=java]\r\n数组名[下标]\r\n[\/code]\r\n显然一个数组元素的引用代表一个数据，有时称这种形式的变量为下标变量，它和简单变量等同使用。\r\nC语言规定：数组元素的下标从0开始。在引用数组元素时要注意下标的取值范围。当定义数组元素的个数为N时．下标值取0到N-1之间的整数。例如上面定义的a数组共10个元素，下标值要在0~9之间。\r\n下标可以是整型常量、整型变量或整型表达式。如：\r\n[code=java]\r\na[i]=a[9-i];\r\n[\/code]\r\n[color=blue]3、一维数组的初始化\r\n对于程序每次运行时，数组元素的初始值是固定不变的场合，可在数组定义的同时，给出数组元素的初值。这种表达形式称为数组的初始化。C语言规定只有静态数组和外部存储数组才能初始化。外部存储数组是在函数之外定义，往往在一个文件的开头定义，在整个文件范围内都能便用的数组。数组的初始化可用以下几种方法实现：\r\n1）顺序列出数组全部元素的初值。\r\n数组初始化时，将数组元素的初值依次写在一对花括号内。例如：\r\n[code=java]\r\n#[Keywords]int #x[10]={0,-1,2,3,-4,5,6,-7,8,9};\r\n[\/code]\r\n2）只给数组的前面一部分元素设定初值。\r\n例如：\r\n[code=java]\r\n#[Keywords]int #y[10]={ 0,-1,2,3,-4};\r\n[\/code]\r\n定义数组y有10个元素，其中前5个元素设定了初值，分别为0，-l，2，3，-4。而后六个元素未设定初值。C系统约定，当一个数组的部分元素被设定初值后，对于元素为数值型的数组，那些末明确设定初值的元素自动被设定0值。所以数组y的后六个元素的初值为0。但是，当定义数组时，如未对它指定初值，对于内部的局部数组，则它的元素的值是不确定的。\r\n3）当对全部数组元素赋初值时，可以不指定数组元素的个数。\r\n例如：\r\n[code=java]\r\n#[Keywords]int #z[]={0,1,2};\r\n[\/code]\r\n系统根据花括号中数据的个数确定数组的元素个数。所以数组z有10个元素。但若提供的初值个数小于数组希望的元素个数时，则方括号中的数组元素个数不能省略。反之，如提供的初值个数超过了数组元素个数，就会引起程序错误。\r\n例0.21：用数组的形式求10个学生的平均成绩。\r\n[code=java]\r\n#include <stdio.h>\r\nmain()\r\n{\r\n\t#[Keywords]int #i,sum,score[10]; 仅供参考\r\n\t#[Keywords]float #average;\r\n\t#sum=0;\r\n\t#[Keywords]for#(i=0;i<10;i++)\r\n\t#{\r\n\t\t#scanf(#[Fields]\"%d\"#,&score[i]);\r\n\t\t#sum+=score[i];\r\n\t#}\r\n\t#average=(#[Keywords]float#)sum\/10;\r\n\t#printf(#[Fields]\"Average=%f\\n\"#,average);\r\n#}\r\n[\/code]\r\n在上面的程序中，数组score表示10个学生每个人的成绩。变量sum表示10个学生成绩的总和，而i是循环变量，用作数组的下标，浮点型变量average表示10人的成绩平均值。在for循环中，先输入每个学生的成绩，即给数组元素赋值。然后进行累加，求出总成绩。在循环结束后，得到总成绩，再求平均值。",
        0,
        106,
        1
      ],
      [
        603,
        "二维数组",
        "[color=blue]1、二维数组的定义\r\n二维数组的定义形式为：\r\n[code=java]\r\n类型标识符数组名[常量表达式][常量表达式]；\r\n[\/code]\r\n其中各个部分的含义与一维数组中的各部分含义相同。\r\n例如：\r\n[code=java]\r\n#[Keywords]float #a[2][3];\r\n[\/code]\r\n定义二维数组a，它有2行3列。\r\n由二维数组可以推广到多维数组。通常多维数组的定义形式有连续多个“[常量表达式]”。例如：\r\n[code=java]\r\n#[Keywords]float #b[2][3][4];\r\n[\/code]\r\n定义了三维数组b。\r\nC语言把二维数组看作是一种特殊的一维数组，即它的成分又是一个数组。对于上述定义的数组a，把它看作是具有2个元素的一维数组：a[0]和a[l]，每个元素又是一个包含3个元素的一维数组。通常，一个n维数组可看作是一个一维数组，而它的元素是一个(n—1)维的数组。C语言对多维数组的这种观点和处理方法，使数组的初始化、引用数组的元素以及用指针表示数组带来很大的方便。\r\n[color=blue]2、二维数组元素的引用\r\n二维数组元素的引用形式为：\r\n[code=java]\r\n数组名[下标][下标]\r\n[\/code]\r\n通常n维数组元素的引用形式为数组名之后紧接连续n个“[下标]”。如同一维数组—样、下标可以是整型常量、变量或表达式。各维下标的下界都是0。\r\n[color=blue]3、二维数组的初始化\r\n二维数组的初始化方法有以下几种：\r\n1）按行给二维数组赋初值。\r\n例如：\r\n[code=java]\r\n#[Keywords]int #x[2][3]={{1,2,3#},{4,5,6#}#};\r\n[\/code]\r\n第一个花括号内的数据给第一行的元素赋初值，第二个花括号内的数据给第二行的元素赋初值，依次类推。这种赋初值方法比较直观。\r\n2）按元素的排列顺序赋初值。\r\n例如：\r\n[code=java]\r\n#[Keywords]int #x[2][3]={1,2,3,4,5,6#};\r\n[\/code]\r\n这种赋初值方法结构性差，容易遗漏。\r\n3）对部分元素赋初值。\r\n例如：\r\n[code=java]\r\n#[Keywords]int #x[2][3]={{1,2#},{3,4#}#};\r\n[\/code]\r\n其作用是使x[0][0]=1，x[0][1]=2，x[1][0]=3，x[1][1]=4，其余元素均为0。\r\n4）如果对数组的全部元素都赋初值，定义数组时，第一维的元素个数可以不指定。\r\n例如：\r\n[code=java]\r\n#[Keywords]int #x[][3]={1,2,3,,4,5,6#};\r\n[\/code]\r\n系统会根据给出的初始数据个数和其他维的元素个数确定第一维的元索个数。所以数组x有2行。\r\n也可以用分行赋初值方法，只对部分元素赋初值而省略第一维的元素个数，例如：\r\n[code=java]\r\n#[Keywords]int #x[][3]={{1,2#},{#}#};\r\n[\/code]\r\n也能确定数组x共有2行。\r\n例0.22：说明一个二维数组a，再对每一元素赋值，然后计算每一行各元素之和。\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]float #a[2][3],b[2]; #[Tags]\/*内部数组不能初始化*\/#\r\n\t#[Keywords]int #i;\r\n\t#[Tags]\/* 给数组赋值*\/#\r\n\t#a[0][0]=15.2; a[0][1]=10.2;a[0][2]=10.6;\r\n\t#a[1][0]=6.7; a[1][1]=2.3; a[1][2]=10.3;\r\n\t#for(i=0;i<2;i++)\r\n\t#{\r\n\t\t#b[i]=a[i][0]+a[i][1]+a[i][2];\r\n\t\t#printf(#[Fields]\"%f %f %f %f\\n\"#,a[i][0],a[i][1],a[i][2],b[i]);\r\n\t#}\r\n#}\r\n[\/code]\r\n程序开始定义了一个二维数组a和一个一维数组b，数组b用来保存数组a每一行元素之和。然后给数组a各元素赋值，并计算各行元素之和，保存到数组b中，然后输出a的各行元素与每行元素的和。\r\n程序运行结果为：\r\n[code=java]\r\n15.200000 10.200000 10.600000 39.000000\r\n6.700000 2.300000 10.300000 22.299999\r\n[\/code]",
        0,
        106,
        1
      ],
      [
        604,
        "字符数组",
        "字符数组是指每个元素都是字符型数据的数组，它的定义形式和元素的引用方法与一般数组相同。例如：\r\n[code=java]\r\n#[Keywords]char #a[20];\r\n[\/code]\r\n表示数组a有20个元素，每个元素都是字符型，能存放一个字符。\r\n字符数组的初始化也与其他数组的初始化一样，对部分未明确指定初值的那些元素，系统自动设定0值字符即‘\\0’，它是字符串结束标志符。\r\n在C语言中，常用一维字符数组来存放一个字符串常量，习惯上把一维字符数组名称作字符串变量。由于字符数组在使用上的一些待殊性，故在此专门讨论。",
        0,
        106,
        1
      ],
      [
        605,
        "字符数组与字符串",
        "前面已经讨论过字符串，利用C语言关于字符串的规定，可以用字符串常量给字符数组初始化。例如：\r\n[code=java]\r\n#[Keywords]char #a[]={#[Fields]\"C programe\"##};\r\n[\/code]\r\n也可以省略花括号，简单的写为：\r\n[code=java]\r\n#[Keywords]char #a[]=#[Fields]\"C programe\"#;\r\n[\/code]\r\n注意，字符数组a[]的元素个数是11，不是10。\r\n需要指出，字符数组本身并不要求最后要有标志‘\\0’。但当字符组需要作为字符串时，就必须有标志符‘\\0’。例如：\r\n[code=java]\r\n#[Keywords]char #str1[]=#[Fields]\"teacher\"#;\r\n#[Keywords]char #str2[]={#[Fields]'t'#,#[Fields]'e'#,#[Fields]'a'#,#[Fields]'c'#,#[Fields]'h'#,#[Fields]'e'#,#[Fields]'r'##};\r\n[\/code]\r\n则\r\n[code=java]\r\nprintf(#[Fields]\"%s\"#,str1);\r\n[\/code]\r\n是正确的，而\r\n[code=java]\r\nprintf(#[Fields]\"%s\"#,str2);\r\n[\/code]\r\n是错误的。后音将在输出teacher之后继续输出，直至遇到8位全0代码（即‘＼0’）为止。实际上字符数组str1[]有8个元素；str2[]只有7个元素。\r\n指定元素个数的字符数组用字符串常量给它初始化时，其元素个数不能少于字符串常量的字符数，但可等于。例如：\r\n[code=java]\r\n#[Keywords]char #str[]=#[Fields]\"abcde\"#;\r\n则str[0]=#[Fields]'a'#,str[1]=#[Fields]'b'#,str[2]=#[Fields]'c'#,str[3]=#[Fields]'d'#,str[4]=#[Fields]'e'#。\r\n[\/code]",
        0,
        106,
        1
      ],
      [
        606,
        "字符数组的输入输出",
        "字符数组的输入输出可以有两种方式：\r\n1）逐个字符输入输出。用格式说明％c，结合循环控制结构输入输出一个字符。\r\n2）将整个字符串一次输入输出。用格式说明％s，输入输出整个字符串。\r\n例0.23 输出字符串“string”。\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]char #s[]=#[Fields]\"string\"#;\r\n\t#[Keywords]int #i;\r\n\t#[Keywords]for#(i=0;s[i];i++)\r\n\t#printf(#[Fields]\"%c\"#,s[i]);\r\n\t#printf(#[Fields]\"\\n\"#);\r\n\t#printf(#[Fields]\"%s\\n\"#,s);\r\n#}\r\n[\/code]\r\n程序开始定义了一个字符数组s，然后分别用逐个字符输出和整个字符串一次输出的方法输出字符串。输出结果都为：\r\n[code=java]\r\nstring\r\n[\/code]\r\n需要注意的是：\r\n1）输出的字符序列不包括字符串结束标志符“\\0”。\r\n2）用％s格式输出字符串时，对应的输出项是字符串或字符数组名，而不是数组元素名。对于上例，写成\r\n[code=java]\r\nprintf(#[Fields]\"%s\\n\"#,s[0]);\r\n[\/code]\r\n是错误的。因为数组元素s[0]是字符，不是字符串。\r\n3）字符串与存储字符串的字符数组的区别。字符串的有效字符是指从所指位置的一个字符开始至字符串结束标志符之前的那些字符。格式符“％s”只输出这些字符，而不会再继续输出字符串结束标志符之后的字符。例如：\r\n[code=java]\r\n#[Keywords]char #str=#[Fields]\"programming\"#;\r\nstr[3]= #[Fields]'\\0'#;\r\nprintf(#[Fields]\"%s\\n\"#str);\r\n[\/code]\r\n将只输出：pro。\r\n4）为字符数组输入字符串时，在scanf函数中输入项是字符数组名．不要加地址运算符‘&’。例如：\r\n[code=java]\r\nscanf(#[Fields]\"%s\"#str);\r\n[\/code]\r\n是正确的，而\r\n[code=java]\r\nscanf(#[Fields]\"%s\"#&str);\r\n[\/code]\r\n是不正确的。\r\n5）用“％s”格式为字符数组输入字符串时，系统会自动在输入的有效字符列之后附加字符串结束标志符。如果用一个scanf函数输入多个字符串．则输入字符串以空格分隔。例如\r\n[code=java]\r\n#[Keywords]char #str1[6],str2[6],str3[6];\r\nscanf(#[Fields]\"%s %s %s\"#,str1,str2,str3);\r\n[\/code]\r\n输入数据：How are you?\r\n则输入后，数组str1，str2，str3的内容分别是：\r\n[code=java]\r\nstr1[0]=#[Fields]'H'#,str1[1]=#[Fields]'o'#,str1[2]=#[Fields]'w'#,str1[3]=#[Fields]'\\0'#;\r\nstr2[0]=#[Fields]'a'#,str2[1]=#[Fields]'r'#,str2[2]=#[Fields]'e'#,str2[3]=#[Fields]'\\0'#;\r\nstr3[0]=#[Fields]'y'#,str3[1]=#[Fields]'o'#,str3[2]=#[Fields]'u'#,str2[3]=#[Fields]'?'#,str2[4]=#[Fields]'\\0'#;\r\n[\/code]",
        0,
        106,
        1
      ],
      [
        607,
        "字符串处理函数",
        "为了便于处理字符串，在C系统提供的函数库中包含有丰富的字符串处理函数，这里介绍其中几个比较常用的字符串处理函数。\r\n[color=blue]1、字符串输出函数puts\r\n函数puts将字符串的内容输出到终端，并将字符串中的‘＼0’转换成换行符‘＼n’。即输出字符串内容，并换行。例如：\r\n[code=java]\r\n#[Keywords]char #str[]=#[Fields]\"1234\"#;\r\nputs(str);\r\n[\/code]\r\n将输出：\r\n[code=java]\r\n1234\r\n[\/code]\r\n[color=blue]2、字符串输入函数gets(str)\r\n其中，参数str是字符串，它的功能是从终端输入—行字符到str中。其中输入时的回车符被转换成‘\\0’。str不能是字符串常量。该函数调用将返回一个函数值，其值是str的起始地址。\r\n[color=blue]3、求字符串长度函数strlen(str)\r\n其中，参数str是字符串，它的功能是返回str中的有效字符(不包括‘\\0’)个数。例如：\r\n[code=java]\r\n#[Keywords]char #c[20]=#[Fields]\"12345\"#;\r\nprintf(#[Fields]\"%d\\n\"#,strlen(c));\r\n[\/code]\r\n将输出5。\r\n[color=blue]4、字符串连接函数stract(str1,str2)\r\n其中，参数str1、str2是字符串，它的功能是将str2连接在str1的后面。str1不能是字符串常量。函数调用返回一个函数值，函数值为strl的开始地址。正确使用该函数，要求strl必须足够大，以便能容纳str2的内容。注意，连接前，strl和str2都各有自‘\\0’。\r\n连接后，strl中的‘\\0’在连接时被覆盖掉，而在新的字符串有效字符之后保留一个‘＼0’。例如：\r\n[code=java]\r\n#[Keywords]char #str1[100]=#[Fields]\"Beijing\"#,str2[]=#[Fields]\"China\"#;\r\nstrcat(str1,str2);\r\nputs(str1);\r\n[\/code]\r\n将输出BeijingChina。\r\n[color=blue]5、字符串拷贝函数strcpy(str1, str2)和strncpy(str1, str2)\r\n其中，参数str1、str2是字符串。strcpy函数的功能是将字符串str2拷贝到字符串str1，限定str1不能是字符串常量，且str1定义得足够大，以便能容纳被拷贝的str2的内容。例如：\r\n[code=java]\r\nstrcpy(str1,#[Fields]\"computer\"#);\r\n[\/code]\r\nstrcpy函数完成整个字符串的拷贝。在某些应用中，需要将一个字符串的前面一部分拷贝，其余部分不拷贝。调用函数strncpy可实现这个要求。strncpy(str1,str2,n)的作用是将str2中的前n个字符拷贝到strl(附加‘＼0’)。其中n是整型表达式，指明欲拷贝的字符个数。如果str2中的字符个数不多于n，则该函数调用等价于strcpy(strl，str2)。\r\n[color=blue]6、字符串比较函数strcmp(str1, str2)\r\n其中，参数str1、str2是字符串，它的功能是比较两个字符串大小。对两个字符串自左至右逐个字符相比较(按字符的ASCII代码值的大小)，直至出现不同的字符或遇到‘\\0’为止。如全部字符都相同，则认为相等，函数返回0值；若出现不相同的字符，则以这第一个不相同的字符比较结果为准。若strl的那个不相同字符小于str2的相应字符，函数返回一个负整数；反之，返回一个正整数。\r\n注意，对字符串不允许施加相等“==”和不相等“!=”运算，必须用字符串比较函数对字符串作比较。例如：\r\n[code=java]\r\nif(str1==str2) printf(#[Fields]\"Yes\\n\"#);\r\n[\/code]\r\n是非法的，而只能用\r\n[code=java]\r\nif(strcmp(str1,str2)==0) printf(#[Fields]\"Yes\\n\"#);\r\n[\/code]\r\n[color=blue]7、字符串字母转换函数\r\n函数strlwr(str)将字符串str中的大写字母转换成小写字母，而strupr(str)则将字符串str中的小写字母转换成大写字母，其中str不能是字符串常量。\r\n例0.24：任意输入一个英文书名，将书名中的小写字母全部转换成大写字母，其余字符不变，输出转换后的书名。程序代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\nmain()\r\n{\r\n\t#[Keywords]char #str[100];\r\n\t#[Keywords]int #i;\r\n\t#printf(#[Fields]\"Input the book name: \"#);\r\n\t#gets(str);\r\n\t#[Keywords]for#(i=0; i<=strlen(str);i++)\r\n\t#if(str[i]>=#[Fields]'a'#&&str[i]<=#[Fields]'z'#)\r\n\t#str[i]-=32;\r\n\t#puts(str);\r\n#}\r\n[\/code]\r\n在上面的程序中，首先定义了一个字符数组str，用来存储英文书名，然后用gets函数得到输入的英文书名。在for循环中，用strlen函数得到输入的英文书名字符串的长度，然后把英文书名的小写字母转换成大写字母。最后用puts函数输出转换后的英文书名。程序运行如下：\r\n[code=java]\r\nInput the book name: C programming\r\nC PROGRAMMING\r\n[\/code]",
        0,
        106,
        1
      ],
      [
        608,
        "二维字符数组",
        "二维字符数组用于处理多个字符串。定义方法类似二维整型数组和二维实型数组，例如：\r\n[code=java]\r\nchar str[3][50];\r\n[\/code]\r\n定义了二维字符数组str，str中各下标变量的排列顺序为：\r\n[code=java]\r\nstr[0][0],str[0][1],…,str[0][49]\r\nstr[1][0],str[1][1],…,str[1][49]\r\nstr[2][0],str[2][1],…,str[2][49]\r\n[\/code]\r\n在C语言中，可将二维数组看作是由若干个一维数组组成的数组。如上面的数组str可看作由三个一维数组组成的，这三个一维数组的数组名分别为str[0]、str[1]和str[2]。前面已说明，一维字符数组可用于处理一个字符串，所以数组str可用于处理三个字符串。将三个字符串输入到数组str中的语句为：\r\n[code=java]\r\nfor(i=0;i<3;i++)\r\n\t#scanf(#[Fields]\"%s\"#,s[i]);\r\n[\/code]\r\n或\r\n[code=java]\r\nfor(i=0;i<3;i++)\r\n\t#gets(s[i]);\r\n[\/code]\r\n前者输入的串中不能包含空格，后者可包含空格。",
        0,
        106,
        1
      ]
    ]
  },
  {
    "table" : "c_library",
    "columns" : [
      "id",
      "title",
      "content",
      "importance",
      "showFlag",
      "version"
    ],
    "data" : [
      [
        0,
        "C语言标准库",
        "",
        9,
        126,
        1
      ],
      [
        1,
        "assert.h：诊断",
        "<assert.h>中只定义了一个带参的宏assert，其定义形式如下：\r\n[code=java]\r\nvoid assert (int 表达式)\r\n[\/code]\r\nassert宏用于为程序增加诊断功能，它可以测试一个条件并可能使程序终止。\r\n在执行语句：\r\n[code=java]\r\nassert(表达式);\r\n[\/code]\r\n时，如果表达式为0，则在终端显示一条信息：\r\n[code=java]\r\nAssertion failed: 0, file 源文件名, line 行号\r\nAbnormal program termination\r\n[\/code]\r\n然后调用abort终止程序的执行。\r\n在<assert.h>中，带参宏assert是被定义为条件编译的，如果在源文件中定义了宏NDEBUG，则即使包含了头文件<assert.h>，assert宏也将被忽略。\r\n",
        8,
        126,
        1
      ],
      [
        2,
        "ctype.h：字符类别测试",
        "在头文件<ctype.h>中定义了一些测试字符的函数。在这些函数中，每个函数的参数都是整型int，而每个参数的值或者为EOF，或者为char类型的字符。<ctype.h>中定义的标准函数列表如下：\r\n<ctype.h>中定义的函数\r\n[code=java]\r\n函数定义, 函数功能简介\r\nint isalnum(int c), 检查字符是否是字母或数字\r\nint isalpha(int c), 检查字符是否是字母\r\nint isascii(int c), 检查字符是否是ASCII码\r\nint iscntrl(int c), 检查字符是否是控制字符\r\nint isdigit(int c), 检查字符是否是数字字符\r\nint isgraph(int c), 检查字符是否是可打印字符\r\nint islower(int c), 检查字符是否是小写字母\r\nint isprint(int c), 检查字符是否是可打印字符\r\nint ispunct(int c), 检查字符是否是标点字符\r\nint isspace(int c), 检查字符是否是空格符\r\nint isupper(int c), 检查字符是否是大写字母\r\nint isxdigit(int c), 检查字符是否是十六进制数字字符\r\nint toupper(int c), 将小写字母转换为大写字母\r\nint tolower(int c), 将大写字母转换为小写字母\r\n[\/code]",
        8,
        126,
        1
      ],
      [
        3,
        "errno.h：错误处理",
        "<errno.h>中定义了两个常量，一个变量。\r\n[color=blue]1、 EDOM\r\n它表示数学领域错误的错误代码。\r\n[color=blue]2、 ERANGE\r\n它表示结果超出范围的错误代码。\r\n[color=blue]3、 errno\r\n这是一个变量，该值被设置成用来指出系统调用的错误类型。",
        8,
        126,
        1
      ],
      [
        4,
        "limits.h：整型常量",
        "在头文件<limits.h>中定义了一些表示整型大小的常量。下面给出这些常量的字符表示以及含义，见下表。\r\n<limits.h>中定义的字符常量字符常量, 取值, 含义\r\n[code=java]\r\nCHAR_BIT, 8, char类型的位数\r\nCHAR_MAX, 255或127, char类型最大值\r\nCHAR_MIN, 0或-127, char类型最小值\r\nINT_MIN, -32767, int类型最小值\r\nINT_MAX\t, 32767, int类型最大值\r\nLONG_MAX, 2147483647, long类型最大值\r\nLONG_MIN, -2147483647, long类型最小值\r\nSCHAR_MAX, 127, signed char 类型最大值\r\nSCHAR_MIN, -127, signed char 类型最小值\r\nSHRT_MAX, 32767, short类型的最大值\r\nSHRT_MIN, -32767, short类型的最小值\r\nUCHAR_MAX, 255, unsigned char 类型最大值\r\nUINT_MAX, 65535, unsigned int 类型最大值\r\nULONG_MAX, 4294967295, unsigned long 类型最大值\r\nUSHRT_MAX, 65535, unsigned short类型的最大值\r\n[\/code]",
        8,
        126,
        1
      ],
      [
        5,
        "locale.h：地域环境",
        "在<locale.h>中，定义了7个常量，一个结构，2个函数。\r\n[color=blue]1、常量的定义\r\nLC_ALL：传递给setlocale的第一个参数，指定要更改该locale的哪个方面。\r\nLC_COLLATE：strcoll和strxfrm的行为。\r\nLC_CTYPE：字符处理函数。\r\nLC_MONETARY：localeconv返回的货币信息。\r\nLC_NUMERIC：localeconv返回的小数点和货币信息。\r\nLC_TIME：strftime的行为。\r\n以上扩展成具有唯一取值的整型常数表达式，可作为setlocale的第一个参数。\r\nNULL：由实现环境定义的空指针。\r\n[color=blue]2、struct lconv结构\r\n该结构用于存储和表示当前locale的设置。其结构定义如下：\r\n[code=java]\r\nstruct lconv \r\n{\r\n    #char*decimal_po#[Keywords]int #;\r\n    #char*thousands_sep ;\r\n    #char*grouping ;\r\n    #char*int_curr_symbol ;\r\n    #char*currency_symbol ;\r\n    #char*mon_decimal_po#[Keywords]int #;\r\n    #char*mon_thousands_sep ;\r\n    #char*mon_grouping ;\r\n    #char*positive_sign ;\r\n    #char*negative_sign ;\r\n    #[Keywords]char #int_frac_digits ;\r\n    #[Keywords]char #frac_digits ;\r\n    #[Keywords]char #p_cs_precedes ;\r\n    #[Keywords]char #p_sep_by_space ;\r\n    #[Keywords]char #n_cs_precedes ;\r\n    #[Keywords]char #n_sep_by_space ;\r\n    #[Keywords]char #p_sign_posn ;\r\n    #[Keywords]char #n_sign_posn ;\r\n#};\r\n[\/code]\r\n[color=blue]3、函数\r\n[code=java]\r\nstruct Iconv *localeconv(void);\r\n[\/code]\r\n函数localeconv将一个struct Iconv类型的对象的数据成员设置成为按照当前地域环境的有关规则进行数量格式化后的相应值。\r\n[code=java]\r\n#[Keywords]char #*setlocale(#[Keywords]int #category,#[Keywords]char #* locale);\r\n[\/code]\r\n函数setlocale用于更改和查询程序的整个当前地域环境或部分设置。地域环境变量由参数category(上面定义的6个常量)和locale指定。",
        8,
        126,
        1
      ],
      [
        6,
        "math.h：数学函数",
        "在<math.h>中定义了一些数学函数和宏，用来实现不同种类的数学运算。下面给出<math.h>中标准数学函数的函数定义及功能简介，见下表。\r\n<math.h>中定义的函数\r\n[code=java]\r\n函数定义, 函数功能简介\r\n#[Keywords]double #exp(#[Keywords]double #x);, 指数运算函数, 求e的x次幂函数\r\n#[Keywords]double #log(#[Keywords]double #x), 对数函数ln(x)\r\n#[Keywords]double #log10(#[Keywords]double #x); , 对数函数log\r\n#[Keywords]double #pow(#[Keywords]double #x, #[Keywords]double #y);, 指数函数(x的y次方)\r\n#[Keywords]double #sqrt(#[Keywords]double #x); , 计算平方根函数\r\n#[Keywords]double #ceil(#[Keywords]double #x); , 向上舍入函数\r\n#[Keywords]double #floor(#[Keywords]double #x);, 向下舍入函数\r\n#[Keywords]double #fabs(#[Keywords]double #x);, 求浮点数的绝对值\r\n#[Keywords]double #ldexp(#[Keywords]double #x, #[Keywords]int #n); , 装载浮点数函数\r\n#[Keywords]double #frexp(#[Keywords]double #x, int* exp); , 分解浮点数函数\r\n#[Keywords]double #modf(#[Keywords]double #x, double* ip); , 分解双精度数函数\r\n#[Keywords]double #fmod(#[Keywords]double #x, #[Keywords]double #y);, 求模函数\r\n#[Keywords]double #sin(#[Keywords]double #x); , 计算x的正弦值函数\r\n#[Keywords]double #cos(#[Keywords]double #x);, 计算x的余弦值函数\r\n#[Keywords]double #tan(#[Keywords]double #x);, 计算x的正切值函数\r\n#[Keywords]double #asin(#[Keywords]double #x);, 计算x的反正弦函数\r\n#[Keywords]double #acos(#[Keywords]double #x); , 计算x的反余弦函数\r\n#[Keywords]double #atan(#[Keywords]double #x); , 反正切函数1\r\n#[Keywords]double #atan2(#[Keywords]double #y, #[Keywords]double #x); , 反正切函数2\r\n#[Keywords]double #sinh(#[Keywords]double #x); , 计算x的双曲正弦值\r\n#[Keywords]double #cosh(#[Keywords]double #x); , 计算x的双曲余弦值\r\n#[Keywords]double #tanh(#[Keywords]double #x); , 计算x的双曲正切值\r\n[\/code]\r\n在标准库中，还有一些与数学计算有关的函数定义在其他头文件中。",
        8,
        126,
        1
      ],
      [
        7,
        "setjmp.h：非局部跳转",
        "在头文件<setjmp.h>中定义了一种特别的函数调用和函数返回顺序的方式。这种方式不同于以往的函数调用和返回顺序，它允许程序流程立即从一个深层嵌套的函数中返回。\r\n<setjmp.h>中定义了两个宏：\r\n[code=java]\r\n#[Keywords]int #setjmp(jmp_buf env);  \/*设置调转点*\/\r\n[\/code]\r\n和\r\n[code=java]\r\nlongjmp(jmp_buf jmpb, #[Keywords]int #retval);   \/*跳转*\/\r\n[\/code]\r\n宏setjmp的功能是将当前程序的状态保存在结构env，为调用宏longjmp设置一个跳转点。setjmp将当前信息保存在env中供longjmp使用。其中env是jmp_buf结构类型的，该结构定义为：\r\n[code=java]\r\ntypedef struct {\r\n\tunsigned\tj_sp;\r\n\tunsigned\tj_ss;\r\n\tunsigned\tj_flag;\r\n\tunsigned\tj_cs;\r\n\tunsigned\tj_ip;\r\n\tunsigned\tj_bp;\r\n\tunsigned\tj_di;\r\n\tunsigned\tj_es;\r\n\tunsigned\tj_si;\r\n\tunsigned\tj_ds;\r\n}\tjmp_buf[1];\r\n[\/code]\r\n直接调用setjmp时，返回值为0，这一般用于初始化（设置跳转点时）。以后再调用longjmp宏时用env变量进行跳转。程序会自动跳转到setjmp宏的返回语句处，此时setjmp的返回值为非0，由longjmp的第二个参数指定。\r\n下面通过例子来理解<setjmp.h>中定义的这两个宏。\r\n例程9-1 非局部跳转演示。\r\n[code=java]\r\n#include <setjmp.h> \r\njmp_buf env;   \/*定义jmp_buf类型变量*\/\r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]int #value; \r\n   #value = setjmp(env);  \/*调用setjmp，为longjmp设置跳转点*\/\r\n   #[Keywords]if #(value != 0) \r\n   #{\r\n      #printf(#[Fields]\"Longjmp with value %d\\n\"#, value);\r\n      #exit(value);    \/*退出程序*\/\r\n   #} \r\n   #printf(#[Fields]\"Jump  ... \\n\"#);\r\n   #longjmp(env,1);       \/*跳转到setjmp语句处*\/\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n本例程先应用setjmp宏为longjmp设置跳转点，当第一次调用setjmp时返回值为0，并将程序的当前状态（寄存器的相关状态）保存在结构变量env中。当程序执行到longjmp时，系统会根据setjmp保存下来的状态env跳转到setjmp语句处，并根据longjmp的第二个参数设置此时setjmp的返回值。\r\n本例程的运行结果为：\r\n[code=java]\r\nJump  ...\r\nLongjmp with value 1\r\n[\/code]\r\n一般地，宏setjmp和longjmp是成对使用的，这样程序流程可以从一个深层嵌套的函数中返回。",
        8,
        126,
        1
      ],
      [
        9,
        "stdarg.h：可变参数表",
        "可变参数表<stdarg.h>中的宏是用来定义参数可变的函数的。在C语言中，有些库函数或者用户自定义的函数的参数是可变的，常用省略号“……”（例如库函数中的printf），定义这样的函数就要使用到<stdarg.h>中的宏。\r\n[color=blue]1、va_list\r\n用于保存宏va_start，va_arg以及va_end所需信息的数据类型。\r\n[color=blue]2、<stdarg.h>中还定义了三个宏\r\n[code=java]\r\nvoid va_start(va_list ap, parmN);\r\ntype va_arg(va_list ap,type);\r\nvoid va_end (va_list ap);\r\n[\/code]\r\nva_start的作用是初始化ap，因此va_start要在所有其它的va_开头的宏前面最先使用(除了用va_list定义变量外)，后面的va_copy, va_arg, va_end都要使用到ap。在一对va_start和va_end之间不能再次使用va_start宏。其中，parmN为\"...\"之前的最后一个参数。例如,printf函数定义为：printf(const char *format, ...); 那么在printf函数中的va_start使用之后, parmN 的值就等于*format。\r\nva_arg的作用就是返回参数列表ap中的下一个具有type类型的参数,每次调用va_arg都会修改ap的值,这样才能连续不断地获取下一个type类型的参数。\r\nva_end与va_start构成了一个scope，va_end标志着结束，va_end之后ap就无效了。",
        8,
        126,
        1
      ],
      [
        10,
        "stddef.h：公共定义",
        "在头文件<seddef.h>中，指定了标准库中的公共定义。其中主要包括以下内容：\r\n[color=blue]1、NULL\r\n空指针类型常量。\r\n[color=blue]2、offset(type,member-designator)\r\n它是扩展iz-t类型的一个整型常数表达式。它的值为从type定义的结构类型的开头到结构成员member-designator的偏移字节数。\r\n[color=blue]3、ptrdiff_t\r\n表示两指针之差的带符号整数类型。\r\n[color=blue]4、size_t\r\n表示由sizeof运算符计算出的结果类型，它是一个无符号整数类型。\r\n[color=blue]5、wchar_t\r\n它是一种整数类型，取值范围为在被支持的地域环境中最大扩展字符集的所有字符的各种代码，空字符代码值为0。",
        8,
        126,
        1
      ],
      [
        11,
        "stdio.h：输入输出",
        "在头文件<stdio.h>中定义了输入输出函数，类型和宏。这些函数、类型和宏几乎占到标准库的三分之一。\r\n下面给出头文件<stdio.h>中声明的函数以及功能简介，见下表。\r\n<stdio.h>中声明的函数\r\n[code=java]\r\n函数定义, 函数功能简介\r\nFILE *fopen(#[Keywords]char #*filename, #[Keywords]char #*type), 打开一个文件\r\nFILE *fropen(#[Keywords]char #*filename, #[Keywords]char #*type,FILE *fp), 打开一个文件，并将该文件关联到fp指定的流\r\n#[Keywords]int #fflush(FILE *stream), 清除一个流\r\n#[Keywords]int #fclose(FILE *stream), 关闭一个文件\r\n#[Keywords]int #remove(#[Keywords]char #*filename), 删除一个文件\r\n#[Keywords]int #rename(#[Keywords]char #*oldname, #[Keywords]char #*newname), 重命名文件\r\nFILE *tmpfile(void), 以二进制方式打开暂存文件\r\n#[Keywords]char #*tmpnam(#[Keywords]char #*sptr), 创建一个唯一的文件名\r\n#[Keywords]int #setvbuf(FILE *stream, #[Keywords]char #*buf, #[Keywords]int #type, unsigned size), 把缓冲区与流相关\r\n#[Keywords]int #printf(#[Keywords]char #*format...), 产生格式化输出的函数\r\n#[Keywords]int #fprintf(FILE *stream, #[Keywords]char #*format[, argument,...]), 传送格式化输出到一个流中\r\n#[Keywords]int #scanf(#[Keywords]char #*format[,argument,...]), 执行格式化输入\r\n#[Keywords]int #fscanf(FILE *stream, #[Keywords]char #*format[,argument...]), 从一个流中执行格式化输入\r\n#[Keywords]int #fgetc(FILE *stream), 从流中读取字符\r\n#[Keywords]char #*fgets(#[Keywords]char #*string, #[Keywords]int #n, FILE *stream), 从流中读取一字符串\r\n#[Keywords]int #fputc(#[Keywords]int #ch, FILE *stream), 送一个字符到一个流中\r\n#[Keywords]int #fputs(#[Keywords]char #*string, FILE *stream), 送一个字符到一个流中\r\n#[Keywords]int #getc(FILE *stream), 从流中取字符\r\n#[Keywords]int #getchar(void), 从stdin流中读字符\r\n#[Keywords]char #*gets(#[Keywords]char #*string), 从流中取一字符串\r\n#[Keywords]int #putchar(#[Keywords]int #ch), 在stdout上输出字符\r\n#[Keywords]int #puts(#[Keywords]char #*string), 送一字符串到流中\r\n#[Keywords]int #ungetc(#[Keywords]char #c, FILE *stream), 把一个字符退回到输入流中\r\n#[Keywords]int #fread(#[Keywords]void #*ptr, #[Keywords]int #size, #[Keywords]int #nitems, FILE *stream), 从一个流中读数据\r\n#[Keywords]int #fwrite(#[Keywords]void #*ptr, #[Keywords]int #size, #[Keywords]int #nitems, FILE *stream), 写内容到流中\r\n#[Keywords]int #fseek(FILE *stream, #[Keywords]long #offset, #[Keywords]int #fromwhere), 重定位流上的文件指针\r\n#[Keywords]long #ftell(FILE *stream), 返回当前文件指针\r\n#[Keywords]int #rewind(FILE *stream), 将文件指针重新指向一个流的开头\r\n#[Keywords]int #fgetpos(FILE *stream), 取得当前文件的句柄\r\n#[Keywords]int #fsetpos(FILE *stream, const fpos_t *pos), 定位流上的文件指针\r\n#[Keywords]void #clearerr(FILE *stream), 复位错误标志\r\n#[Keywords]int #feof(FILE *stream), 检测流上的文件结束符\r\n#[Keywords]int #ferror(FILE *stream), 检测流上的错误\r\n#[Keywords]void #perror(#[Keywords]char #*string), 系统错误信息\r\n[\/code]\r\n在头文件<stdio.h>中还定义了一些类型和宏。",
        8,
        126,
        1
      ],
      [
        12,
        "<stdlib.h>：实用函数",
        "在头文件<stdlib.h>中声明了一些实现数值转换，内存分配等类似功能的函数。下面给出头文件<stdlib.h>中声明的函数以及功能简介，见下表。\r\n<stdlib.h>中声明的函数\r\n[code=java]\r\n函数定义, 函数功能简介\r\n#[Keywords]double #atof(const #[Keywords]char #*s), 将字符串s转换为double类型\r\n#[Keywords]int #atoi(const #[Keywords]char #*s) , 将字符串s转换为int类型\r\n#[Keywords]long #atol(const #[Keywords]char #*s), 将字符串s转换为long类型\r\n#[Keywords]double #strtod (const char*s,#[Keywords]char #**endp) , 将字符串s前缀转换为double型\r\n#[Keywords]long #strtol(const char*s,#[Keywords]char #**endp,#[Keywords]int #base), 将字符串s前缀转换为long型\r\nunsinged #[Keywords]long #strtol(const char*s,#[Keywords]char #**endp,#[Keywords]int #base), 将字符串s前缀转换为unsinged long型\r\n#[Keywords]int #rand(void), 产生一个0~RAND_MAX之间的伪随机数\r\n#[Keywords]void #srand(unsigned #[Keywords]int #seed) , 初始化随机数发生器\r\n#[Keywords]void #*calloc(size_t nelem, size_t elsize), 分配主存储器\r\n#[Keywords]void #*malloc(unsigned size), 内存分配函数\r\n#[Keywords]void #*realloc(#[Keywords]void #*ptr, unsigned newsize), 重新分配主存\r\n#[Keywords]void #free(#[Keywords]void #*ptr), 释放已分配的块\r\n#[Keywords]void #abort(void), 异常终止一个进程\r\n#[Keywords]void #exit(#[Keywords]int #status), 终止应用程序\r\n#[Keywords]int #atexit(atexit_t func), 注册终止函数\r\n#[Keywords]char #*getenv(#[Keywords]char #*envvar), 从环境中取字符串\r\n#[Keywords]void #*bsearch(const #[Keywords]void #*key, const #[Keywords]void #*base, size_t *nelem, size_t width, int(*fcmp)(const #[Keywords]void #*, const *)), 二分法搜索函数\r\n#[Keywords]void #qsort(#[Keywords]void #*base, #[Keywords]int #nelem, #[Keywords]int #width, #[Keywords]int #(*fcmp)()), 使用快速排序例程进行排序\r\n#[Keywords]int #abs(#[Keywords]int #i), 求整数的绝对值\r\n#[Keywords]long #labs(#[Keywords]long #n), 取长整型绝对值\r\ndiv_t  div(#[Keywords]int #number, #[Keywords]int #denom), 将两个整数相除, 返回商和余数\r\nldiv_t ldiv(#[Keywords]long #lnumer, #[Keywords]long #ldenom), 两个长整型数相除, 返回商和余数\r\n[\/code]\r\n有关上面列出的这些标准实用函数的功能、用法、例程等。",
        8,
        126,
        1
      ],
      [
        13,
        "time.h：日期与时间函数",
        "在头文件<time.h>中，声明了一些处理日期和时间的类型与函数。clock_t和time_t是两个表示时间值的算术类型。结构struct tm存储了一个日历时间的各个成分。结构tm的成员的意义及其正常的取值范围如下：\r\n[code=java]\r\nstruct\ttm\t{\r\n\t#[Keywords]int\t#tm_sec;      \/*从当前分钟开始经过的秒数(0,61)*\/\r\n\t#[Keywords]int\t#tm_min;      \/*从当前小时开始经过的分钟数(0,59)*\/\r\n\t#[Keywords]int\t#tm_hour;     \/*从午夜开始经过的小时数(0,23)*\/\r\n\t#[Keywords]int\t#tm_mday;    \/*当月的天数(1,31)*\/\r\n\t#[Keywords]int\t#tm_mon;     \/*从1月起经过的月数(0,11)*\/\r\n\t#[Keywords]int\t#tm_year;     \/*从1900年起经过的年数*\/\r\n\t#[Keywords]int\t#tm_wday;    \/*从本周星期天开始经过的天数(0,6)*\/\r\n\t#[Keywords]int\t#tm_yday;    \/*从今年1月1日起经过的天数(0,356)*\/\r\n\t#[Keywords]int\t#tm_isdst;    \/*夏令时标记*\/\r\n#};\r\n[\/code]\r\n如果夏令时有效，夏令时标记tm_isdst值为正；若夏令时无效，tm_isdst值为0；如果得不到夏令时信息，tm_isdst值为负。\r\n下面给出头文件<time.h>中声明的时间函数，见下表。\r\n<time.h>中声明的时间函数\r\n[code=java]\r\n函数定义, 函数功能简介\r\nclock_t clock(void), 确定处理器时间函数\r\ntime_t time(time_t *tp), 返回当前日历时间\r\n#[Keywords]double #difftime(time_t time2, time_t time1), 计算两个时刻之间的时间差\r\ntime_t mktime(struct tm *tp), 将分段时间值转换为日历时间值\r\n#[Keywords]char #*asctime(const struct tm *tblock), 转换日期和时间为ASCII码\r\n#[Keywords]char #*ctime(const time_t *time), 把日期和时间转换为字符串\r\nstruct tm *gmtime(const time_t *timer), 把日期和时间转换为格林尼治标准时间(GMT)\r\nstruct tm *localtime(const time_t *timer), 把日期和时间转变为结构\r\nsize_t strftime(#[Keywords]char #*s,size_t smax,const #[Keywords]char #*fmt, const struct tm *tp) , 根据fmt的格式要求将*tp中的日期与时间转换为指定格式。\r\n[\/code]",
        8,
        126,
        1
      ],
      [
        8,
        "signal.h：信号",
        "头文件<signal.h>中提供了一些处理程序运行期间引发的各种异常条件的功能，例如一些来自外部的中断信号等。\r\n在<signal.h>中只定义了两个函数：\r\n[code=java]\r\n#[Keywords]int #signal(#[Keywords]int #sig, sigfun fname);\r\n[\/code]\r\n和\r\n[code=java]\r\n#[Keywords]int #raise(#[Keywords]int #sig);\r\n[\/code]\r\nsignal函数的作用是设置某一信号的对应动作。其中参数sig用来指定哪一个信号被设置处理函数。在标准C 中支持的信号如下表。\r\n标准C支持的信号\r\n[code=java]\r\n取值, 说明, 默认执行动作, 使用的操作系统\r\nSIGABRT, 异常中止, 中止程序, UNIX DOS\r\nSIGPPE, 算术运算错误, 中止程序, UNIX DOS\r\nSIGILL, 非法硬件指令, 中止程序, UNIX DOS\r\nSIGINT, 终端中断, 中止程序, UNIX DOS\r\nSIGSEGV, 无效的内存访问, 中止程序, UNIX DOS\r\nSIGTERM, 中止信号, 中止程序, UNIX DOS\r\n[\/code]\r\n参数fname是一个指向函数的指针，当sig的信号发生时程序会自动中断转而执行fname指向的函数。执行完毕再返回断点继续执行程序。系统提供了两个常量函数指针，可以作为函数的参数传递。它们分别是：\r\n[code=java]\r\nSIG_DEF：执行默认的系统第一的函数。\r\nSIG_IGN：忽略此信号。\r\n[\/code]\r\nraise函数的作用是向正在执行的程序发送一个信号，从而使得当前进程产生一个中断而转向信号处理函数signal执行。其中参数sig为信号名称，它的取值范围同函数signal中的参数sig取值范围相同，见表9-6。\r\n下面通过例子理解函数signal和raise。\r\n例程9-2 signall和raise函数演示\r\n[code=java]\r\n#include <stdio.h> \r\n#include <signal.h> \r\n#[Keywords]void #Print1();\r\n#[Keywords]void #Print2();\r\n#[Keywords]int #main()\r\n{   signal(SIGINT,Print1);\r\n    #printf(#[Fields]\"Please enter Ctr+c #[Keywords]for #interupt\\n\"#) ;\r\n    #getchar();\r\n    #signal(SIGSEGV,Print2);\r\n    #printf(#[Fields]\"Please enter any key #[Keywords]for #a interupt\\n\"#);\r\n    #getchar();\r\n    #raise(SIGSEGV);\r\n\r\n#}\r\n#[Keywords]void #Print1()\r\n{\r\n    #printf(#[Fields]\"This is a SIGINT interupt!\\n\"#);\r\n#}\r\n#[Keywords]void #Print2()\r\n{\r\n    #printf(#[Fields]\"This is a SIGSEGV interupt!\\n\"#);\r\n#}\r\n[\/code]\r\n本例程首先通过用户终端输入Ctrl+c产生一个终端中断，然后应用signal函数调用中断处理函数Print1；再通过raise函数生成一个无效内存访问中断，并通过signal函数调用中断处理函数Print2。\r\n本例程的运行结果为：\r\n[code=java]\r\nPlease enter Ctr+c for interupt\r\n^C\r\nThis is a SIGINT interupt!\r\n\r\nPlease enter any key for a interupt\r\na\r\nThis is a SIGSEGV interupt!\r\n[\/code]",
        8,
        126,
        1
      ],
      [
        100,
        "IO函数",
        "",
        9,
        127,
        1
      ],
      [
        101,
        "clearerr：复位错误标志函数",
        "函数原型：void clearerr(FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：复位错误标志，即：使fp所指向的文件中的错误标志和文件结束标志置0。当输入输出函数对文件进行读写出错时，文件就会自动产生错误标志，这样会影响程序对文件的后续操作。clearerr函数就是要复位这些错误标志，也就是使fp所指向的文件的错误标志和文件结束标志置0，从而使文件恢复正常。\r\n返回值：无\r\n例程如下：复位错误标志演示。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{\r\n   #FILE *fp;\r\n   #[Keywords]char #ch; \r\n   #\/* 以写的方式打开一个文件名为test.txt的文件 *\/\r\n   #fp = fopen(#[Fields]\"test.txt\"#, #[Fields]\"w\"#);\r\n   #\/* 错误地从fp所指定的文件中读取一个字符，并打印它*\/\r\n   #ch = fgetc(fp);\r\n   #[Keywords]if #(ferror(fp)) \r\n   #{\r\n      #\/* 如果此操作错误，就发布错误信息*\/\r\n      #printf(#[Fields]\"This is a error reading!\\n\"#);\r\n      #\/*复位错误标志*\/\r\n      #clearerr(fp);\r\n   #} \r\n    #\/*关闭文件*\/\r\nfclose(fp); \r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先程序以只写的方式打开一个文件名为”test.txt”的文件。这样，该文件就只能写而不能读了。\r\n（2）程序企图应用fgetc函数从fp所指的文件中读出一个字符，这当然是违法的，因此文件自动产生错误标志。\r\n（3）当用ferror函数检测出文件流存在错误时，就发布一条错误信息，并用clearerr函数清除fp指定的文件流所使用的错误标志，也就是使fp所指的文件的错误标志和文件结束标志置0。这样原先的错误就不会对文件的后续操作产生影响。\r\n注意：ferror函数与clearerr函数应该配合使用。也就是说，通过ferror函数检测出文件有错误标志后要用clearerr函数复位错误标志。",
        8,
        127,
        1
      ],
      [
        102,
        "feof：检测文件结束符函数",
        "函数原型：int feof(FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：检测流上的文件结束符，即：检测文件是否结束。应用该函数可以判断一个文件是否到了结尾。在读取一个未知长度文件时，这个函数很有用。\r\n返回值：遇到文件结束符返回非0，否则返回0。\r\n例程如下：：检测文件结束标志演示。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *stream;\r\n   #\/* 以只读方式打开test.txt文件 *\/\r\n   #stream = fopen(#[Fields]\"test.txt\"#, #[Fields]\"r\"#);\r\n   #\/* 从文件中读取一个字符 *\/\r\n   #fgetc(stream);\r\n   #\/*检测是否是EOF，即结束标志 *\/\r\n   #[Keywords]if #(feof(stream)) \r\n      #printf(#[Fields]\"Have reached the end of the file!\\n\"#);\r\n   #\/* 关闭该文件 *\/\r\n   #fclose(stream);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n例程说明：\r\n（1）首先程序打开一个名为test.txt的文件。\r\n（2）应用fgetc函数从一个名为test.txt的文件中读取一个字符。\r\n（3）判断它是否为文件结束标志EOF，如果是文件结束标志，就说明该文件已经结束，于是在屏幕上显示一条提示信息。如果不是文件的结束标志，就说明文件还未结束，信息不显示。\r\n（4）最后关闭文件。\r\n注意：在实际应用中，feof函数很重要，利用它程序员就可以很方便地判断当前的文件是否结束，从而进行不同的处理。例如，在从一个未知长度的文件中读取信息时，就可以利用feof函数判断什么时候该文件读完。",
        8,
        127,
        1
      ],
      [
        103,
        "ferror：检测流上的错误函数",
        "函数原型：int ferror(FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：检测流上的错误。即：检查文件在使用各种输入输出函数进行读写时是否出错。当输入输出函数对文件进行读写时出错，文件就会产生错误标志。应用这个函数，就可以检查出fp所指向的文件操作是否出错，也就是说是否有错误标志。\r\n返回值：未出错返回值为0，否则返回非0，表示有错。\r\n例程如下：应用ferror函数检查流上的错误。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *fp;\r\n   #[Keywords]char #ch; \r\n   #\/* 以写的方式打开一个文件名为test.txt的文件 *\/\r\n   #fp = fopen(#[Fields]\"test.txt\"#, #[Fields]\"w\"#);\r\n   #\/* 错误地从fp所指定的文件中读取一个字符，并打印它*\/\r\n   #ch = fgetc(fp);\r\n   #printf(#[Fields]\"%c\\n\"#,ch);\r\n   #[Keywords]if #(ferror(fp)) \r\n   #{\r\n      #\/* 如果此操作错误，就发布错误信息*\/\r\n      #printf(#[Fields]\"Error reading from test.txt !\\n\"#);\r\n      #\/*复位错误标志*\/\r\n      #clearerr(fp);\r\n   #} \r\n    #\/*关闭文件*\/\r\nfclose(fp); \r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n例程说明：\r\n（1）首先以只写的方式打开一个文件名为”test.txt”的文件。这样，该文件就只能写而不能读了。程序企图用fgetc函数从fp所指的文件中读出一个字符，这样就是非法操作，也就是说在用fgetc函数进行读取字符时出错了，因此文件产生错误标志。\r\n（2）再用ferror函数来检测输入输出函数进行文件读写操作时是否出错，结果发现有错，因此函数返回一个非0整型数，并提示出错信息。",
        8,
        127,
        1
      ],
      [
        104,
        "fflush：清除文件缓冲区函数",
        "函数原型：int fflush(FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：清除一个流，即清除文件缓冲区，当文件以写方式打开时，将缓冲区内容写入文件。也就是说，对于ANSI C规定的是缓冲文件系统，函数fflush用于将缓冲区的内容输出到文件中去。\r\n返回值：如果成功刷新，fflush返回0。指定的流没有缓冲区或者只读打开时也返回0值。返回EOF指出一个错误。\r\n例程如下：第一种方式读写文件 \r\n[code=java]\r\n#include <string.h>\r\n#include <stdio.h>\r\n#include <conio.h>\r\n#include <io.h>\r\n#[Keywords]int #main(void)\r\n{\r\n   #FILE *stream1,*stream2;\r\n   #[Keywords]char #test[20]=#[Fields]\"This is a test\"#;\r\n   #[Keywords]char #res[20];\r\n   #\/*以写的方式打开文件test.txt*\/\r\n   #stream1 = fopen(#[Fields]\"test.txt\"#, #[Fields]\"w\"#);\r\n   #\/*向文件写入字符串*\/\r\n   #fwrite(test,15,1,stream1);\r\n   #\/*以读的方式打开文件test.txt*\/\r\n   #stream2 = fopen(#[Fields]\"test.txt\"#, #[Fields]\"r\"#);\r\n   #\/*将文件内容读入缓冲区*\/\r\n #[Keywords]if#(fread(res,15,1,stream2))\r\n        #printf(#[Fields]\"%s\"#,res);\r\n  #[Keywords] else#\r\n        #printf(#[Fields]\"Read error!\\n\"#);\r\n   #fclose(stream1);\r\n   #fclose(stream2);\r\n   #getch();\r\n   #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n例程如下：：第二种方式读写文件\r\n[code=java]\r\n#include <string.h>\r\n#include <stdio.h>\r\n#include <conio.h>\r\n#include <io.h>\r\n#[Keywords]int #main(void)\r\n{\r\n   #FILE *stream1,*stream2;\r\n   #[Keywords]char #test[20]=#[Fields]\"This is a test\"#;\r\n   #[Keywords]char #res[20];\r\n   #\/*以写的方式打开文件test.txt*\/\r\n   #stream1 = fopen(#[Fields]\"test.txt\"#, #[Fields]\"w\"#);\r\n   #\/*向文件写入字符串*\/\r\n   #fwrite(test,15,1,stream1);\r\n\t#\/*将缓冲区的内容写入文件*\/\r\n   #fflush(stream1);\r\n   #\/*以读的方式打开文件test.txt*\/\r\n   #stream2 = fopen(#[Fields]\"test.txt\"#, #[Fields]\"r\"#);\r\n   #\/*将文件内容读入缓冲区*\/\r\n #[Keywords]if#(fread(res,15,1,stream2))\r\n        #printf(#[Fields]\"%s\"#,res);\r\n  #[Keywords] else#\r\n        #printf(#[Fields]\"Read error!\\n\"#);\r\n   #fclose(stream1);\r\n   #fclose(stream2);\r\n   #getch();\r\n   #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n例程说明：\r\n例程如下：中定义了两个文件指针stream1和stream2。\r\n（1）首先以写的方式打开文件test.txt，用指针stream1指向该文件，并向文件中写入字符串\"This is a test\"。\r\n（2）不关闭该文件，以读的方式打开文件test.txt，并用指针stream2指向该文件，试图将刚刚写入的字符串读入到内存缓冲区中。如果读入成功，打印出该字符串，否则报错。\r\n实践证明，例程如下：的输出结果是在屏幕上显示错误信息Read error!。\r\n例程如下：中定义了两个文件指针stream1和stream2。\r\n（1）首先以写的方式打开文件test.txt，用指针stream1指向该文件，并向文件中写入字符串\"This is a test\"。\r\n（2）调用fflush函数将缓冲区的内容写入文件。\r\n（3）不关闭该文件，以读的方式打开文件test.txt，并用指针stream2指向该文件，试图将刚刚写入的字符串读入到内存缓冲区中。如果读入成功，打印出该字符串，否则报错。\r\n实践证明，例程如下：的输出结果是在屏幕上显示字符串\"This is a test\"。\r\n产生这样的效果原因在于：例程如下：中将文件打开后，指针stream1指向的是该文件的内存缓冲区，将字符串写入后也只是写到了文件的内存缓冲区中，而并没有写到磁盘上的文件中。而当以读的方式打开该文件时，该文件中的内容实际为空，也就是stream2指向的缓冲区中内容为空。因此读文件发生错误。而例程如下：中，在写完文件后调用函数fflush，将缓冲区的内容写到文件中，这样再以读的方式打开该文件时，文件中已经存有了字符串，因此可以正常读出。\r\n注意：如果在写完文件后调用函数fclose关闭该文件，同样可以达到将缓冲区的内容写到文件中的目的，但是那样系统开销较大。",
        8,
        127,
        1
      ],
      [
        105,
        "fgetc：从流中读取字符函数",
        "函数原型：int fgetc(FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：从流中读取字符，即从fp所指定的文件中取得下一个字符。这里需要注意，在每取完一个字符时fp会自动向下移动一个字节。这样编成时，程序员就不用再对fp控制了。这种功能在许多读写函数中都有体现。\r\n返回值：返回所得到的字符，若读入错误。返回EOF。\r\n例程如下：应用fgetc函数从文件中自动读取字符。\r\n[code=java]\r\n#include <string.h> \r\n#include <stdio.h> \r\n#include <conio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *fp;\r\n   #[Keywords]char #string[] = #[Fields]\"This is a test\"#; \r\n   #[Keywords]char #ch; \r\n   #\/* 以读写方式打开一个名为test.txt的文件 *\/\r\n   #fp = fopen(#[Fields]\"test.txt\"#, #[Fields]\"w+\"#);\r\n   #\/* 向文件中写入字符串string *\/\r\n   #fwrite(string, strlen(string), 1, fp);\r\n   #\/* 将fp指针指向文件首 *\/\r\n   #fseek(fp, 0, SEEK_SET);\r\n   #[Keywords]do #\r\n   #{\r\n      #\/* 从文件中读一个字符 *\/\r\n      #ch = fgetc(fp);\r\n      #\/* 显示该字符 *\/\r\n      #putch(ch);\r\n   #} #[Keywords]while #(ch != EOF); \r\n   #fclose(fp);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n例程说明：\r\n（1）首先程序先以读写方式打开一个名为test.txt的文件，并向该文件中写入一个字符串。\r\n（2）再应用fseek函数将文件指针fp定位在文件的开头，再循环地将字符逐一读出。这里每读出一个字符，指针fp会自动地向后移一个字节，直至读到文件尾，即EOF标志，循环才停止。因为fgetc函数的返回值为得到的字符，所以用一个字符型变量ch 来接受读出的字符。\r\n（3）最后的运行结果是在屏幕上打印出This is a test字符串。",
        8,
        127,
        1
      ],
      [
        106,
        "fgetpos：取得当前文件的句柄函数",
        "函数原型：int fgetpos( FILE *stream, fpos_t *pos );\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：取得当前文件的指针所指的位置，并把该指针所指的位置数存放到pos所指的对象中。pos值以内部格式存储,仅由fgetpos和fsetpos使用。其中fsetpos的功能与fgetpos相反，为了详细介绍，将在后节给与说明。\r\n返回值：成功返回0，失败返回非0，并设置errno。\r\n例程如下：应用fgetpos函数取得当前文件的指针所指的位置。\r\n[code=java]\r\n#include <string.h> \r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *fp;\r\n   #[Keywords]char #string[] = #[Fields]\"This is a test\"#; \r\n   #fpos_t pos;\r\n   #\/* 以读写方式打开一个名为test.txt的文件 *\/\r\n   #fp = fopen(#[Fields]\"test.txt\"#, #[Fields]\"w+\"#);\r\n   #\/* 将字符串写入文件 *\/\r\n   #fwrite(string, strlen(string), 1, fp);\r\n   #\/* 取得指针位置并存入&pos所指向的对象 *\/\r\n   #fgetpos(fp, &pos);\r\n   #printf(#[Fields]\"The file pointer is at byte %ld\\n\"#, pos);\r\n    #\/*重设文件指针的位置*\/\r\n   #fseek(fp,3,0);\r\n    #\/* 再次取得指针位置并存入&pos所指向的对象 *\/\r\n   #fgetpos(fp, &pos);\r\n   #printf(#[Fields]\"The file pointer is at byte %ld\\n\"#, pos);\r\n   #fclose(fp);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n例程说明：\r\n（1）首先，程序以读写方式打开一个名为test.txt的文件，并把字符串\"This is a test\"写入文件。注意：字符串共14个字节，地址为0~13。用fwrite函数写入后，文件指针自动指向文件最后一个字节的下一个位置。即这时的fp的值应该是14。\r\n（2）再用fgetpos函数取得指针位置并存入&pos所指向的对象，此时， pos中的内容为14。然后在屏幕上显示出The file pointer is at byte 14。\r\n（3）再用fseek函数重设文件指针的位置，让fp的值为3，即指向文件中第4个字节。\r\n再次取得指针位置并存入&pos所指向的对象。然后在屏幕上显示出The file pointer is at byte 3。",
        8,
        127,
        1
      ],
      [
        107,
        "fgets：从流中读取字符串函数",
        "函数原型：char *fgets(char *string, int n, FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：从fp所指的文件中读取一个长度为(n-1)的字符串，并将该字符串存入以string为起始地址的缓冲区中。fgets函数有三个参数，其中string为缓冲区首地址，n规定了要读取的最大长度，fp为文件指针。\r\n返回值：返回地址string，若遇到文件结束符或出错，返回NULL。用feof 或ferror判断是否出错。\r\n例程如下：用fgets函数从文件中读取字符串。\r\n[code=java]\r\n#include <string.h> \r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *fp;\r\n   #[Keywords]char #string[] = #[Fields]\"This is a test\"#; \r\n   #[Keywords]char #str[20];\r\n   #\/* 以读写的方式打开一个名为test.txt的文件 *\/\r\n   #fp = fopen(#[Fields]\"test.txt\"#, #[Fields]\"w+\"#);\r\n   #\/* 将字符串写入文件 *\/\r\n   #fwrite(string, strlen(string), 1, fp);\r\n   #\/* 文件指针定位在文件开头*\/\r\n   #fseek(fp, 0, SEEK_SET);\r\n   #\/* 从文件中读一个长为strlen(string)的字符串 *\/\r\n   #fgets(str, strlen(string)+1, fp);\r\n   #\/* 显示该字符串 *\/\r\n   #printf(#[Fields]\"%s\"#, str);\r\n   #fclose(fp);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，以读写的方式打开一个名为test.txt的文件，并将字符串写入文件。\r\n应用fseek函数将文件指针定位在文件开头。\r\n（2）从文件中读一个长为strlen(string)的字符串，这里应注意第二个参数若为n，则表示从fp所指的文件中读取一个长度为(n-1)的字符串。因此，这里的参数为strlen(string)+1，表示读取一个长度为strlen(string)的字符串。把字符串读到以str为首地址的数组中。\r\n（3）最后显示该字符串。",
        8,
        127,
        1
      ],
      [
        108,
        "fopen、fclose：文件的打开与关闭函数",
        "函数原型：FILE *fopen(char *filename, char *type);  \r\nint fclose(FILE *fp); \r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：函数fopen：打开一个流，即：打开一个文件。该函数有两个参数，filename是需要打开文件的文件名，type是打开文件的方式。函数fclose：关闭一个流，即：关闭一个文件，并释放文件缓冲区。fclose函数与fopen函数是相对的两个函数。fclose函数的参数是指向文件的指针，应用该函数用以在程序结束之前关闭文件，并释放文件缓冲区。这样可以保证文件的数据不流失。\r\n在这里，特别列出所有的文件打开方式，以供大家参考。如下表所示。\r\n文件的打开方式\r\n[code=java]\r\n文件使用方式\t意 义\r\nr\t只读打开一个文本文件，只允许读数据 \r\nw\t只写打开或建立一个文本文件，只允许写数据\r\na\t追加打开一个文本文件，并在文件末尾写数据\r\nrb\t只读打开一个二进制文件，只允许读数据\r\nwb\t只写打开或建立一个二进制文件，只允许写数据\r\nab\t追加打开一个二进制文件，并在文件末尾写数据\r\nr+\t读写打开一个文本文件，允许读和写\r\nw+\t读写打开或建立一个文本文件，允许读写\r\na+\t读写打开一个文本文件，允许读，或在文件末追加数据\r\nrb+\t读写打开一个二进制文件，允许读和写 \r\nwb+\t读写打开或建立一个二进制文件，允许读和写\r\nab+\t读写打开一个二进制文件，允许读，或在文件末追加数据\r\n[\/code]\r\n返回值：fopen：FILE类型，如果打开的文件存在，返回指向该文件的指针；如果打开的文件不存在，则在指定的目录下建立该文件打开，并返回指向该文件的指针。fclose：整型，有错返回非0，否则返回0。\r\n例程如下：打开并输出一个文件，然后关闭。\r\n[code=java]\r\n#include <string.h> \r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *fp;\r\n   #[Keywords]char #buf[11] = #[Fields]\"abcdefghij\"#; \r\n   #\/* 以写方式打开文件名为test.txt的文件 *\/\r\n   #fp = fopen(#[Fields]\"test.txt\"#, #[Fields]\"w\"#);\r\n\/*把字符串写入文件中*\/\r\n   #fwrite(&buf, strlen(buf), 1, fp);\r\n   #\/* 关闭文件 *\/\r\n   #fclose(fp);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先开辟一个11个字节大小的缓冲区buf，也就是数组，但预先只能存入10个字符。这是因为C语言中规定数组存放字符串时，最后一个字节要以’\/0’结尾，作为结束标志，并由系统自动在字符串末尾添加’\/0’标志。因此，11个字节大小的缓冲区只存放一个长10个字节的字符串。\r\n（2）用fopen函数以写的方式打开一个名为test.txt的文件并将字符串写入文件。\r\n调用fclose函数关闭该文件。\r\n（3）fclose函数与fopen函数正好相对，其作用是关闭一个文件。当使用fopen函数打开一个文件时，会返回一个指向该文件的指针。在该例程中这个指针被赋值给fp，也就是说fp指向了test.txt这个文件。而当调用fclose函数关闭该文件，即fclose(fp)时，fp就不再指向该文件了，相应的文件缓冲区也被释放。\r\n注意：用户在编写程序时应该养成及时关闭文件的习惯，如果不及时关闭文件，文件数据有可能会丢失。",
        8,
        127,
        1
      ],
      [
        109,
        "fprintf：格式化输出函数",
        "函数原型：int fprintf(FILE *fp, char *format[, argument,...]);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：把argument的值以format所指定的格式输出到fp指向的文件中。这个函数理解起来和printf类似，在一般的使用中，第二个参数可以是一个字符串的头指针，也可以就是一个字符串。例如：fprintf(fp, \"Cannot open this file!!\")，意思就是把字符串Cannot open this file!!输出到文件fp中去。该函数一般用作终端的出错提示或是在磁盘中生成错误报告。\r\n返回值：如果正确返回实际输出字符数，若错误则返回一个负数。\r\n例程如下 用fprintf函数向终端发出出错提示。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *fp;\r\n     #\/*以只读方式打开名为test.txt的文件*\/\r\n   #[Keywords]if #((fp = fopen(#[Fields]\"\\\\test.txt\"#, #[Fields]\"rt\"#))\r\n       #== NULL)\r\n   #{\r\n      #fprintf(stderr, #[Fields]\"Cannot open #[Keywords]this# file!!\\n\"#);\r\n      #[Keywords]return #1;    \/*若该文件不能打开，在屏幕上显示出错提示*\/\r\n   #} \r\n      #\/*若该文件能够打开，在屏幕上显示正确提示*\/\r\n      #fprintf(stderr,#[Fields]\"Have open #[Keywords]this# file!!\\n\"#);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，以只读方式打开名为test.txt的文件，如果文件不能打开，这返回NULL。\r\n（2）若该文件不能打开，在屏幕上显示出错提示。\r\n（3）若该文件能够打开，在屏幕上显示正确提示。\r\n注意：该函数中第一个参数是stderr，这是C语言中标准出错输出指针，它指向标准的出错输出文件，也就是显示器。因为，在操作系统中，I\/O设备都是用文件进行管理的，因此设备都配有相应的控制文件。在C语言中，有三个文件与终端相联系，因此系统定义了三个文件指针。见下表：\r\n[code=java]\r\n设备文件\t文件指针\r\n标准输入\tstdin\r\n标准输出\tstdout\r\n标准出错输出\tstderr\r\n[\/code]\r\n在系统运行时，程序自动打开这三个标准文件。\r\n本例程的运行结果为：\r\n（1）如果不能打开文件：\r\nCannot open this file!!\r\n（2）如果可以打开文件：\r\nHave open this file!!\r\n例程如下用fprintf函数在磁盘中生成错误报告。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *fp1,*fp2;\r\n\/*以只读方式打开名为test.txt的文件*\/\r\n   #[Keywords]if #((fp1 = fopen(#[Fields]\"text.txt\"#, #[Fields]\"rt\"#))\r\n       #== NULL)\r\n   #{\r\n\t#\/*若文件打不开，则生成错误报告*\/\r\n      #fp2=fopen(#[Fields]\"report.txt\"#,#[Fields]\"w\"#);\r\n      #fprintf(fp2, #[Fields]\"Cannot open #[Keywords]this# file!!\\n\"#);\r\n      #[Keywords]return #1; \r\n   #} \r\n     #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，以只读方式打开名为test.txt的文件，如果文件不能打开，这返回NULL。\r\n（2）若该文件不能打开，则以写的方式打开一个名为report.txt的文件，并按照格式要求向文件中写入字符串\"Cannot open this file!!\\n\"，即生成了一个错误报告。\r\n注意：这里函数fprintf的第一个参数为文件指针，是用户自定义的，与上一例程的系统定义的文件指针stderr不同。fprintf函数与printf函数的使用类似，其实printf函数是fprintf函数的一个特例，printf函数只能向标准输出文件（显示器）输出数据，而fprintf函数也可以向一般用户定义的文件输出数据。",
        8,
        127,
        1
      ],
      [
        110,
        "fputc：向流中输出字符函数",
        "函数原型：int fputc(char ch, FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：将字符ch输出到fp指向的文件中。该函数与前边提到的fgetc是相对的，第一个参数ch是字符型变量，函数将该变量中的字符输出到fp指向的文件中。\r\n返回值：成功返回该字符，否则返回非0。\r\n例程如下 应用fputc向文件输出字符。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n\t#\/*初始化字符数组str *\/\r\n   #[Keywords]char #str[] = #[Fields]\"This is a test\"#;\r\n   #[Keywords]int #i = 0; \r\n\t#\/*将数组中的字符循环输出至屏幕*\/\r\n   #[Keywords]while #(str[i])\r\n   #{\r\n      #fputc(str[i], stdout);\r\n      #i++;\r\n   #} \r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先初始化字符数组str。这里应当知道，在C语言中初始化数组，系统会自动在数组最后添加\"\/0\"，以表示该字符串结束。\r\n（2）将数组中的字符循环输出至屏幕。这里注意两点：\r\nA.该循环以\"\/0\"作为结束标志，即循环碰到\"\/0\"时结束。\r\nB.函数fputc的第二个参数是stdout，前面已讲过它代表标准输出文件指针，这样就是在屏幕上显示该字串。\r\n本例程的运行结果为：\r\n[code=java]\r\nThis is a test\r\n[\/code]",
        8,
        127,
        1
      ],
      [
        111,
        "fputs：向流中输出字符串函数",
        "函数原型：int fputs(char *string, FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：将string所指的字符串输出到fp指向的文件中。该函数与fgets相对，第一个参数为字符串指针。与fgets函数不同的是，fputs函数没有字符串长度的限制，只是将string指向的字符串输出到文件中。\r\n返回值：成功返回0，否则返回非0。\r\n例程如下 应用fputs函数向文件中输出字符串。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *fp;\r\n   #[Keywords]char #str[]=#[Fields]\"This is a test!\"#;\r\n   #\/*以写的方式打开名为test.txt的文件*\/\r\n   #fp=fopen(#[Fields]\"test.txt\"#,#[Fields]\"w\"#);\r\n   #\/*将字符串写入文件*\/\r\n   #fputs(str,fp);\r\n   #fclose(fp);\r\n   #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先用字符数组str存储一个字符串，并以写的方式打开名为test.txt的文件。\r\n（2）再用fputs函数将该字符串输出到test.txt的文件中。",
        8,
        127,
        1
      ],
      [
        112,
        "fread：从流中读取字符串函数",
        "函数原型：int fread(void *buf, int size, int count, FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：从fp指向的文件中读取长度为size 的count个数据项，并将它输入到以buf为首地址的缓冲区中。此时，文件指针fp会自动增加实际读入数据的字节数，即fp指向最后读入字符的下一个字符位置。\r\n返回值：返回实际读入数据项的个数，即count值。若遇到错误或文件结束返回0。\r\n例程如下 应用fread函数从文件中读取数据到缓冲区。\r\n[code=java]\r\n#include <string.h> \r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *fp;\r\n   #[Keywords]char #str[] = #[Fields]\"#[Keywords]this# is a test\"#;\r\n   #[Keywords]char #buf[20]; \r\n\r\n   #[Keywords]if #((fp = fopen(#[Fields]\"test.txt\"#, #[Fields]\"w+\"#))\r\n       #== NULL)\r\n   #{\r\n      #fprintf(stderr,\r\n              #[Fields]\"Cannot open output file!!\\n\"#);\r\n      #[Keywords]return #1; \r\n   #} \r\n\r\n   #\/* 向文件中写入字符串数组中的数据 *\/\r\n   #fwrite(str, strlen(str), 1, fp);\r\n   #\/* 将文件指针定位到文件开头 *\/\r\n   #fseek(fp, SEEK_SET, 0);\r\n   #\/* 把文件中的数据读出并显示 *\/\r\n   #fread(buf, strlen(str), 1, fp);\r\n   #printf(#[Fields]\"%s\\n\"#, buf);\r\n   #fclose(fp);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）程序首先以读写方式打开名为test.txt的文件。这里有一个判断，若打开文件失败，则在屏幕上显示出错信息。\r\n（2）应用fwrite函数向文件写入数据。有关fwrite函数后面做详细介绍。\r\n（3）应用fseek函数将文件指针定位到文件开头。\r\n（4）应用fread函数把文件中的数据读入内存。这里读取一个长度为strlen(str)的字符串，并将该字符串存入以buf为首地址的内存缓冲区中。\r\n（5）显示该字符串。",
        8,
        127,
        1
      ],
      [
        113,
        "freopen：替换文件中数据流函数",
        "函数原型：FILE *freopen(char *filename, char *type, FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：关闭fp所指向的文件，并将该文件中的数据流替换到filename所指向的文件中去。该函数共三个参数：第一个参数filename是文件流将要替换到的文件名路径；第二个参数type是文件打开的方式，它与fopen中的文件打开方式类似；第三个参数fp是要被替换的文件指针。\r\n返回值：返回一个指向新文件的指针，即指向filename文件的指针。若出错，则返回NULL。\r\n例程如下 关闭一个终端，并将数据流替换至一个新文件中。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n    #FILE *Nfp;\r\n   #\/* 替换标准输出文件上的数据流到新文件test.txt *\/\r\n   #[Keywords]if #(Nfp=freopen(#[Fields]\"test.txt\"#, #[Fields]\"w\"#, stdout)\r\n       #== NULL)\r\n      #fprintf(stderr, #[Fields]\"error redirecting stdout\\n\"#);\r\n   #\/* 标准输出文件上的数据流将会被替换到新文件中 *\/\r\n   #printf(#[Fields]\"This will go into a file.\"#);\r\n\r\n   #\/* 关闭标准输出文件 *\/\r\n   #fclose(stdout);\r\n   #\/*关闭新生成的文件*\/\r\n   #fclose(Nfp);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序以写的方式打开名为test.txt的文件，将标准输出文件上的数据流\"This will go into a file.\"替换到新生成的文件test.txt中。freopen函数返回一个指向新文件的指针，即指向文件test.txt的指针，并将它存放到Nfp中。\r\n（2）然后关闭标准输出文件，fclose(stdout)。\r\n（3）最后关闭新生成的文件fclose(Nfp)。\r\n（4）本程序的执行结果是在当前目录下生成一个文件test.txt，并将原终端的数据流\"This will go into a file.\"重新写入test.txt文件中。",
        8,
        127,
        1
      ],
      [
        114,
        "fscanf：格式化输入函数",
        "函数原型：int fscanf(FILE *fp, char *format[,argument...]);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：从fp所指向的文件中按format给定的格式读取数据到argument所指向的内存单元。其中argument是指针，指针类型要与输入的格式format相一致。例如：fscanf(stdin, \"%d\", &i)；&i是整型的指针，输入的格式format也要为整型，即\"%d\"。\r\n返回值：返回已输入的数据个数。若错误或文件结束返回EOF。\r\n例程如下 应用fscanf函数从终端向内存输入数据。\r\n[code=java]\r\n#include <stdlib.h> \r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]char #ch;\r\n   #printf(#[Fields]\"Please input an character \"#);\r\n   #\/* 从标准输入文件中读取一个字符，并送至ch *\/\r\n   #[Keywords]if #(fscanf(stdin, #[Fields]\"%c\"#, &ch))\r\n      #printf(#[Fields]\"The character  was: %c\\n\"#,ch);\r\n   #[Keywords]else #\r\n   #{\r\n        #\/*出错提示*\/\r\n      #fprintf(stderr, #[Fields]\"Error reading an character from stdin!!\\n\"#);\r\n      #exit(1);\r\n   #} \r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序提示用户从键盘输入一个字符。这时，标准输入文件指针stdin指向该字符。\r\n（2）调用fscanf函数从标准输入文件中读取一个字符，并送至ch。这里应该注意两点：\r\nA.fscanf函数的第一个参数不是用户定义的文件指针，而是系统定义的标准输入文件指针stdin。但用法与用户定义的文件指针类似。\r\nB.&ch是指向字符型数据的指针，因此，输入的格式format也要为字符型\"%c\"，它们必须保持一致。\r\n（3）该函数的使用与scanf类似。其实，scanf函数是fscanf函数的一个特例，它只能从标准输入文件（键盘终端）中输入数据。而fscanf函数则也可以从一般用户定义的文件中输入数据。",
        8,
        127,
        1
      ],
      [
        115,
        "fseek：文件指针定位函数",
        "函数原型：int fseek(FILE *fp, long offset, int base);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：重定位流上的文件指针，即将fp指向的文件的位置指针移向以base为基准，以offset为偏移量的位置。该函数有三个参数：fp为文件指针，offset为偏移量，即位移offset个字节，base为指针移动的基准，即起始点。其中，基准base用0、1或2表示。在ANSI C标准指定的名字如下表\r\nANSI C标准指定的起始点名字\r\n[code=java]\r\n起始点\t名字  \t数字代码\r\n文件当前位置\tSEEK_CUR\t1\r\n文件开始位置\tSEEK_SET\t0\r\n文件末尾位置\tSEEK_END\t2\r\n[\/code]\r\n偏移量用长整型数表示。ANSI C标准规定，在数的末尾加L就表示长整型数。该函数在随机读取较长的顺序文件时是很有用的。\r\n返回值：成功返回0，否则返回非0。\r\n例程如下 文件指针的定位演示。\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]void #main( #[Keywords]void #)\r\n{\r\n   #FILE *fp;\r\n   #[Keywords]char #line[81];\r\n   #[Keywords]int # result;\r\n    #\/*以读写的方式打开打开名为test.txt的文件*\/\r\n   #fp = fopen( #[Fields]\"test.txt\"#, #[Fields]\"w+\"# );\r\n   #[Keywords]if#( fp == NULL )\r\n      #printf( #[Fields]\"The file test.txt was not opened！\\n\"# );\r\n  #[Keywords] else#\r\n   #{\r\n      #\/*按照规定格式将字符串写入文件*\/\r\n      #fprintf( fp, #[Fields]\"The fseek begins here:\r\n                       #[Fields]\"This is the file #[Fields]'test.txt'#.\\n\"# );\r\n          #\/*将文件指针定位到离文件头23个字节处*\/\r\n      #result = fseek( fp, 23L, SEEK_SET);\r\n      #[Keywords]if#( result )\r\n         #perror( #[Fields]\"Fseek failed\"# );\r\n     #[Keywords] else#\r\n      #{\r\n         #printf( #[Fields]\"File pointer is set to middle of first line.\\n\"# );\r\n         #\/*从fp指向的文件中读取字符串*\/\r\n         #fgets( line, 80, fp );\r\n         #\/*显示读取的字符串*\/\r\n         #printf( #[Fields]\"%s\"#, line );\r\n      #}\r\n      #fclose(fp);\r\n   #}\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序以读写的方式打开打开名为test.txt的文件。\r\n（2）然后，应用fprintf函数按照规定格式将字符串\"The fseek begins here: \"\"This is the file 'test.txt'.\\n\"写入文件。\r\n（3）再将文件指针定位到离文件头23个字节处，即将文件指针fp定位在字符串\"This is the file 'test.txt'.\\n\"的开头。\r\n（4）然后，应用fgets函数从fp指向的文件中读取字符串，并显示在屏幕上。\r\n本程序的运行结果为在屏幕上显示出以下字符串：\r\n[code=java]\r\nFile pointer is set to middle of first line.\r\nThis is the file 'test.txt'.\r\n[\/code]",
        8,
        127,
        1
      ],
      [
        116,
        "fsetpos：定位流上的文件指针函数",
        "函数原型：int fsetpos(FILE *fp, const fpos_t *pos);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：将文件指针定位在pos指定的位置上。该函数的功能与前面提到的fgetpos相反，是将文件指针fp按照pos指定的位置在文件中定位。pos值以内部格式存储,仅由fgetpos和fsetpos使用。\r\n返回值：成功返回0，否则返回非0。\r\n例程如下 应用fsetpos函数定位文件指针。\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]void #main( #[Keywords]void #)\r\n{\r\n   #FILE   *fp;\r\n   #fpos_t pos;\r\n   #[Keywords]char #  buffer[50];\r\n   #\/*以只读方式打开名为test.txt的文件*\/\r\n   #[Keywords]if#( (fp = fopen( #[Fields]\"test.txt\"#, #[Fields]\"rb\"# )) == NULL )\r\n      #printf( #[Fields]\"Trouble opening file\\n\"# );\r\n  #[Keywords] else#\r\n   #{\r\n      #\/*设置pos值*\/\r\n      #pos = 10;\r\n      #\/*应用fsetpos函数将文件指针fp按照\r\n      #pos指定的位置在文件中定位*\/\r\n      #[Keywords]if#( fsetpos( fp, &pos ) != 0 )\r\n        #perror( #[Fields]\"fsetpos error\"# );\r\n           #[Keywords] else#\r\n            #{\r\n                #\/*从新定位的文件指针开始读取16个字符到buffer缓冲区*\/\r\n                #fread( buffer, sizeof( #[Keywords]char #), 16, fp );\r\n                 #\/*显示结果*\/\r\n                #printf( #[Fields]\"16 bytes at byte %ld: %.16s\\n\"#, pos, buffer );\r\n                #}\r\n      #}\r\n   #fclose( fp );\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序以只读方式打开名为test.txt的文件。在这里，test.txt文件中已存入字符串This is a test for testing the function of fsetpos.\r\n（2）将pos设置为10。应用fsetpos函数将文件指针fp按照pos指定的位置在文件中定位。这样文件指针fp指向字符串中test的字母t。\r\n（3）再从新定位的文件指针开始读取16个字符到buffer缓冲区，也就是说读取字符串\"test for testing\"到缓冲区buffer。\r\n（4）最后显示结果：16 bytes at byte 10: test for testing 。",
        8,
        127,
        1
      ],
      [
        117,
        "ftell：返回当前文件指针位置函数",
        "函数原型：long ftell(FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：返回当前文件指针的位置。这个位置是指当前文件指针相对于文件开头的位移量。\r\n返回值：返回文件指针的位置，若出错则返回–1L。\r\n例程如下 应用ftell返回文件指针位置。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *fp;\r\n   #fp = fopen(#[Fields]\"test.txt\"#, #[Fields]\"w+\"#);\r\n   #\/*按照格式要求将字符串写入文件*\/\r\n   #fprintf(fp, #[Fields]\"This is a test\"#);\r\n   #\/*读出文件指针fp的位置*\/\r\n   #printf(#[Fields]\"The file pointer is at byte %ld\\n\"#, ftell(fp));\r\n   #fclose(fp);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先以写方式打开名为test.txt的文件，按照格式要求将字符串写入文件。注意：字符串共14个字符，地址为0~13。调用fprintf函数后，文件指针自动移到读入的最后一个字符的下一个位置，本例中就是文件的结束符，它的地址是14。\r\n（2）应用ftell函数读出文件指针fp的位置。\r\n注意：本题中ftell函数的返回值实际上就是该文件的长度。在实际的应用中，函数ftell常用来计算文件的长度。",
        8,
        127,
        1
      ],
      [
        118,
        "fwrite：向文件写入数据函数",
        "函数原型：int fwrite(void *buf, int size, int count, FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：将buf所指向的count*size个字节的数据输出到文件指针fp所指向的文件中去。该函数与fread相对，输出数据后，文件指针fp自动指向输出的最后一个字符的下一个位置。该函数常用于分批将数据块输出到文件中。\r\n返回值：返回实际写入文件数据项个数。\r\n例程如下 应用fwrite函数向文件中写入数据块。\r\n[code=java]\r\n#include <stdio.h> \r\nstruct exp_struct\r\n{ \r\n  #[Keywords]int #i; \r\n  #[Keywords]char #ch; \r\n#}; \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *fp;\r\n   #struct exp_struct s;\r\n    #\/*以写的方式打开名为test.txt的文件*\/\r\n   #[Keywords]if #((fp = fopen(#[Fields]\"test.txt\"#,#[Fields]\"wb\"#)) == NULL)\r\n   #{\r\n      #fprintf(stderr, #[Fields]\"Cannot open the test.txt\"#);\r\n      #[Keywords]return #1; \r\n   #} \r\n   #\/*向结构体中的成员赋值*\/\r\n   #s.i = 0;\r\n   #s.ch = #[Fields]'A'#;\r\n    #\/* 将一个结构体数据块写入文件 *\/\r\n   #fwrite(&s, sizeof(s), 1, fp);\r\n   #fclose(fp);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）程序先声明一个结构体类型struct exp_struct，这样一个结构体变量就是一个小数据块。\r\n（2）再以写的方式打开名为test.txt的文件。\r\n（3）然后向结构体中的成员变量赋值，并将赋值好的数据块应用fwrite函数写入fp 所指向的文件中。这里参数sizeof(s)是该结构体变量的大小，1指只写入文件1个数据块。\r\n（4）最后关闭该文件。",
        8,
        127,
        1
      ],
      [
        119,
        "getc：从流中读取字符函数",
        "函数原型：int getc(FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：从fp所指向的文件中读取一个字符。该函数与前面所讲到的fgetc作用类似。读取字符后，文件指针fp自动指向下一个字符。\r\n返回值：返回所读的字符，若文件结束或出错返回EOF。\r\n例程如下 应用getc函数从标准输入文件中读取一个字符。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]char #ch; \r\n   #printf(#[Fields]\"Input a character:\"#);\r\n  #\/* 从标准输入文件中读取一个字符 *\/\r\n   #ch = getc(stdin);\r\n   #\/*显示该字符*\/\r\n   #printf(#[Fields]\"The character input was: #[Fields]'%c'#\\n\"#, ch);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n本程序是从标准输入文件（键盘）中读取一个字符，存入变量ch，并显示在屏幕上。\r\n例程如下应用getc函数从一般文件中读取字符。\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]void #main( #[Keywords]void #)\r\n{\r\n    #FILE *fp;\r\n    #[Keywords]char #ch;\r\n    #\/*以写的方式打开名为test.txt的文件*\/\r\n    #fp=fopen(#[Fields]\"test.txt\"#,#[Fields]\"w\"#);\r\n    #\/*写入字符串*\/\r\n    #fprintf(fp,#[Fields]\"This is a test.\"#);\r\n    #fclose(fp);\r\n    #\/*再以读的方式打开名为test.txt的文件*\/\r\n    #fp=fopen(#[Fields]\"test.txt\"#,#[Fields]\"r\"#);\r\n    #\/*将文件指针指向文件开头*\/\r\n    #fseek(fp,0L,SEEK_SET);\r\n    #\/*应用getc函数从文件中循环读取字符并显示出来*\/\r\n   #[Keywords] while#(feof(fp)==0)\r\n    #{\r\n\r\n        #ch=getc(fp);\r\n        #printf(#[Fields]\"%c\"#,ch);\r\n    #}\r\n    #fclose(fp);\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先以写的方式打开名为test.txt的文件，并将字符串\"This is a test.\" 写入字符串。\r\n（2）再以读的方式打开名为test.txt的文件，并将文件指针指向文件开头。\r\n（3）最后，应用getc函数从文件中循环读取字符，直到文件结束为止，并将读取的字符显示到终端屏幕。\r\n注意：本例程与上例不同，上例是从标准输入文件（键盘）中读取一个字符，本例是从一般文件中读取字符，关键在于函数的参数不同。",
        8,
        127,
        1
      ],
      [
        120,
        "getchar：从标准输入文件中读取字符函数",
        "函数原型：int getchar(void);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：从标准输入文件stdin（键盘）中读取一个字符。该函数与getc类似，但参数为空，它只能从标准输入文件中读取字符，而不能读取用户自定义的文件。getchar函数在编程时多用于接收回车、换行符。\r\n返回值：返回所读的字符，若文件结束或出错返回-1。\r\n例程如下 应用getchar函数从标准输入设备读取下一个字符。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]int #c; \r\n   #\/* 从键盘上接收字符并显示，直到键入换行符为止 *\/\r\n   #[Keywords]while #((c = getchar()) != #[Fields]'\\n'#) \r\n      #printf(#[Fields]\"%c\"#, c);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n程序从键盘上接收字符并显示，当接收到换行符'\\n'时，程序结束。",
        8,
        127,
        1
      ],
      [
        121,
        "gets：从标准输入文件中读取字符串函数",
        "函数原型：char *gets(char *buf);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：从标准输入文件stdin（键盘）中读取一个字符串，并把该字符串存入以buf为首地址的缓冲区中。该函数与fgets类似，但它只能从标准输入文件stdin中读取字符串，而且没有长度限制。\r\n返回值：返回其参数，即缓冲区指针buf，若出错则返回空NULL。\r\n例程如下 应用gets函数从键盘读取字符串。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]char #string[30];\r\n   #printf(#[Fields]\"Input a string:\"#);\r\n   #\/*从终端输入字符串，注意不要超过30个字符*\/\r\n   #gets(string);\r\n   #\/*显示该字符串*\/\r\n   #printf(#[Fields]\"The string input was: %s\\n\"#,string);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序开辟一个可容纳30个字符的字符串数组空间，并在屏幕上提示用户输入一个字符串。\r\n（2）应用gets函数接收键盘输入的字符串，并把它存储到以string为首地址的缓冲区中。\r\n（3）最后，将以string为首地址的缓冲区中的内容显示出来，即在屏幕上显示输入的字符串。",
        8,
        127,
        1
      ],
      [
        122,
        "perror：打印系统错误信息函数",
        "函数原型：void perror(char *string);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：将错误信息输出到标准出错输出stderr。该函数的参数是字符串指针，指向错误信息字符串。也可以就是一个字符串，直接在参数中输入要显示的错误信息。但要注意，完整的错误信息不仅包括用户在参数中自己定义的字符串，还包括一个冒号，系统报错信息，和一个换行符。该函数主要用作向终端进行错误提示。\r\n返回值：无。\r\n例程如下 应用perror函数显示错误信息。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *fp;\r\n   #\/*企图以读的方式打开文件test.txt*\/\r\n   #fp = fopen(#[Fields]\"test.txt\"#, #[Fields]\"r\"#);\r\n   #[Keywords]if #(fp==NULL)\r\n    #\/*该文件不存在，在终端显示错误信息*\/\r\n      #perror(#[Fields]\"Unable to open file #[Keywords]for #reading\"#);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先程序企图以读的方式打开文件test.txt，但在这里该文件并不存在。\r\n（2）然后，利用函数perror在终端显示错误信息\"Unable to open file for reading: No such file or directory\"。\r\n具体的运行结果格式如下：\r\n[code=java]\r\nUnable to open file for reading: No such file or directory\r\n[\/code]\r\n注意：完整的错误信息包括：用户自定义字符串，冒号，系统报错信息，换行符。",
        8,
        127,
        1
      ],
      [
        123,
        "printf：产生格式化输出的函数",
        "函数原型：int printf( const char *format [, argument]... );\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：按format指向的格式字符串所规定的格式，将输出表列argument的值输出到标准输出设备。该函数与fprintf类似，但只能将argument的值输出到标准输出设备stdout,即显示器屏幕，而不能输出到用户自定义的文件中。\r\n返回值：输出字符的个数，若出错则返回一个负数。\r\n例程如下 应用printf函数输出字符串。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h>\r\n#[Keywords]int #main(void) \r\n{\r\n  #[Keywords]int #a=1;\r\n  #[Keywords]char #ch=#[Fields]'r'#;\r\n  #[Keywords]char #str[]=#[Fields]\"This is a test!\"#;\r\n  #printf(#[Fields]\"Output a string.\\n\"#);\r\n  #printf(#[Fields]\"%s\"#,str);\r\n  #printf(#[Fields]\"The integer is %d\\n\"#,a);\r\n  #printf(#[Fields]\"The character is %c\\n\"#,ch);\r\n  #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先在标准输出设备stdout,即显示器屏幕上打印出\"Output a string.\\n\"。\r\n（2）再打印出字符串str中的内容：\"This is a test!\"。\r\n（3）再打印出整型数a：The integer is 1。\r\n（4）再打印出字符ch：The character is r。",
        8,
        127,
        1
      ],
      [
        124,
        "putc：向指定流中输出字符函数",
        "函数原型：int putc(int ch, FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：向指定的文件输出一个字符。该函数有两个参数，ch是用户指定的字符，fp是文件指针。函数将字符ch输出到fp指定的文件中。\r\n返回值：返回输出的字符ch，若出错则返回EOF。\r\n例程如下 应用putc函数向标准输出文件输出字符。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]char #str[] = #[Fields]\"Hello world!\"#;\r\n   #[Keywords]int #i = 0; \r\n   #[Keywords]while #(str[i]){\r\n      #putc(str[i], stdout);\r\n      #i++;\r\n      #}\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先将字符串\"Hello world!\"存入字符串数组str中。\r\n（2）循环地将数组str中的内容输出到标准输出文件（显示器）上。\r\n例程如下 应用putc函数向用户自定义文件输出字符。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *fp;\r\n   #[Keywords]int #i = 0;\r\n   #[Keywords]char #str[]=#[Fields]\"This is a test!\"#;\r\n   #fp=fopen(#[Fields]\"test.txt\"#,#[Fields]\"w\"#);\r\n   #[Keywords]while #(str[i]){\r\n      #putc(str[i], fp);\r\n      #i++;\r\n      #}\r\n    #fclose(fp);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先将字符串\"This is a test!\" 存入字符串数组str中。\r\n（2）以写的方式打开一个名为\"test.txt\"文件，并利用函数putc将数组str中的内容输出到文件\"test.txt\"中。\r\n（3）关闭文件。\r\n注意：该函数既可以向标准输出文件输出字符，又可以向用户自定义文件输出字符。而且，每当向文件输出一个字符时，文件指针就会自动向后移一个字节。",
        8,
        127,
        1
      ],
      [
        125,
        "putchar：向标准输出文件上输出字符",
        "函数原型：int putchar(char ch);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：将字符串ch输出到标准输出文件stdout上。也就是说将字符串ch输出到显示器屏幕上。\r\n返回值：返回输出的字符ch，若出错，则返回EOF。\r\n例程如下 应用putchar函数在屏幕上显示字符。\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]int #main()\r\n{\r\n    #[Keywords]char #str[]=#[Fields]\"This is a test!\\n\"#;\r\n    #[Keywords]int #i=0;\r\n   #[Keywords] while#(str[i]){\r\n        #putchar(str[i]);\r\n        #i++;\r\n    #}\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先将字符串\"This is a test!\\n\"存入字符串数组str中。\r\n（2）应用putchar函数，循环地将字符串输出到标准输出文件（终端屏幕）上。\r\n注意：该函数与putc函数不同，它只能向标准输出文件，也就是终端屏幕上输出字符。而putc函数既可以向标准输出文件上输出字符，又可以向一般用户自定义文件上输出字符。",
        8,
        127,
        1
      ],
      [
        126,
        "puts：将字符串输出到终端函数",
        "函数原型：int puts(char *string);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：将string指向的字符串输出到标准输出设备（stdout），并将'\\0'转换为回车换行符'\\n'。在C语言中，字符串以’\\0’结尾。该函数不仅可以将字符串输出到标准输出设备，而且要将字符串的结束标志转换为回车换行。\r\n返回值：成功则返回换行符，若失败则返回EOF。\r\n例程如下 应用puts函数向终端输出字符串。\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]char #string[] = #[Fields]\"This is a test!\\n\"#;\r\n   #puts(string);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，将字符串\"This is a test!\\n\"存入以string为首地址的缓冲区。\r\n（2）应用puts函数将该字符串显示在标准输出设备上。\r\n注意：该函数将字符串的结尾标志'\\0'转换为回车换行符'\\n'。因此，程序运行的结果为：\r\n[code=java]\r\nThis is a test!\r\n[\/code]",
        8,
        127,
        1
      ],
      [
        127,
        "remove：删除文件函数",
        "函数原型：int remove(char *filename);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：删除以filename为文件名的文件。该函数的参数为欲删除文件的文件名，如果是单纯的文件名，就表明删除当前文件夹下的文件，否则要写明文件的路径。\r\n返回值：成功删除文件返回0，否则返回-1。\r\n例程如下 应用remove函数删除文件。\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n   #[Keywords]if#( remove( #[Fields]\"test.txt\"# ) == -1 )\r\n      #perror( #[Fields]\"Could not delete test.txt!!\"# );\r\n  #[Keywords] else#\r\n      #printf( #[Fields]\"Deleted test.txt \\n\"# );\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先要在当前文件夹下建立文件test.txt。\r\n（2）再利用remove函数删除该文件。若删除成功，则在终端显示字符串\"Deleted test.txt \\n\"，否则显示字符串\"Could not delete test.txt!!: No such file or directory\"。\r\n注意：前面已经讲过perror函数是按照一定格式要求向终端输出错误信息，因此，若删除文件成功，程序运行的结果为：\r\n[code=java]\r\nDeleted test.txt\r\n[\/code]\r\n若删除失败，则程序运行的结果为：\r\n[code=java]\r\nCould not delete test.txt!!: No such file or directory\r\n[\/code]\r\n这里，利用perror函数显示的完整的错误信息包括：用户自定义字符串，冒号，系统报错信息，换行符。",
        8,
        127,
        1
      ],
      [
        128,
        "rename：重命名文件函数",
        "函数原型：int rename(char *oldname, char *newname);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：把由oldname所指的文件名改为由newname所指的文件名。该函数有两个参数，oldname为旧的文件名，newname为欲改成的新文件名。应当注意，oldname所指的文件一定要存在，newname所指的文件一定不存在。应用该函数可将一个文件的旧文件名oldname改为新文件名newname，但不能改变文件的路径。\r\n返回值：成功返回0，出错返回-1。\r\n例程如下 应用rename函数重命名文件。\r\n[code=java]\r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n  #[Keywords]if#( rename(#[Fields]\"oldname.txt\"#,#[Fields]\"newname.txt\"#)==0)\r\n      #printf(#[Fields]\"Rename successful!!\"#);\r\n #[Keywords] else#\r\n      #printf(#[Fields]\"Rename fail!!\"#);\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，在当前文件夹下建立一个文件\"oldname.txt\"。\r\n（2）应用rename函数重命名该文件，将其改名为\"newname.txt\"。若重命名成功，在屏幕上显示\"Rename successful!!\"提示字符串；否则显示\"Rename fail!!\"提示字符串。",
        8,
        127,
        1
      ],
      [
        129,
        "rewind：重置文件指针函数",
        "函数原型：void rewind(FILE *stream);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：将文件指针fp重新定位在文件开头，并清除文件的结束标志和错误标志。该函数与函数fseek功能类似，但不同的是，该函数可以清除文件的结束标志和错误标志，而函数fseek不能；另外，该函数不能像函数fseek一样返回一个值表明操作是否成功，因为该函数无返回值。\r\n返回值：无。\r\n例程如下 应用函数rewind重定位文件指针。\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]void #main( #[Keywords]void #)\r\n{\r\n   #FILE *fp;\r\n   #[Keywords]int #data1, data2;\r\n   #data1 = 1;\r\n   #data2 = 2;\r\n   #[Keywords]if#( (fp = fopen( #[Fields]\"test.txt\"#, #[Fields]\"w+\"# )) != NULL )\r\n   #{\r\n      #fprintf( fp, #[Fields]\"%d %d\"#, data1, data2 );\r\n      #printf( #[Fields]\"The values written are: %d and %d\\n\"#, data1, data2 );\r\n\t  #data1=0;\r\n      #data2=0;\r\n      #rewind( fp );\r\n      #fscanf( fp, #[Fields]\"%d %d\"#, &data1, &data2 );\r\n      #printf( #[Fields]\"The values read are: %d and %d\\n\"#, data1, data2 );\r\n      #fclose( fp );\r\n   #}\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先以写的方式打开一个名为\"test.txt\"的文件。\r\n（2）应用fprintf函数向该文件写入data1，data2两个整型数，其值分别为1，2。此时，文件指针fp已指向文件尾。\r\n（3）在屏幕上显示这两个数。\r\n（4）再将变量data1和data2置0。\r\n（4）应用rewind函数重定位文件指针，将文件指针fp重新定位在文件开头。\r\n（5）再应用fscanf函数向data1，data2两个变量中读入文件中的数字。\r\n（6）在屏幕上显示这两个数。\r\n注意：在应用fprintf函数向该文件写入data1，data2两个整型数后，文件指针fp会自动指向文件尾。只有再应用函数rewind、fseek才能将文件指针重新定位到文件开头，以便读取文件。本例中，将data1和data2置0的目的是为了说明应用fscanf函数向data1，data2两个变量中读入文件中的数字的结果是正确的。本程序的运行结果为：\r\n[code=java]\r\nThe values written are: 1 and 2\r\nThe values read are: 1 and 2\r\n[\/code]",
        8,
        127,
        1
      ],
      [
        130,
        "scanf：格式化输入函数",
        "函数原型：int scanf(char *format[,argument,...]);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：从标准输入设备（键盘）按照format指定的格式字符串所规定的格式，将数据输入到argument所指定的内存单元。scanf函数与printf函数相对，前者是从标准输入设备输入数值，后者是从标准输出设备输出数值。\r\n返回值：成功返回输入的字符个数，否则遇到结束符返回EOF，出错返回0。\r\n例程如下 应用scanf函数输入数据。\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]void #main( #[Keywords]void #)\r\n{\r\n    #[Keywords]int #i;\r\n    #[Keywords]char #ch;\r\n    #[Keywords]float #f;\r\n    #printf(#[Fields]\"Please input an integer:\\n\"#);\r\n    #scanf(#[Fields]\"%d\"#,&i);\r\n    #getchar();\r\n    #printf(#[Fields]\"Please input a character:\\n\"#);\r\n    #scanf(#[Fields]\"%c\"#,&ch);\r\n    #getchar();\r\n    #printf(#[Fields]\"Please input an float:\\n\"#);\r\n    #scanf(#[Fields]\"%f\"#,&f);\r\n    #getchar();\r\n    #printf(#[Fields]\"These values are:%d,%c,%f\"#,i,ch,f);\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）应用scanf函数向预先声明的三个变量空间输入一个整型数、一个字符、一个浮点数。\r\n（2）在屏幕上显示这三个值。\r\n注意：scanf函数与fscanf函数类似，但只能从标准输入设备文件读取数值，而不能像fscanf函数一样从一般用户自定义文件中读取数值。scanf函数常用作程序设计中数据的输入函数。",
        8,
        127,
        1
      ],
      [
        131,
        "setbuf、setvbuf：指定文件流的缓冲区函数",
        "函数原型：void setbuf(FILE *fp, char *buf);\r\n\t\t  void setvbuf(FILE *fp, char *buf, int type, unsigned size);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能： 这两个函数使得打开文件后，用户可以建立自己的文件缓冲区，而不必使用fopen函数打开文件时设定的默认缓冲区。\r\nsetbuf函数的定义中，参数buf指定的缓冲区大小由stdio.h中定义的宏BUFSIZE的值决定，缺省值default为512字节。而当buf为NULL时，setbuf函数将使文件I\/O不带缓冲区。而对setvbuf函数，则由malloc函数来分配缓冲区。参数size指明了缓冲区的长度(必须大于0)，而参数type则表明了缓冲的类型，其取值如下表：\r\nsetvbuf函数中参数type的取值含义\r\n[code=java]\r\ntype 值\t  含义\r\n_IOFBF\t文件全部缓冲，即缓冲区装满后，才能对文件读写\r\n_IOLBF\t文件行缓冲，即缓冲区接收到一个换行符时，才能对文件读写 \r\n_IONBF \t文件不缓冲，此时忽略buf,size的值，直接读写文件，不再经过文件缓冲区缓冲 \r\n[\/code]\r\n返回值：无。\r\n例程如下 应用setbuf函数指定文件的缓冲区。\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]void #main( #[Keywords]void #)\r\n{\r\n   #[Keywords]char #buf[BUFSIZ];\r\n   #FILE *fp1, *fp2;\r\n   #[Keywords]if#( ((fp1 = fopen( #[Fields]\"test1.txt\"#, #[Fields]\"a\"# )) != NULL) &&\r\n       #((fp2 = fopen( #[Fields]\"test2.txt\"#, #[Fields]\"w\"# )) != NULL) )\r\n   #{\r\n      #\/* 应用setbuf函数给文件流fp1指定缓冲区buf *\/\r\n      #setbuf( fp1, buf );\r\n      #\/*显示缓冲区地址*\/\r\n      #printf( #[Fields]\"fp1 set to user-defined buffer at: %Fp\\n\"#, buf );\r\n      #\/* 文件流fp2不指定缓冲区*\/\r\n      #setbuf( fp2, NULL );\r\n      #\/*信息提示不分配缓冲区*\/\r\n      #printf( #[Fields]\"fp2 buffering disabled\\n\"# );\r\n      #fclose(fp1);\r\n      #fclose(fp2);\r\n   #}\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先开辟一个大小为BUFSIZ的缓冲区，用作指定文件的缓冲区。这里，BUFSIZE为stdio.h中定义的宏，缺省值为512字节。\r\n（2）以追加的方式和写的方式打开名为\"test1.txt\"和\"test2.txt\"的文件。\r\n（3）应用setbuf函数给文件流fp1指定缓冲区buf，其中buf为缓冲区的首地址。并在屏幕上显示该首地址。\r\n（4）文件流fp2不指定缓冲区，也就是第二个参数设置为NULL。并信息提示不分配缓冲区。\r\n（5）关闭两个文件。\r\n注意：使用setbuf函数指定文件的缓冲区时，一定要在文件读写之前。一旦用户自己指定了文件的缓冲区，文件的读写就要在用户指定的缓冲区中进行，而不在系统默认指定的缓冲区中进行。函数setvbuf的用法与setbuf类似，只是它的缓冲区大小可以动态分配，由函数的参数指定，而且缓冲区的类型也可以由参数指定。",
        8,
        127,
        1
      ],
      [
        132,
        "sprintf：向字符串写入格式化数据函数",
        "函数原型：int sprintf(char *string, char *farmat [,argument,...]);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：将格式化的数据存储到以string为首地址的缓冲区中。参数argument要被转化为farmat规定的格式，并按照这个规定的格式向字符串数组写入数据。这里应该注意，sprintf函数与printf函数和fprint函数不同，前者是向缓冲区（即数组）写入格式化数据，后者是向标准输出文件（stdout）和用户自定义文件输出格式化数据。\r\n返回值：返回存储在string中数据的字节数。\r\n例程如下 应用sprintf函数向指定缓冲区写入数据。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <math.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]char #str[80];\r\n   #sprintf(str, #[Fields]\"An approximation of Pi is %f\\n\"#, M_PI);\r\n   #puts(str);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先开辟一个80字节大小的缓冲区str，即：该缓冲区以str为首地址。\r\n（2）再将指定的字符串写入缓冲区str中。其中，M_PI是math.h中定义的常量3.141593。\r\n（3）应用puts函数向终端输出该字符串。\r\n注意：puts函数的作用是把str指定的字符串输出到标准输出设备，并且将字符串结束标志'\/0'转换为回车换行符。因此，该程序运行的结果是：\r\n[code=java]\r\nAn approximation of Pi is 3.141593\r\n[\/code]\r\n除了规定字符串中的换行符外，程序还将'\/0'转换为换行符。",
        8,
        127,
        1
      ],
      [
        133,
        "sscanf：从缓冲区中读格式化字符串函数",
        "函数原型：int sscanf(char *string, char *format[,argument,...]);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：将string指定的数据读到argument所指定的位置。其中，参数argument是与format格式要求相符合的变量指针。也就是说，如果format指定的格式为\"%d\"，则argument就必须是整型变量的指针。这里应该注意，sscanf函数与scanf函数和fscanf函数不同，前者是从指定的缓冲区读格式化数据到新的缓冲区中，而后者是从标准输入文件（stdin）和用户自定义文件中读取格式化数据到缓冲区中。\r\n返回值：成功返回已分配空间的数量，返回0表示没用空间分配，返回EOF表示出错。\r\n例程如下 应用sscanf函数读取格式化数据。\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]void #main( #[Keywords]void #)\r\n{\r\n   #[Keywords]char # str[] = #[Fields]\"1 2 3...\"#;\r\n   #[Keywords]char # s[81];\r\n   #[Keywords]char # c;\r\n   #[Keywords]int #  i;\r\n   #[Keywords]float #fp;\r\n   #\/* 从缓冲区str中读取数据 *\/\r\n   #sscanf( str, #[Fields]\"%s\"#, s );\r\n   #sscanf( str, #[Fields]\"%c\"#, &c );\r\n   #sscanf( str, #[Fields]\"%d\"#, &i );\r\n   #sscanf( str, #[Fields]\"%f\"#, &fp );\r\n   #\/* 输出已读取的数据 *\/\r\n   #printf( #[Fields]\"String    = %s\\n\"#, s );\r\n   #printf( #[Fields]\"Character = %c\\n\"#, c );\r\n   #printf( #[Fields]\"Integer:  = %d\\n\"#, i );\r\n   #printf( #[Fields]\"Real:     = %f\\n\"#, fp );\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先开辟一个以str为首地址的缓冲区，并初始化其内容。\r\n（2）应用sscanf函数从缓冲区str中读取数据。分别以格式要求\"%s\"、\"%c\"、\"%d\"、\"%f\"读取，并存入相应的变量中。\r\n（3）输出已读取的数据。",
        8,
        127,
        1
      ],
      [
        134,
        "tmpfile：创建临时文件函数",
        "函数原型：FILE *tmpfile(void);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：创建一个临时文件。该文件以w+b（二进制读写）方式打开，当该文件被关闭时，该文件会被自动删除。\r\n返回值：返回指向临时文件的指针，如果文件打不开则返回EOF。\r\n例程如下 创建一个临时文件。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <process.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #FILE *tempfp;\r\n   #tempfp = tmpfile();\r\n   #[Keywords]if #(tempfp) \r\n      #printf(#[Fields]\"Temporary file be created!!\\n\"#);\r\n   #[Keywords]else #\r\n   #{\r\n      #printf(#[Fields]\"Unable to create the temporary file!!\\n\"#);\r\n      #exit(1);\r\n   #} \r\n    #sleep(20);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先应用tmpfile函数创建一个临时文件，并将文件指针赋值给FILE型变量tempfp。\r\n（2）如果创建临时文件成功，则在终端显示提示：Temporary file be created!!\r\n（3）如果创建不成功，则显示提示：Unable to create the temporary file!!\r\n（4）程序挂起20秒。\r\n注意：这里将程序挂起20秒的目的是为了让用户看到生成的临时文件。这是因为当程序执行完时，系统会自动删除临时文件，那样用户就感觉不到临时文件的创建了。当该程序运行时，会在当前文件夹下生成一个临时文件。\r\n临时文件的作用是暂时存储程序运行过程中需要的数据，当程序运行完毕时，这些数据也就没有用了。",
        8,
        127,
        1
      ],
      [
        135,
        "tmpnam：创建临时文件名函数",
        "函数原型：char *tmpnam(char *string);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：创建一个临时文件名，用以打开一个临时文件。\r\n返回值：创建成功返回指向该文件名的指针，否则返回NULL。\r\n例程如下\r\n[code=java]\r\n#include <string.h>\r\n#include <stdio.h>\r\nmain()\r\n{\r\n    #[Keywords]char #tmp[10];\r\n    #tmpnam(tmp);\r\n    #printf(#[Fields]\"The temporary name is %s\\n\"#,name);\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先定义一个字符型数组tmp。\r\n（2）调用tmpnam函数生成一个临时文件名。\r\n（3）打印出该临时文件名。\r\n注意：应用函数tmpnam生成的临时文件名是不同于任何已存在文件名的有效文件名。本函数用于给临时文件创建文件名。",
        8,
        127,
        1
      ],
      [
        136,
        "ungetc：把字符退回到输入流函数",
        "函数原型：int ungetc(char c, FILE *fp);\r\n头文件：#include<stdio.h>\r\n是否是标准函数：是\r\n函数功能：把字符c退回到fp所指向的文件流中，并清除文件的结束标志。fp所指向的文件既可以是用户自定义的文件，又可以是系统定义的标准文件。\r\n返回值：成功返回字符c，否则返回EOF。\r\n例程如下 应用ungetc函数向标准输入文件退回字符。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <ctype.h> \r\n#[Keywords]int #main( #[Keywords]void #) \r\n{ \r\n   #[Keywords]int #i=0; \r\n   #[Keywords]char #ch; \r\n   #puts(#[Fields]\"Input an integer followed by a char:\"#);\r\n   #\/* 读取字符直到输入非数字或EOF *\/\r\n  #[Keywords] while#((ch = getchar()) != EOF && isdigit(ch)) \r\n      #i = 10 * i + ch - 48; \/* 将ASCII码转换为整数值*\/\r\n   #\/* 如果输入非数字，将其退回输入流 *\/\r\n   #[Keywords]if #(ch != EOF) \r\n      #ungetc(ch, stdin);\r\n   #printf(#[Fields]\"i = %d, next #[Keywords]char #in buffer = %c\\n\"#, i, getchar());\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先从终端输入一串字符串，要求输入整型数字，并以非数字字符结尾。\r\n（2）程序读取字符，直到输入非数字或EOF为止，并将数字字符串转换为整型数。例如：将字符串\"123\"转换为整型数123。\r\n（3）再将结尾的非数字字符退回到标准输入文件（stdin）。\r\n（4）显示退回到标准输入文件中的字符。\r\n注意：所谓将结尾的非数字字符退回到标准输入文件，就是说将数字字符串后面的那个非数字字符退回到标准输入文件中去。例如：输入的字符串为\"123abc\"，那么退回的字符就是a。这样，程序将前面的字符串\"123\"转换为整型数123，并存入变量i中。a作为数字字符串输入的结束标志（因为 a是继数字字符之后的第一个非数字字符），被退回到标准输入文件（stdin）。于是，再调用getchar函数读取的字符就应该是刚刚退回到标准输入文件中的字符a。因此，本段例程的执行结果为：\r\n[code=java]\r\nInput an integer followed by a char:\r\n123abc\r\ni = 123, next char in buffer = a\r\n[\/code]\r\n即：输入的字符串中123 为整型数，接下来的字符为a。",
        8,
        127,
        1
      ],
      [
        200,
        "字符处理函数",
        "",
        9,
        128,
        1
      ],
      [
        201,
        "isalnum：检查字符是否是字母或数字",
        "函数原型：int isalnum( int c );\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：检查字符c 是否是字母（alpha）或数字（number）。\r\n返回值：是字母或数字返回1，否则返回0。\r\n例程如下： 应用isalnum检查字符属性。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h> \r\n#[Keywords]int #main( #[Keywords]void #) \r\n{ \r\n   #[Keywords]char #c,ch;\r\n   #scanf(#[Fields]\"%c\"#,&c);\r\n   #ch=getchar();\r\n  #[Keywords] while#(c!=#[Fields]'e'#) {\r\n        #[Keywords]if#(isalnum(c))\r\n            #printf(#[Fields]\"This is a alpha or a number\\n\"#);\r\n       #[Keywords] else#\r\n            #printf(#[Fields]\"This is a particulate character\\n\"#);\r\n        #scanf(#[Fields]\"%c\"#,&c);\r\n        #ch=getchar();\r\n   #}\r\n   #[Keywords]return #1;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了两个字符型变量，用以接收来自终端的字符。\r\n（2）当用户输入的字符不是'e'且是字母或数字字符时，就在屏幕上显示\"This is a alpha or a number\"提示信息。当用户输入的字符不是'e'且不是字母或数字字符时，就在屏幕上显示\"This is a particulate character\"提示信息。\r\n（3）当用户输入字符'e'时，程序退出。\r\n注意：本例程中，scanf函数用以接收欲判断的字符，getchar函数用以接收回车换行符。本例程的运行结果为：\r\n[code=java]\r\na\r\nThis is a alpha or a number\r\n2\r\nThis is a alpha or a number\r\n#\r\nThis is a particulate character\r\ne\r\n[\/code]",
        8,
        128,
        1
      ],
      [
        202,
        "isalpha：检查字符是否是字母",
        "函数原型：int isalpha( int c );\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：检查字符c 是否是字母（alpha）。\r\n返回值：是字母返回1，否则返回0。\r\n例程如下：应用isalpha检查字符属性。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h> \r\n#[Keywords]int #main( #[Keywords]void #) \r\n{ \r\n   #[Keywords]char #c,ch;\r\n   #scanf(#[Fields]\"%c\"#,&c);\r\n   #ch=getchar();\r\n  #[Keywords] while#(c!=#[Fields]'e'#) {\r\n        #[Keywords]if#(isalpha (c))\r\n            #printf(#[Fields]\"This is a alpha \\n\"#);\r\n       #[Keywords] else#\r\n            #printf(#[Fields]\"This is not a alpha\\n\"#);\r\n        #scanf(#[Fields]\"%c\"#,&c);\r\n        #ch=getchar();\r\n   #}\r\n   #[Keywords]return #1;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n本例程但只判断输入的字符是否是字母，如果是字母，则在屏幕上显示\"This is a alpha \"提示信息，否则显示\"This is not a alpha\"提示信息。\r\n本例程的运行结果为：\r\n[code=java]\r\na\r\nThis is a alpha\r\n3\r\nThis is not a alpha\r\n$\r\nThis is not a alpha\r\ne\r\n[\/code]",
        8,
        128,
        1
      ],
      [
        203,
        "isascii：检查字符是否是ASCII码",
        "函数原型：int isascii(int c);\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：检查字符c 是否是ASCII码，所谓ASCII码是指0x00~0x7F之间的字符。\r\n返回值：是ASCII码返回1，否则返回0。\r\n例程如下：应用isascii检查字符属性。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#[Keywords]int #main(void)\r\n{\r\n    #[Keywords]int #c;\r\n    #c=#[Fields]'A'#;\r\n    #printf(#[Fields]\"%c:%s\\n\"#,c,isascii(c)?#[Fields]\"yes\"#:#[Fields]\"no\"#);\r\n    #c=0x7f;\r\n    #printf(#[Fields]\"%c:%s\\n\"#,c,isascii(c)?#[Fields]\"yes\"#:#[Fields]\"no\"#);\r\n    #c=0x80;\r\n    #printf(#[Fields]\"%c:%s\\n\"#,c,isascii(c)?#[Fields]\"yes\"#:#[Fields]\"no\"#);\r\n    #getchar();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n本例程应用isascii函数判断字符'A'、0x7f、0x80是否是ASCII码，如果是，显示\"yes\",不是则显示\"no\"。本例程的运行结果是：\r\n[code=java]\r\nA:yes\r\n?:yes\r\n?:no\r\n[\/code]\r\n注意：所谓ASCII码是指0x00~0x7F之间的字符，本例程中十六进制数0x7f的字符显示为?，属于ASCII码，因此显示yes；0x80的字符显示为?，不属于ASCII码，因此显示no。",
        8,
        128,
        1
      ],
      [
        204,
        "iscntrl：检查字符是否是控制字符",
        "函数原型：int iscntrl( int c );\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：检查字符c 是否是控制字符，控制字符的ASCII码在0到0x1F之间。\r\n返回值：是控制字符返回1，否则返回0。\r\n例程如下：应用iscntrl检查字符属性。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h> \r\n#[Keywords]int #main(void)\r\n{\r\n    #[Keywords]char #c,ch;\r\n    #printf(#[Fields]\"Input some character until contrl character\\n\"#);\r\n    #scanf(#[Fields]\"%c\"#,&c);\r\n    #ch=getchar();\r\n   #[Keywords] while#(!iscntrl(c)){\r\n        #scanf(#[Fields]\"%c\"#,&c);\r\n        #ch=getchar();\r\n    #};\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n输入的字符不是控制字符时，可以一直输入下去，一旦输入了控制字符，程序结束。\r\n注意：每输入一个字符时，要以回车结束。\r\n本例程的运行结果为：\r\n[code=java]\r\na\r\nb\r\n[\/code]",
        8,
        128,
        1
      ],
      [
        205,
        "isdigit：检查字符是否是数字字符",
        "函数原型：int isdigit( int c );\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：检查字符c 是否是数字字符（0~9）。\r\n返回值：是数字字符返回1，否则返回0。\r\n例程如下：应用isdigit函数统计字符串中数字个数。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h> \r\n#[Keywords]int #main(void)\r\n{\r\n    #[Keywords]char #ch;\r\n    #[Keywords]int #i=0;\r\n    #ch=getchar();\r\n   #[Keywords] while#(ch!=EOF){\r\n        #[Keywords]if#(isdigit(ch))i++;\r\n        #ch=getchar();\r\n    #}\r\n    #printf(#[Fields]\"%d\"#,i);\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序中设置字符型变量ch用以接收输入的字符，设置整型变量i，并初始化i=0，用以统计输入的字符串中数字的个数。\r\n（2）当输入的字符不是EOF时，程序循环执行，并应用isdigit函数判断用户输入的字符是否是数字字符，如果是则在变量i上加1。\r\n（3）最后显示输入的字符串中数字个数。\r\n注意：利用Ctrl+Z组合键输入的字符就是EOF。\r\n本例程的运行结果为：\r\n[code=java]\r\nabc123def567ghi^Z\r\n6\r\n[\/code]",
        8,
        128,
        1
      ],
      [
        206,
        "isgraph：检查字符是否是可打印字符（不含空格）",
        "函数原型：int isgraph(int c);\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：检查字符c是否是除了空格符外的可打印字符，其ASCII码在0x21-0x7e之间。\r\n返回值：是除了空格符外的可打印字符返回1，否则返回0。\r\n例程如下： 应用isgraph函数判断可打印字符。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#[Keywords]int #main(void)\r\n{\r\n    #[Keywords]int #c;\r\n    #c=#[Fields]'A'#;\r\n    #printf(#[Fields]\"%c:%s\\n\"#,c,isgraph(c)?#[Fields]\"yes\"#:#[Fields]\"no\"#);\r\n    #c=#[Fields]' '#;\r\n    #printf(#[Fields]\"%c:%s\\n\"#,c,isgraph(c)?#[Fields]\"yes\"#:#[Fields]\"no\"#);\r\n    #c=0x7f;\r\n    #printf(#[Fields]\"%c:%s\\n\"#,c,isgraph(c)?#[Fields]\"yes\"#:#[Fields]\"no\"#);\r\n    #getchar();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n本例程应用isgraph函数判断字符'A'、''、0x7f是否是除了空格符外的可打印字符。如果是，显示\"yes\",不是则显示\"no\"。本例程的运行结果是：\r\n[code=java]\r\nA:yes\r\n :no\r\n?:no\r\n[\/code]",
        8,
        128,
        1
      ],
      [
        207,
        "islower：检查字符是否是小写字母",
        "函数原型：int islower(int c);\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：检查字符c是否是小写字母（a~z）。\r\n返回值：当c为小写字母时，返回1，否则返回0。\r\n例程如下： 应用islower函数统计字符串中的小写字母个数。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h> \r\n#[Keywords]int #main(void)\r\n{\r\n    #[Keywords]char #ch;\r\n    #[Keywords]int #i=0;\r\n    #ch=getchar();\r\n   #[Keywords] while#(ch!=EOF){\r\n        #[Keywords]if#(islower(ch))i++;\r\n        #ch=getchar();\r\n    #}\r\n    #printf(#[Fields]\"%d\"#,i);\r\n    #getchar();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n本例程先输入一串任意的字符，然后应用islower函数统计字符串中的小写字母个数。最后，在屏幕上显示出小写字母的个数。本例程的运行结果是：\r\n[code=java]\r\ndjcvGGJH4623^Z\r\n4\r\n[\/code]\r\n注意：^Z是Ctrl+Z组合键的屏幕显示，即结束标志EOF。",
        8,
        128,
        1
      ],
      [
        208,
        "isprint：检查字符是否是可打印字符（含空格）",
        "函数原型：int isprint(int c);\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：检查字符c是否为可打印字符（含空格），其ASCII码在0x20-0x7e之间。\r\n返回值：是可打印字符返回1，否则返回0。\r\n例程如下：应用isprint函数判断可打印字符。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#[Keywords]int #main(void)\r\n{\r\n    #[Keywords]int #c;\r\n    #c=#[Fields]'A'#;\r\n    #printf(#[Fields]\"%c:%s\\n\"#,c,isprint(c)?#[Fields]\"yes\"#:#[Fields]\"no\"#);\r\n    #c=#[Fields]' '#;\r\n    #printf(#[Fields]\"%c:%s\\n\"#,c,isprint(c)?#[Fields]\"yes\"#:#[Fields]\"no\"#);\r\n    #c=0x7f;\r\n    #printf(#[Fields]\"%c:%s\\n\"#,c,isprint(c)?#[Fields]\"yes\"#:#[Fields]\"no\"#);\r\n    #getchar();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n本例程与例程11-6相似，应用isprint函数判断字符'A'、' '、0x7f是否是可打印字符（包括空格）。如果是，显示\"yes\",不是则显示\"no\"。本例程的运行结果是：\r\n[code=java]\r\nA:yes\r\n :yes\r\n?:no\r\n[\/code]",
        8,
        128,
        1
      ],
      [
        209,
        "ispunct：检查字符是否是标点字符",
        "函数原型：int ispunct(int c);\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：检查字符c是否是除字母、数字、空格之外的可打印字符，也就是检查字符c是否是标点字符。\r\n返回值：当c为标点符号时，返回1，否则返回0。\r\n例程如下： 应用ispunct函数判断标点字符。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <string.h>\r\n#[Keywords]int #main(void)\r\n{\r\n    #[Keywords]char #s[]=#[Fields]\"He said:Oh!Very well!\"#;\r\n    #[Keywords]int #i;\r\n    #printf(#[Fields]\"%s\\n\"#,s);\r\n    #[Keywords]for#(i=0;i<strlen(s);i++)\r\n    #{\r\n         #[Keywords]if#(ispunct(s[i])) printf(#[Fields]\"^\"#);\r\n         #[Keywords]else #printf(#[Fields]\".\"#);\r\n    #}\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，将字符串\"He said:Oh!Very well!\"存入以s为首地址的缓冲区中，并在屏幕上显示该字符串。\r\n（2）循环检查该字符串中的每个字符，并在屏幕上显示的该字符串下方作出标记，即：如果不是标点字符，打印\".\"，如果是标点字符，打印\"^\"。本例程的运行结果是：\r\n[code=java]\r\nHe said:Oh!Very well!\r\n[\/code]",
        8,
        128,
        1
      ],
      [
        210,
        "isspace：检查字符是否是空格符",
        "函数原型：int isspace(int c);\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：检查字符c是否为空格符space、制表符tab或是换行符。空格符space的ASCII码为32，制表符tab的ASCII码为9，换行符的ASCII码则为\r\n返回值：当c为空格符或制表符时，返回1，否则返回0。\r\n例程如下： 应用isspace函数转换空格符、制表符和换行符。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#[Keywords]int #main(void)\r\n{\r\n    #[Keywords]char #s[]=#[Fields]\"space |NewLine\\n|table\\t|\"#;\r\n    #[Keywords]int #i;\r\n    #printf(#[Fields]\"%s\"#,s);\r\n    #printf(#[Fields]\"\\n\"#);\r\n    #[Keywords]for#(i=0;i<strlen(s);i++)\r\n    #{\r\n        #[Keywords]if#(isspace(s[i])) putchar(#[Fields]'.'#);\r\n        #[Keywords]else #putchar(s[i]);\r\n    #}\r\n    #getchar();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，将字符串\"space |NewLine\\n|table\\t|\"存入以s为首地址的缓冲区中，并在屏幕上显示该字符串。其中，' '、'\\n'、'\\t'分别为空格符、换行符、制表符，在屏幕上显示其字符原样。\r\n（2）再通过isspace函数检测出该字符串中的这些空格符、换行符、制表符，将其转换为'.'字符，并输出到终端屏幕。\r\n注意：本例程并没有改变原字符串数组中的存储内容，只是在输出时将字符串中的空格符、换行符、制表符转换为'.'字符并输出到终端屏幕。本例程的运行结果是：\r\n[code=java]\r\nspace |NewLine\r\n|table  |\r\nspace.|NewLine.|table.|\r\n[\/code]",
        8,
        128,
        1
      ],
      [
        211,
        "isupper：检查字符是否是大写字母",
        "函数原型：int isupper(int c);\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：检查字符c是否是大写字母（A~Z）。\r\n返回值：当c为大写字母时，返回1，否则返回0。\r\n例程如下： 应用isupper函数统计字符串中的小写字母个数。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h> \r\n#[Keywords]int #main(void)\r\n{\r\n    #[Keywords]char #ch;\r\n    #[Keywords]int #i=0;\r\n    #ch=getchar();\r\n   #[Keywords] while#(ch!=EOF){\r\n        #[Keywords]if#(isupper(ch))i++;\r\n        #ch=getchar();\r\n    #}\r\n    #printf(#[Fields]\"%d\"#,i);\r\n    #getchar();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n本例程利用函数isupper统计输入的字符串中大写字母的个数。最后，在屏幕上显示出小写字母的个数。本例程的运行结果是：\r\n[code=java]\r\nABCDEabcFG123^Z\r\n7\r\n[\/code]",
        8,
        128,
        1
      ],
      [
        212,
        "isxdigit：检查字符是否是十六进制数字字符",
        "函数原型： int isxdigit(int c);\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：检查字符c是否为十六进制数字。\r\n返回值：当c为A-F,a-f或0-9之间的十六进制数字时，返回非零值，否则返回0。\r\n例程如下：应用isxdigit函数检查字符属性。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#[Keywords]int #main(void)\r\n{\r\n     #[Keywords]char #c;\r\n     #c=#[Fields]'f'#;\r\n     #printf(#[Fields]\"%c:%s\\n\"#,c,isxdigit(c)?#[Fields]\"yes\"#:#[Fields]\"no\"#);\r\n     #c=#[Fields]'1'#;\r\n     #printf(#[Fields]\"%c:%s\\n\"#,c,isxdigit(c)?#[Fields]\"yes\"#:#[Fields]\"no\"#);\r\n     #c=#[Fields]'$'#;\r\n     #printf(#[Fields]\"%c:%s\\n\"#,c,isxdigit(c)?#[Fields]\"yes\"#:#[Fields]\"no\"#);\r\n     #getchar();\r\n     #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n本例程应用isxdigit函数判断字符'f'、'1'、'$'是否是十六进制数字，如果是，显示\"yes\",不是则显示\"no\"。本例程的运行结果是：\r\n[code=java]\r\nf:yes\r\n1:yes\r\n$:no\r\n[\/code]",
        8,
        128,
        1
      ],
      [
        213,
        "toascii：将字符转换为ASCII码",
        "函数原型：int toascii(int c);\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：将c转化为相应的ASCII码。\r\n返回值：返回转换后的数值，也就是转换后的ASCII码。\r\n例程如下： 应用toascii函数将整型数字转换为相应的ASCII码。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h>\r\nmain()\r\n{\r\n    #[Keywords]int #s[]={1,2,3,4,5,6#};\r\n    #[Keywords]int #i;\r\n    #[Keywords]for#(i=0;i<6;i++)\r\n        #{\r\n            #printf(#[Fields]\"%d\"#,s[i]);\r\n        #}\r\n    #printf(#[Fields]\"\\n\"#);\r\n    #[Keywords]for#(i=0;i<6;i++)\r\n        #{\r\n            #putchar(toascii(s[i]));\r\n        #}\r\n    #getchar();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，在整型数组中存入1~6六个整型数字，并将其显示在终端屏幕上。\r\n（2）循环地将数组中的每个数字转换为其对应的ASCII码，并将其以字符的形式显示在终端屏幕上。本例程的运行结果为：\r\n[code=java]\r\n1 2 3 4 5 6\r\n??? ? ? ?\r\n[\/code]",
        8,
        128,
        1
      ],
      [
        214,
        "tolower：将大写字母转换为小写字母",
        "函数原型：int tolower(int c);\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：将c转化为相应的小写字母。\r\n返回值：如果c为大写英文字母，则返回对应的小写字母；否则返回原来的值。\r\n例程如下： 应用tolower函数将大写字母转换为小写字母。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#[Keywords]int #main(void)\r\n{\r\n    #[Keywords]char #str[]=#[Fields]\"This Is A Test!\"#;\r\n    #[Keywords]int #i;\r\n    #printf(#[Fields]\"%s\\n\"#,str);\r\n    #[Keywords]for#(i=0;i<strlen(str);i++)\r\n    #{\r\n        #putchar(tolower(str[i]));\r\n    #}\r\n    #getchar();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，将字符串\"This Is A Test!\"存入以str为首地址的缓冲区中，并将该字符串显示在终端屏幕上。\r\n（2）应用\"This Is A Test!\"函数将该字符串中大写字母转换为小写字母，并输出。本\r\n注意：本例程将字符串中大写字母转换为小写字母并输出，但并不改变原数组中的内容，只是在输出时将大写字母转换为小写字母，而本身是小写字母的字符或非字母字符，则返回原值。本例程的运行结果是：\r\n[code=java]\r\nThis Is A Test!\r\nthis is a test!\r\n[\/code]",
        8,
        128,
        1
      ],
      [
        215,
        "toupper：将小写字母转换为大写字母",
        "函数原型：int toupper(int c);\r\n头文件：#include<ctype.h>\r\n是否是标准函数：是\r\n函数功能：将c转化为相应的大写字母。\r\n返回值：如果c为小写英文字母，则返回对应的大写字母；否则返回原来的值。\r\n例程如下： 应用toupper函数将小写字母转换为大写字母。\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#[Keywords]int #main(void)\r\n{\r\n    #[Keywords]char #str[]=#[Fields]\"This Is A Test!\"#;\r\n    #[Keywords]int #i;\r\n    #printf(#[Fields]\"%s\\n\"#,str);\r\n    #[Keywords]for#(i=0;i<strlen(str);i++)\r\n    #{\r\n        #putchar(toupper(str[i]));\r\n    #}\r\n    #getchar();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n本例程利用toupper函数将字符串中的小写字母转换为大写字母，并输出到终端。本例程的运行结果为：\r\n[code=java]\r\nThis Is A Test!\r\nTHIS IS A TEST!\r\n[\/code]",
        8,
        128,
        1
      ],
      [
        300,
        "字符串函数",
        "",
        9,
        129,
        1
      ],
      [
        301,
        "atof：字符串转浮点型函数",
        "函数原型：float atof(const char *str);\r\n头文件：#include<stdlib.h>\r\n是否是标准函数：是\r\n函数功能：将字符串转换成浮点值，也就是将字符串str转换成浮点值然后获取转换后的结果。\r\n返回值：返回转换后的浮点值\r\n例程如下： 应用atol将字符串转换成浮点值。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]char #*str=#[Fields]\"12345.67\"#;\r\n   #[Keywords]float #result;\r\n   #result=atof(str);\r\n   #printf(#[Fields]\"string=%s\\n#[Keywords]float #=%f\\n\"#,str,result);\r\n   #getch();\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符串作为待转换的字符串，声明的浮点型变量result用于获取转换结果。\r\n（2）程序通过调用atol将字符串转换为相应的浮点型变量，获取转换结果，转换规则与strtoX函数相同。\r\n（3）最后将转换结果打印出来。\r\n本例程的运行结果是：\r\n[code=java]\r\nstring =12345.67\r\nfloat=12345.669922\r\n[\/code]\r\n注意：本例程中，转换成浮点数的结果有些奇怪，它并不等于我们字符串中变量的值，而是存在一定的误差，虽然误差很小，但是可以看出误差是从原字符串中的最后一位开始的，这是由于在转换过程中函数内部在实现时采用的转换方式造成的，如果想避免这种误差，可以使用strtoX系列函数。",
        8,
        129,
        1
      ],
      [
        302,
        "atoi：字符串转整型函数",
        "函数原型：int atoi(const char *str);\r\n头文件：#include<stdlib.h>\r\n是否是标准函数：是\r\n函数功能：将字符串转换成整数值，也就是将字符串str转换成整型值然后获取转换后的结果。\r\n返回值：返回转换后的整型值\r\n例程如下： 应用atoi将字符串转换成整型值。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]char #*str=#[Fields]\"12345.67\"#;\r\n   #[Keywords]int #result;\r\n   #result=atoi(str);\r\n   #printf(#[Fields]\"string=%s\\ninteger=%d\\n\"#,str,result);\r\n   #getch();\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符串作为待转换的字符串，声明的整型变量result用于获取转换结果。\r\n（2）程序通过调用atoi将字符串转换为相应的整型变量，获取转换结果，转换规则与strtoX函数相同。\r\n（3）最后将转换结果打印出来。\r\n本例程的运行结果是：\r\n[code=java]\r\nstring =12345.67\r\ninteger=12345\r\n[\/code]",
        8,
        129,
        1
      ],
      [
        303,
        "atol：字符串转长整型函数",
        "函数原型：long atol(const char *str);\r\n头文件：#include<stdlib.h>\r\n是否是标准函数：是\r\n函数功能：将字符串转换成长整数值，也就是将字符串str转换成长整型值然后获取转换后的结果。\r\n返回值：返回转换后的长整型值\r\n例程如下： 应用atol将字符串转换成长整型值。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]char #*str=#[Fields]\"12345.67\"#;\r\n   #[Keywords]long #result;\r\n   #result=atol(str);\r\n   #printf(#[Fields]\"string=%s\\n#[Keywords]long #=%ld\\n\"#,str,result);\r\n   #getch();\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符串作为待转换的字符串，声明的长整型变量result用于获取转换结果。\r\n（2）程序通过调用atol将字符串转换为相应的长整型变量，获取转换结果，转换规则与strtoX函数相同。\r\n（3）最后将转换结果打印出来。\r\n本例程的运行结果是：\r\n[code=java]\r\nstring =12345.67\r\nlong=12345 \r\n[\/code]",
        8,
        129,
        1
      ],
      [
        304,
        "memchr：字符搜索函数",
        "函数原型：void *memchr(void *s, char ch, unsigned n)\r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：在数组的前n个字节中搜索字符 ch。\r\n返回值：返回一个指针，它指向ch在s 中第一次出现的位置。如果在s的前n个字符中找不到匹配，返回NULL。\r\n例程12.31应用函数memchr搜索一个字符串的子串。\r\n[code=java]\r\n#include <string.h> \r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]char #*str=#[Fields]\"I love China\\n\"#;\r\n   #[Keywords]char #*p;\r\n   #p=memchr(str,#[Fields]'C'#,strlen(str));\r\n   #[Keywords]if#(p)\r\n         #printf(#[Fields]\"%s\"#,p);\r\n  #[Keywords] else#\r\n        #printf(#[Fields]\"The character was not found\\n\"#) ;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先初始化字符串“I love China\\n”，将首地址赋值给str。\r\n（2）在字符串str中查找字符’C’出现的位置，并返回以第一个字符’C’开头的字符子串的指针。\r\n（3）如果返回值不为NULL，打印该子串。\r\n本例程的运行结果为：\r\n[code=java]\r\nChina\r\n[\/code]",
        8,
        129,
        1
      ],
      [
        305,
        "memcmp：字符串比较函数",
        "函数原型：void *memcmp(char *s1, char *s2, unsigned n)\r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：比较s1所指向的字符串与s2所指向的字符串的前n个字符。\r\n返回值：根据s1所指向的对象的大于、等于、小于s2所指向的对象，函数memcmp分别返回大于、等于、小于0的值。\r\n例程如下：比较两个字符串。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h> \r\n#[Keywords]int #main(void) \r\n{\r\n    #[Keywords]char #*str1=#[Fields]\"ABCDEF\"#;\r\n    #[Keywords]char #*str2=#[Fields]\"ABCDEf\"#;\r\n    #[Keywords]int #s1,s2;\r\n    #s1=memcmp(str1,str2,6);\r\n    #s2=memcmp(str1,str2,5);\r\n    #printf(#[Fields]\"The comparison of 6 character\\n\"#);\r\n    #[Keywords]if#(s1>0)printf(#[Fields]\"%s>%s\\n\"#,str1,str2);\r\n   #[Keywords] else#\r\n        #[Keywords]if#(s1<0)printf(#[Fields]\"%s<%s\\n\"#,str1,str2);\r\n   #[Keywords] else#\r\n         #printf(#[Fields]\"%s=%s\\n\"#,str1,str2);\r\n    #printf(#[Fields]\"The comparison of 5 character\\n\"#);\r\n    #[Keywords]if#(s2>0)printf(#[Fields]\"%s>%s\\n\"#,str1,str2);\r\n   #[Keywords] else#\r\n        #[Keywords]if#(s2<0)printf(#[Fields]\"%s<%s\\n\"#,str1,str2);\r\n   #[Keywords] else#\r\n         #printf(#[Fields]\"%s=%s\\n\"#,str1,str2);\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先初始化两个字符串“ABCDEF”和“ABCDEf”。\r\n（2）然后应用函数memcmp将这两个字符串按照不同的字符个数进行比较，将返回的比较结果复制给变量s1和s2。\r\n（3）显示比较结果。\r\n本例程的运行结果为：\r\n[code=java]\r\nThe comparison of 6 character\r\nABCDEF<ABCDEf\r\nThe comparison of 5 character\r\nABCDEF=ABCDEf\r\n[\/code]\r\n注意：\r\n由于字符串比较的方法是从左至右按照字符的ASCII码进行比较的，因此在比较6个字符时，字符串“ABCDEF”<“ABCDEf”（f的ASCII值大于F的ASCII值）；而只比较5个字符时，字符串“ABCDEF”=“ABCDEf”。",
        8,
        129,
        1
      ],
      [
        306,
        "memcpy： 字符串拷贝函数",
        "函数原型：void *memcpy(void *destin, void *source, unsigned n)\r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：从source所指的对象中复制n个字符到destin所指的对象中。但是，如果这种复制发生在重叠对象之间，其行为是不可预知的。\r\n返回值：destin\r\n例程如下：利用函数memcpy进行字符串拷贝。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]char #*s = #[Fields]\"#####\"#;\r\n   #[Keywords]char #*d = #[Fields]\"This is a test #[Keywords]for #memcpy function\"#;\r\n   #[Keywords]char #*ptr; \r\n   #printf(#[Fields]\"destination before memcpy: %s\\n\"#, d);\r\n   #ptr = memcpy(d, s, strlen(s));\r\n   #[Keywords]if #(ptr) \r\n      #printf(#[Fields]\"destination after memcpy: %s\\n\"#, d);\r\n   #[Keywords]else #\r\n      #printf(#[Fields]\"memcpy failed\\n\"#);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先定义两个字符串s和d，并赋初值，且d的长度大于s。\r\n（2）显示字符串d的原始内容。\r\n（3）通过函数memcpy将字符串s复制到字符串d中，并返回字符串d的首指针。\r\n（4）如果拷贝成功，再次显示字符串d的内容。\r\n本例程的运行结果为：\r\n[code=java]\r\ndestination before memcpy: This is a test for memcpy function\r\ndestination after memcpy:  ##########test for memcpy function\r\n[\/code]\r\n注意：\r\n1、memcpy与strcpy的不同在于应用memcpy进行字符串的拷贝可以指定拷贝串的长度。另外memcpy的参数为void指针类型，因此它还可以对非字符型对象进行操作，而strcpy只适用于字符串的拷贝。\r\n2、前面提到，如果复制过程中发生在重叠对象之间，其行为是不可预知的。例如下面这个例子：\r\n[code=java]\r\n#include <string.h> \r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n  #[Keywords]char #*d = #[Fields]\"1234567890\"#;\r\n  #[Keywords]char #*p;\r\n  #p=d+3;\r\n  #printf(#[Fields]\" %s\\n\"#, d);\r\n  #memcpy(p, d, 6);\r\n  #printf(#[Fields]\" %s\\n\"#, d);\r\n  #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n由于字符串p是字符串d的一个子串，在调用memcpy时，复制的字符串在d和p之间又重叠，因此该复制行为是不可预知的，结果也自然难以保证。这段程序的运行结果为：\r\n[code=java]\r\n1234567890\r\n1231231230\r\n[\/code]\r\n显然这不是期望得到的结果。",
        8,
        129,
        1
      ],
      [
        307,
        "memmove： 字块移动函数",
        "函数原型：void *memmove(void *destin, void *source, unsigned n)\r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：从source所指的对象中复制n个字符到destin所指的对象中。与memcpy不同的是，当对象重叠时，该函数仍能正确执行。\r\n返回值：destin\r\n例程如下：利用函数memmove进行字符块的移动\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]char #*s = #[Fields]\"#####\"#;\r\n   #[Keywords]char #*d = #[Fields]\"This is a test #[Keywords]for #memcpy function\"#;\r\n   #[Keywords]char #*ptr; \r\n   #printf(#[Fields]\"destination before memmove: %s\\n\"#, d);\r\n   #ptr = memmove(d, s, strlen(s));\r\n   #[Keywords]if #(ptr) \r\n      #printf(#[Fields]\"destination after memmove:  %s\\n\"#, d);\r\n   #[Keywords]else #\r\n      #printf(#[Fields]\"memcpy failed\\n\"#);\r\n   #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先定义两个字符串s和d，并赋初值，且d的长度大于s。\r\n（2）显示字符串d的原始内容。\r\n（3）通过函数memmove将字符串s复制到字符串d中，并返回字符串d的首指针。\r\n（4）如果拷贝成功，再次显示字符串d的内容。\r\n本例程的运行结果为：\r\n[code=java]\r\ndestination before memmove: This is a test for memcpy function\r\ndestination after memmove:  ##########test for memcpy function\r\n[\/code]\r\n注意：\r\n与函数memcpy不同的是，当对象重叠时，该函数仍能正确执行。例如下面这个例子：\r\n[code=java]\r\n#include <string.h> \r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n  #[Keywords]char #*d = #[Fields]\"1234567890\"#;\r\n  #[Keywords]char #*p;\r\n  #p=d+3;\r\n  #printf(#[Fields]\" %s\\n\"#, d);\r\n  #memmove(p, d, 6);\r\n  #printf(#[Fields]\" %s\\n\"#, d);\r\n  #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n虽然复制的字符串在d和p之间又重叠，但本段程序的运行结果为：\r\n[code=java]\r\n1234567890\r\n1231234560\r\n[\/code]\r\n显然这是期望得到的结果。\r\n这是因为函数memmove的复制行为类似于先从source对象中复制n个字符到一个与source和destin都不重合的含n个字符的临时数组中作为缓冲，然后从临时数组中再复制n个字符destin所指的对象中。\r\n就本段程序而言，memmove先将字符串“123456”复制到一个临时数组中，再将它复制到以p为首地址的字符串中。",
        8,
        129,
        1
      ],
      [
        308,
        "memset：字符加载函数",
        "函数原型：void *memset(void *s, int c, unsigned n)\r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：把c复制到s所指向的对象的前n个字符的每一个字符中。\r\n返回值：s的值\r\n例程如下：应用memset函数替换字符串中的字符。\r\n[code=java]\r\n#include <string.h> \r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]char #*str=#[Fields]\"AAAAAAAAAAAAAAAAAA\"#;\r\n   #printf(#[Fields]\"The original string is:    %s\\n\"#,str);\r\n   #memset(str,#[Fields]'B'#,9);\r\n   #printf(#[Fields]\"The string after memset is:%s\\n\"#,str);\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先初始化字符串“AAAAAAAAAAAAAAAAAA”， 将首地址赋值给str。\r\n（2）显示该字符串。\r\n（3）利用函数memset将字符串str的前9个字符替换为’B’。\r\n（4）显示替换后的字符串。\r\n本例程的运行结果为：\r\n[code=java]\r\nThe original string is:    AAAAAAAAAAAAAAAAAA\r\nThe string after memset is:BBBBBBBBBAAAAAAAAA\r\n[\/code]",
        8,
        129,
        1
      ],
      [
        309,
        "strcat：字符串连接函数",
        "函数原型：char *strcat (char *dest,char *src);\r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：将两个字符串连接合并成一个字符串，也就是把字符串src连接到字符串dest后面，连接后的结果放在字符串dest中\r\n返回值：指向字符串dest的指针\r\n例程如下： \r\n应用strcat连接字符串。\r\n[code=java]\r\n#include <string.h> \r\n#include <stdio.h> \r\n#[Keywords]int #main( ) \r\n{ \r\n \t#[Keywords]char #dest[20]={“ ”#}; \r\n    #[Keywords]char #*hello = #[Fields]\"hello \"#, *space = #[Fields]\" \"#, *world = #[Fields]\"world\"#;\r\n \t#strcat(dest, hello);\r\n   \t#strcat(dest, space);\r\n    #strcat(dest, world);\r\n   \t#printf(#[Fields]\"%s\\n\"#, destination);\r\n    #getch();\r\n   \t#[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符数组和三个字符串变量，将字符数组dest初始化位空串，其余三个字符串变量分别赋予初值。\r\n（2）程序通过调用strcat函数实现字符串的连接，首先将字符串hello添加到字符数组dest的末端，此时字符数组dest的值有空串变为\"hello\"，然后继续调用两次strcat函数，依次将字符串space和字符串world陆续连接到字符数组dest的末端，从而完成整个字符串的连接操作。\r\n（3）最后将最终的结果输出。\r\n本例程的运行结果是：\r\n[code=java]\r\nhello world\r\n[\/code]\r\n注意：本例程中，开始对字符数组dest初始化位空是必要的，对声明的变量进行初始化是一个很好的习惯，如果不对字符数组dest进行初始化程序会产生运行时的错误，有兴趣的读者可以试试未初始化程序的输出结果。",
        8,
        129,
        1
      ],
      [
        310,
        "strchr：字符串中字符首次匹配函数",
        "函数原型：char *strchr(char *str, char c); \r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：在字符串中查找给定字符的第一次匹配，也就是在字符串str中查找字符c第一次出现的位置\r\n返回值：第一次匹配位置的指针\r\n例程如下： 应用strchr匹配字符串中字符。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h> \r\n#[Keywords]int #main(void) \r\n{\r\n    #[Keywords]char #str[15] ={#[Fields]\"\"##};\r\n    #[Keywords]char #*ptr, c = #[Fields]'r'#; \r\n    #strcpy(str, #[Fields]\"Hello World\"#);\r\n    #ptr = strchr(str, c);\r\n    #[Keywords]if #(ptr) \r\n       #printf(#[Fields]\"The character %c is at position: %d\\n\"#, c, ptr-str);\r\n    #[Keywords]else #\r\n       #printf(#[Fields]\"The character was not found\\n\"#);\r\n    #strcpy(str, #[Fields]\"Aloha\"#);\r\n    #[Keywords]if #(ptr) \r\n       #printf(#[Fields]\"The character %c is at position: %d\\n\"#, c, ptr-str);\r\n    #[Keywords]else #\r\n       #printf(#[Fields]\"The character was not found\\n\"#);\r\n    #getch();\r\n    #[Keywords]return #0; \r\n#} \r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符串和一个字符数组以及一个字符，并对字符变量赋予了我们要查找的值。\r\n（2）程序通过调用strcpy 赋予了字符数组一个值，然后调用strchr函数在字符数组中查找第一次与字符变量c匹配的字符，也就是查找第一个'r' 字符，返回的结果为指向第一个匹配字符的指针。根据返回值输出匹配结果。\r\n（3）程序第二次通过调用strcpy 赋予了字符数组一个值，然后调用strchr函数在字符数组中查找第一次与字符变量c匹配的字符，也就是查找第一个'r' 字符，最后根据返回值输出匹配结果。\r\n（4）第二次匹配已经给字符串重新赋值，我们理解新的字符串似乎应该是\"Aloha\"，从而没有与'r'匹配的字符，但实际的运行结果却令人大吃一惊。这时因为在重新赋值时\"Aloha\"虽然将\"Hello\"覆盖掉，但是后面的字符仍然在数组中保留，因此在做匹配的时候仍然得到与第一次匹配相同的结果。\r\n（5）对结果进行输出时，如果匹配成功，那么我们输出匹配的字符在数组中的位置，如果匹配不成功，则显示没有找到。\r\n本例程的运行结果是：\r\n[code=java]\r\nThe character r is at position 8\r\nThe character r is at position 8\r\n[\/code]\r\n注意：本例程中，对字符串中字符匹配的返回值是指向匹配位置的指针，我们获取到该指针后，与数组的头指针做减法，也就是与数组变量名做减法，就可以获得我们得到的指针在数组中对应的下标。",
        0,
        129,
        1
      ],
      [
        311,
        "strcmp：字符串比较函数",
        "函数原型：int strcmp (char *str1,char * str2);\r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：比较两个字符串的大小，也就是把字符串str1和字符串str2从首字符开始逐字符的进行比较，直到某个字符不相同或比较到最后一个字符为止，字符的比较为ASIC码的比较\r\n返回值：若字符串str1大于字符串str2返回结果大于零，若字符串str1小于字符串str2返回结果小于零，若字符串str1等于字符串str2返回结果等于零\r\n例程如下： 应用strcmp比较字符串大小。\r\n[code=java]\r\n#include <string.h> \r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #*str1 = #[Fields]\"Canada\"#, *str2 = #[Fields]\"China\"#, *str3 = #[Fields]\"china\"#;\r\n    #[Keywords]int #result;\r\n    #result = strcmp(str1, str2);\r\n    #[Keywords]if #(result < 0)\r\n        #printf(#[Fields]\"%s is less than %s\"#, str1,str2);\r\n    #[Keywords]else #\r\n        #printf(#[Fields]\"%s is not less than %s\"#, str1,str2);\r\n    #printf(#[Fields]\"\\n\"#);\r\n    #result = strcmp(str2, str3);\r\n    #[Keywords]if #(result < 0)\r\n        #printf(#[Fields]\"%s is less than %s\"#, str2,str3);\r\n    #[Keywords]else #\r\n        #printf(#[Fields]\"%s is not less than %s\"#, str2,str3);\r\n    #getch();\r\n    #[Keywords]return #0; \r\n#}\r\n\/code\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了三个字符串变量并分别赋予了初值，注意字符串str2和字符串str3的区别在于首字母是否大写，整型变量result用于记录字符串的比较结果。\r\n（2）程序通过调用strcmp函数比较字符串str1和字符串str2，在首字符相同的情况下第二个字符' a'的ASIC码小于' h'的ASIC码，因此比较结果为字符串str1小于字符串str2，返回结果小于零。第二次调用strcmp函数比较字符串str2和字符串str3，由于在ASIC码表中小写字母在后，小写字母的ASIC码大于大写字母，即' C'小于' c'，因此比较结果为字符串str2小于字符串str3，返回结果小于零。\r\n（3）最后将最终的结果输出，为了使输出结果一目了然，在两次比较中间的printf函数输出了一个换行。\r\n本例程的运行结果是：\r\n[code=java]\r\nCanada is less than China\r\nChina is less than china\r\n[\/code]\r\n注意：本例程中，字符串的比较结果为首个两个不等字符之间ASIC码的差值，如果我们将第一次比较的结果result输出，应该是' a'的ASIC与码与' h'的ASIC码的差值，有兴趣的读者可以试试输出结果。",
        0,
        129,
        1
      ],
      [
        312,
        "strcpy：字符串拷贝函数",
        "函数原型： char * strcpy (char *dest,char * src);\r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：实现字符串的拷贝工作，也就是把字符串src中的内容拷贝到字符串dest中，使两个字符串的内容相同。\r\n返回值：指向字符串dest的指针\r\n例程如下： 应用strcpy实现字符串拷贝。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #dest[20] ={#[Fields]\"\"##};\r\n    #[Keywords]char #*src = #[Fields]\"Hello World\"#;\r\n    #[Keywords]int #result;\r\n    #strcpy(dest,src);\r\n    #printf(#[Fields]\"%s\\n\"#, dest);\r\n    #result=strcmp(dest,src);\r\n    #[Keywords]if#(!result)\r\n        #printf(#[Fields]\"dest is equal to src\"#);\r\n    #[Keywords] else#\r\n        #printf(#[Fields]\"dest is not equal to src\"#);\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#}\r\n\/code\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符串和一个字符数组并给分别赋予了初值，整型变量result用于记录字符串子串的比较结果。\r\n（2）程序通过调用strcpy函数将字符串src中的内容拷贝到字符数组dest中，使得两者具有相同的内容。为了验证两个变量中的内容是否真的一样，通过调用strcmp对两个字符串中的内容进行比较。\r\n（3）最后将拷贝结果和比较结果输出。\r\n本例程的运行结果是：\r\n[code=java]\r\nHello World\r\ndest is equal to src \r\n[\/code]\r\n注意：本例程中，向字符数组中赋值时要保证字符数组中有足够的空间，虽然有时候即便空间不够也会打印出正确的结果，但随着程序的运行，不能保证超出下标范围的部分还能以正确的型式存在。",
        0,
        129,
        1
      ],
      [
        313,
        "strcspn：字符集逆匹配函数",
        "函数原型：int strcspn(char *str1, char *str2); \r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：在字符串中查找第一个属于字符集的下标，即从开始有多少个字符不属于字符集，也就是在字符串str1中查找第一个属于字符集str2中任何一个字符的下标，即字符串str1中从开始一直有多少个字符不属于字符集str2中的字符。\r\n返回值：所找到的字符串中段的长度\r\n例程如下： 应用strspn逆匹配字符串中字符集。\r\n[code=java]\r\n#include <string.h>\r\n#include <stdio.h>\r\n#[Keywords]int #main(void)\r\n{\r\n    #[Keywords]char #*str1=#[Fields]\"tomato\"#,*str2=#[Fields]\"carrot\"#;\r\n    #[Keywords]char #*str= #[Fields]\"abc\"#;\r\n    #[Keywords]int # result;\r\n    #result = strcspn(str1,str);\r\n    #[Keywords]if#(result)\r\n        #printf(#[Fields]\"The first %d is congruent\\n\"#,result);\r\n   #[Keywords] else#\r\n        #printf(#[Fields]\"No character is congruent\\n\"#);\r\n    #result = strcspn(str2,str);\r\n    #[Keywords]if#(result)\r\n        #printf(#[Fields]\"The first %d is congruent\\n\"#,result);\r\n   #[Keywords] else#\r\n        #printf(#[Fields]\"No character is congruent\\n\"#);\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了三个字符串并分别赋予初值，其中最后一个变量是用于逆匹配的字符集。\r\n（2）程序通过调用strcspn进行字符集的逆匹配，它从字符串str1中的第一个字符开始检查是不是属于字符串str中的任意字符，如果不属于就继续逆匹配，直到逆匹配不成功，本例中会发现直到遇到字符'a'才逆匹配失败，因为字符'a'属于字符串str中的某个字符。然后输出匹配结果。\r\n（3）程序第二次通过调用strspn对字符串str2进行字符集逆匹配，发现第一个字符即属于字符集str中的某字符。\r\n（4）输出匹配结果是显示前多少个字符逆匹配成功。\r\n本例程的运行结果是：\r\n[code=java]\r\nThe first 3 is congruent\r\nNo character is congruent\r\n[\/code]\r\n注意：本例程中，字符集逆匹配与字符集匹配两者的匹配方式截然相反，字符串匹配是当字符串中字符等于字符集中任意字符是匹配成功，字符串逆匹配是当字符串中字符不等于字符集中任意字符是匹配成功。",
        0,
        129,
        1
      ],
      [
        314,
        "strdup：字符串新建拷贝函数",
        "函数原型：char *strdup(char *str); \r\n头文件：#include<stdlib.h>\r\n是否是标准函数：是\r\n函数功能：将字符串拷贝到新分配的空间位置，也就是将str拷贝到一块新分配的存储空间，其内部使用动态分配内存技术实现的，分配给字符串的空间来自于当前所用内存模式制定的堆。\r\n返回值：返回指向含有该串拷贝的存储区\r\n例程如下： 应用strdup将字符串拷贝到新建位置处。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h>\r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #*src=#[Fields]\"This is the buffer text\"#;\r\n    #[Keywords]char #*dest;\r\n    #dest=strdup(src);\r\n    #[Keywords]if#(!strcmp(src,dest))\r\n        #printf(#[Fields]\"Copy success\\n%s\\n\"#,dest);\r\n   #[Keywords] else#\r\n        #printf(#[Fields]\"Copy failure\"#);\r\n    #free(dest);\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#} \r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了两个字符串并给第一个字符串赋于初值，此时并未给字符串dest分配任何空间。\r\n（2）程序通过调用strdup将字符串拷贝到新建位置处，通过动态分配内存技术将新分配一个与字符串src大小相同的存储区并完成字符串的复制工作，然后返回该存储区并让dest指向该区域。\r\n（3）程序通过调用strcmp比较复制前后的字符串，如果复制成功而这应当相同，函数返回值为零，并打印拷贝结果。\r\n（4）由于新分配的存储区是通过动态分配内存技术实现的，因此在程序退出之前要将分配的存储区显示的释放。\r\n本例程的运行结果是：\r\n[code=java]\r\nCopy success\r\nThis is the buffer text\r\n[\/code]\r\n注意：本例程中，初学者往往会忽视释放动态分配存储区的操作，虽然表面看起来似乎对程序没有什么影响，但实际上不对存储区进行回收会造成内存泄漏，在一些大程序会造成致命的后果。",
        0,
        129,
        1
      ],
      [
        315,
        "strerror：字符串错误信息函数",
        "函数原型：char *strerror(int errnum);\r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：获取程序出现错误的字符串信息，也就是根据错误代码errnum查找到具体的错误信息。\r\n返回值：返回错误信息\r\n例程如下： 应用strerror查看几种错误信息。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <errno.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #*error;\r\n    #[Keywords]int #i;\r\n    #[Keywords]for#(i=0;i<12;i++)\r\n    #{\r\n        #error=strerror(i);\r\n        #printf(#[Fields]\"%s\"#,error);\r\n    #}\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符串用于获取错误信息，声明的整型变量既作为循环变量又作为错误信息代码。\r\n（2）程序通过调用strerror根据错误代码获取到具体的错误信息，其中这些代表具体错误信息的字符串在相应的头文件中定义。循环只取了前十二种错误信息，实际的错误种类还有更多。\r\n（3）每次循环将具体错误信息打印出来。\r\n本例程的运行结果是：\r\n[code=java]\r\nError 0\r\nInvalid function number\r\nNo such file or directory\r\nPath not found\r\nToo many open files\r\nPermission denied\r\nBad file number\r\nMemory arena trashed\r\nNot enough memory\r\nInvalid memory block address\r\nInvalid environment\r\nInvalid format \r\n[\/code]\r\n注意：本例程中，如果读者有兴趣，不妨看看一共系统定义了多少种错误信息，通过更改循环变量将各种错误信息打印出来。",
        0,
        129,
        1
      ],
      [
        316,
        "strlen：计算字符串长度函数",
        "函数原型： int strlrn (char *str); \r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：求字符串的长度，也就是求字符串str中有多少个字符\r\n返回值：字符串str字符的个数\r\n例程如下： 应用strlen求字符串长度。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #src1[3]={#[Fields]\"\"##},src2[10]={#[Fields]\"Hello\"##};\r\n    #[Keywords]char #*src3=#[Fields]\"Hello\"#;\r\n    #printf(#[Fields]\"%d\\n\"#,strlen(src1));\r\n    #printf(#[Fields]\"%d\\n\"#,strlen(src2));\r\n    #printf(#[Fields]\"%d\\n\"#,strlen(src3));\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符串和两个字符数组并给分别赋予了初值，我们将字符串src3与字符数组src2赋予相同的初值。\r\n（2）程序通过调用strlen函数分别求出三个变量字符的长度。在求字符长度时，返回的结果是有效字符的个数，因此虽然字符数组src1由十个字符变量组成，但初值为空串，因此长度为零，并不等于数组长度。由于字符串src3与字符数组src2赋予相同的初值，因此两者长度相同。\r\n（3）最后将字符串或字符数组的长度值输出。\r\n本例程的运行结果是：\r\n[code=java]\r\n0\r\n5\r\n5\r\n[\/code]\r\n注意：本例程中，如果将字符数组src2拷贝到字符数组src1中，并不会产生任何编译错误，但是程序运行时会产生不可预知的结果，有兴趣的读者可以试试完成拷贝后将三个变量的长度输出。",
        0,
        129,
        1
      ],
      [
        317,
        "strlwr：字符串小写转换函数",
        "函数原型：char *strlwr(char *str,);\r\n头文件：#include<string.h>\r\n是否是标准函数：否\r\n函数功能：将字符串原有大写字符全部转换为小写字符，也就是将字符串str中的所有字符变成小写。\r\n返回值：返回指向被转换字符串的指针\r\n例程如下： 应用strlwr将字符串转换成小写字符。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h>\r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #*s=#[Fields]\"You#[Fields]'ll Never Walk Alone\"#;\r\n    #printf(#[Fields]\"%s\"#,strlwr(s));\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符串为待转换字符串并赋予初值。\r\n（2）程序通过调用strlwr将字符串中的所有大写字符转换成小写字符，并返回转换后的结果。\r\n（3）最后将转换结果打印出来。\r\n本例程的运行结果是：\r\n[code=java]\r\nyou'll never walk alone \r\n[\/code]",
        0,
        129,
        1
      ],
      [
        318,
        "strncat：字符串连接函数",
        "函数原型：char *strncat (char *dest, char *src, int n);\r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：将一个字符串的子串连接到另一个字符串末端，也就是把字符串src的前n个字符连接到字符串dest后面，连接后的结果放在字符串dest中\r\n返回值：指向字符串dest的指针\r\n例程如下：应用strncat连接字符串子串。\r\n[code=java]\r\n#include <string.h> \r\n#include <string.h> \r\n#include <stdio.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #dest[30]={#[Fields]\"\"##};\r\n    #[Keywords]char #*favorite = #[Fields]\"I love\"#, *tabs = #[Fields]\"\\t\\n\"#, *language = #[Fields]\"C++\"#;\r\n    #strcnat(dest, favorite,6);\r\n    #strncat(dest, tabs,1);\r\n    #strncat(dest, language,1);\r\n    #printf(#[Fields]\"%s\\n\"#, dest);\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符数组和三个字符串变量，将字符数组dest初始化位空串，其余三个字符串变量分别赋予初值，其中字符串tans由两个字符组成，一个制表符和一个换行符。\r\n（2）程序通过调用strncat函数实现字符串子串的连接，首先将字符串favorite的前六个字符添加到字符数组dest的末端，其效果与直接调用strcat函数相同，然后继续调用两次strncat函数，依次将字符串tabs和字符串language的首字符陆续连接到字符数组dest的末端，从而完成整个字符串子串的连接操作。\r\n（3）最后将最终的结果输出，由于未将字符串tabs中的换行符添加到字符数组dest中，因此所有输出结果应在同一行。\r\n本例程的运行结果是：\r\n[code=java]\r\nI love\tC\r\n[\/code]\r\n注意：本例程中，字符串tabs中的内容比较新奇，它并不是我们一般的字符，而是两个转义说明符构成的特殊字符，C语言内部在处理过程中遇到转义说明符时会作特殊处理，本例中会将' \\t'看做制表符，将' \\n'看做换行符。",
        0,
        129,
        1
      ],
      [
        319,
        "strncmp：字符串子串比较函数",
        "函数原型： int strncmp (char *str1,char * str2, int n);\r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：比较两个字符串子串的大小，也就是把字符串str1的前n个字符组成的子串和字符串str2的前n个字符组成的子串进行比较，从首字符开始逐字符的进行比较，直到某个字符不相同或比较到第n个字符为止。\r\n返回值：若字符串str1前n个字符组成的子串大于字符串str2前n个字符组成的子串返回结果大于零，若字符串str1前n个字符组成的子串小于字符串str2前n个字符组成的子串返回结果小于零，若字符串str1前n个字符组成的子串等于字符串str2前n个字符组成的子串返回结果等于零\r\n例程如下： 应用strncmp比较字符串子串大小。\r\n[code=java]\r\n#include <string.h>\r\n#include <string.h>\r\n#[Keywords]int #main(void)\r\n{\r\n    #[Keywords]char #*str1=#[Fields]\"Hello World\"#;\r\n    #[Keywords]char #*str2=#[Fields]\"Hello C Programme\"#;\r\n    #[Keywords]int #result;\r\n    #result=strncmp(str1,str2,5);\r\n    #[Keywords]if#(!result)\r\n        #printf(#[Fields]\"%s is identical to %s in the first 5 words\"#,str1,str2);\r\n    #[Keywords]else #[Keywords]if#(result<0)\r\n        #printf(#[Fields]\"%s is less than %s in the first 5 words\"#,str1,str2);\r\n   #[Keywords] else#\r\n        #printf(#[Fields]\"%s is great than %s in the first 5 words\"#,str1,str2);\r\n    #printf(#[Fields]\"\\n\"#);\r\n    #result=strncmp(str1,str2,10);\r\n     #[Keywords]if#(!result)\r\n        #printf(#[Fields]\"%s is identical to %s in the first 10 words\"#,str1,str2);\r\n    #[Keywords]else #[Keywords]if#(result<0)\r\n        #printf(#[Fields]\"%s is less than %s in the first 10 words\"#,str1,str2);\r\n   #[Keywords] else#\r\n        #printf(#[Fields]\"%s is great than %s in the first 10 words\"#,str1,str2);\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了两个字符串变量并分别赋予了初值，整型变量result用于记录字符串子串的比较结果。\r\n（2）程序通过调用strncmp函数比较字符串str1和字符串str2的前5个字符组成的子串，由于两个字符串的前五个字符相同，因此两个子串的比较结果应为相等，返回结果为零。然后将比较结果输出。\r\n（3）程序第二次调用strncmp函数比较字符串str2和字符串str3的前10个字符组成的子串，由于从第七个字符开始出现不等的情况，分别为' w'和' C'，根据ASIC码表中小写字母在后，即' w'的ASIC码大，返回结果大于零。最后输出比较结果。\r\n（4）输出时显示的输出比较结果并指明比较范围。\r\n本例程的运行结果是：\r\n[code=java]\r\nHello World is identical to Hello C Programme in the first 5 words\r\nHello World is great than Hello C Programme in the first 10 words\r\n[\/code]\r\n注意：本例程中，要注意子串比较的过程中子串的大小应不小于零且不超过字符串的长度，虽然子串的长短参数不会产生编译时的错误和最终结果的输出，但在比较前检查比较范围是一个很好的习惯。",
        0,
        129,
        1
      ],
      [
        320,
        "strncpy：字符串子串拷贝函数",
        "函数原型： char * strncpy (char *dest,char * src, int n);\r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：实现字符串子串的拷贝工作，也就是把字符串src中的前n个字符拷贝到字符串dest中。\r\n返回值：指向字符串dest的指针\r\n例程如下： 应用strncpy实现字符串子串拷贝。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #dest[20]={#[Fields]\"\"##};\r\n    #[Keywords]char #*src1=#[Fields]\"Hello World\"#,*src2 =#[Fields]\"Aloha\"#;\r\n    #strncpy(dest,src1,5);\r\n    #strncpy(dest,src2,5);\r\n    #[Keywords]if#(!strcmp(dest,src1))\r\n        #printf(#[Fields]\"dest is equal to src1\"#);\r\n    #[Keywords]else #[Keywords]if#(!strcmp(dest,src2))\r\n        #printf(#[Fields]\"dest is equal to src2\"#);\r\n   #[Keywords] else#\r\n        #printf(#[Fields]\"dest is %s\"#,dest);\r\n    #printf(#[Fields]\"%s\\n\"#, dest);\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了两个字符串和一个字符数组并分别赋予了初值，本例中省去了用于记录比较结果result变量。\r\n（2）程序通过调用strncpy函数将字符串src1中的前五个字符组成的子串拷贝到字符数组dest中，然后又将调用strncpy函数将字符串src2中的前五个字符组成的子串拷贝到字符数组dest中。通过调用一系列的strcmp字符串比较函数，从而达到验证dest变量中的最终内容的目的。\r\n（3）最终的字符串dest中内容的到底是什么呢，是\"Hello\"，还是\"Aloha\"，亦或是\" HelloAloha\"。通过第一次调用strncpy函数，字符串dest中的内容由空串变成\"Hello\"，再次调用strncpy函数则会从字符串dest的下标为零处逐一覆盖，也就是\"Aloha\"覆盖了原来的\" Hello \"，并不是将\"Aloha\"添加到末端。\r\n（4）最后将拷贝结果和验证结果输出。\r\n本例程的运行结果是：\r\n[code=java]\r\nAloha\r\ndest is equal to src2 \r\n[\/code]\r\n注意：本例程中，在检验字符串dest的内容时，if判断中并没有使用像上例中的result变量，我们只关心比较的结果是否为零，直接通过将函数作为判断条件，从而利用函数的返回值进行判断是一个简单而有效的方法。",
        0,
        129,
        1
      ],
      [
        321,
        "strpbrk：字符集字符匹配函数",
        "函数原型：char *strpbrk(char *str1, char *str2); \r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：在字符串中查找第一个属于字符集的字符位置，也就是在字符串str1中查找第一个属于字符集str2中任意字符的位置。\r\n返回值：返回第一个匹配字符的指针\r\n例程如下： 应用strpbrk匹配字符集字符。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #*str1=#[Fields]\"There are 5 pigs in the hogpen\"#;\r\n    #[Keywords]char #*str2=#[Fields]\"0123456789\"#;\r\n    #[Keywords]char #*result;\r\n    #result = strpbrk(str1,str2);\r\n    #[Keywords]if#(result)\r\n        #printf(#[Fields]\"%s\\n\"#,result++);\r\n   #[Keywords] else#\r\n        #printf(#[Fields]\"There are no numbers any more\"#);\r\n    #result = strpbrk(result,str2);\r\n    #[Keywords]if#(result)\r\n        #printf(#[Fields]\"%s\\n\"#,result++);\r\n   #[Keywords] else#\r\n        #printf(#[Fields]\"There are no numbers any more\"#);\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了三个字符串变量并给前两个变量赋予初值，其中字符指针result用于记录匹配字符的位置。\r\n（2）程序通过调用strcspn进行字符集字符的匹配，它从字符串str1中查找第一个属于字符集str2中任意字符的字符，具体到本例中就是在字符串str1种查找第一个数字字符，如果匹配成功我们会获得指向第一个数字字符的指针，利用该返回值输出匹配结果。\r\n（3）然后我们在上一次匹配字符的下一个字符作为首字符的子串中继续匹配，程序第二次通过调用strspn完成上述功能，并用同样的输出方式输出匹配结果，如没有数字字符可以获得显示匹配失败。\r\n（4）输出匹配结果时我们并没有将匹配的字符输出，取而代之的是将以匹配字符作为第一个字符的字符串字串输出。\r\n本例程的运行结果是：\r\n[code=java]\r\n5 pigs in the hogpen\r\nThere are no numbers any more\r\n[\/code]\r\n注意：本例程中，值得注意的是匹配成功时结果的输出。由于获得了匹配成功的字符的指针，因此我们可以利用该指针输出字符串的字串，利用自增操作符我们移动一个位置又可以对尚未匹配的子串继续进行下一次匹配。",
        0,
        129,
        1
      ],
      [
        322,
        "strrchr：字符串中字符末次匹配函数",
        "函数原型：char *strrchr(char *str, char c); \r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：在字符串中查找给定字符的最后一次匹配，也就是在字符串str中查找字符c最后一次出现的位置\r\n返回值：最后一次匹配位置的指针\r\n例程如下： 应用strrchr匹配字符串中字符。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h> \r\n#[Keywords]int #main(void) \r\n{\r\n    #[Keywords]char #str[15]={#[Fields]\"\"##};\r\n    #[Keywords]char #*ptr, c = #[Fields]'o'#;\r\n    #strcpy(str, #[Fields]\"Hello World\"#);\r\n    #ptr = strchr(str, c);\r\n    #[Keywords]if #(ptr) \r\n       #printf(#[Fields]\"The first character %c is at position: %d\\n\"#, c, ptr-str);\r\n    #[Keywords]else #\r\n       #printf(#[Fields]\"The character was not found\\n\"#);\r\n    #ptr = strrchr(str, c);\r\n    #[Keywords]if #(ptr) \r\n       #printf(#[Fields]\"The last character %c is at position: %d\\n\"#, c, ptr-str);\r\n    #[Keywords]else #\r\n       #printf(#[Fields]\"The character was not found\\n\"#);\r\n    #getch();\r\n    #[Keywords]return #0; \r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符串和一个字符数组以及一个字符，并对字符变量赋予了我们要查找的值。\r\n（2）程序通过调用strcpy 赋予了字符数组一个值，然后调用strchr函数在字符数组中查找第一次与字符变量c匹配的字符，也就是查找最后一个'o' 字符，返回的结果为指向第一个匹配字符的指针。根据返回值输出匹配结果。\r\n（3）然后程序调用strrchr函数在字符数组中查找最后一次与字符变量c匹配的字符，也就是查找最后一个'o' 字符，最后根据返回值输出匹配结果。\r\n（4）在字符数组中有两个'o'字符，因此调用strchr函数应该返回第一个'o'字符的指针，调用strrchr函数应该返回最后一个'o'字符的指针。\r\n（5）对结果进行输出时，如果匹配成功，那么我们输出匹配的字符在数组中的位置，如果匹配不成功，则显示没有找到。\r\n本例程的运行结果是：\r\n[code=java]\r\nThe first character r is at position 4\r\nThe last character r is at position 7\r\n[\/code]\r\n注意：本例程中，如果字符串中只有一个'o'字符，那么无论调用哪种字符串中字符匹配函数都会返回相同的结果。",
        0,
        129,
        1
      ],
      [
        323,
        "strrev：字符串倒转函数",
        "函数原型：char *strrev(char *str);\r\n头文件：#include<string.h>\r\n是否是标准函数：否\r\n函数功能：将字符串进行倒转，也就是将字符串str中的第一个字符与最后一个字符交换，第二个字符与倒数第二个字符交换，以此类推。\r\n返回值：返回倒转后字符串的指针\r\n例程如下： 应用strrev将字符串倒转。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h>\r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #*str = #[Fields]\"Able was I ere I saw Elba\"#;\r\n    #printf(#[Fields]\"Before: %s\\n\"#,str);\r\n    #strrev(str);\r\n    #printf(#[Fields]\"After: %s\\n\"#,str);\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符数组并赋予初值，应该注意到字符数组的初值很有意思，类似于回文。\r\n（2）程序通过调用strrev将原字符串中的所有内容倒转，第一个字符与最后一个字符交换，第二个字符与倒数第二个字符交换，以此类推。\r\n（3）最后将倒转前后字符串的值打印出来。\r\n本例程的运行结果是：\r\n[code=java]\r\nAble was I ere I saw Elba \r\nablE was I ere I saw elbA \r\n[\/code]\r\n注意：本例程中，字符数组中的初值并不是严格意义上的回文，将它倒转后会发现与原字符串并不是完全一样。",
        0,
        129,
        1
      ],
      [
        324,
        "strset：字符串设定函数",
        "函数原型：char *strset(char *str, char c);\r\n头文件：#include<string.h>\r\n是否是标准函数：否\r\n函数功能：将字符串原有字符全部设定为指定字符，也就是将字符串str中的所有字符全部用字符c进行替换.\r\n返回值：返回指向被替换字符串的指针\r\n例程如下： 应用strset将字符串设定为指定字符。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h>\r\n#[Keywords]int #main(void) \r\n{ \r\n   #[Keywords]char #str[11]=#[Fields]\"0123456789\"#;\r\n   #[Keywords]char #symbol=#[Fields]'a'#;\r\n   #printf(#[Fields]\"Before: %s\\n\"#,str);\r\n   #strset(str,symbol);\r\n   #printf(#[Fields]\"After: %s\\n\"#,str);\r\n   #getch();\r\n   #[Keywords]return #0; \r\n#} \r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符数组和一个字符变量并赋予初值，字符变量代表用于替换的字符。\r\n（2）程序通过调用strset将原字符串中的所有内容用字符'a'替换，相当于覆盖了原值并重新设定了字符串的值。\r\n（3）最后将设定前后字符串的值打印出来。\r\n本例程的运行结果是：\r\n[code=java]\r\n0123456789\r\naaaaaaaaaa\r\n[\/code]\r\n注意：本例程中，字符数组中指存储了十个字符，但是下表确是十一，利用字符串的相关知识可以理解该问题，有兴趣的读者可以将下表改成十或在字符串赋值的时候多加一个字符，看看程序会输出什么。",
        0,
        129,
        1
      ],
      [
        325,
        "strspn：字符集匹配函数",
        "函数原型：int strspn(char *str1, char *str2); \r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：在字符串中查找第一个不属于字符集的下标，即从开始有多少个字符属于字符集，也就是在字符串str1中查找第一个不属于字符集str2中任何一个字符的下标，即字符串str1中从开始一直有多少个字符属于字符集str2中的字符。\r\n返回值：所找到的字符串中段的长度\r\n例程如下： 应用strspn匹配字符串中字符集。\r\n[code=java]\r\n#include <string.h>\r\n#include <stdio.h>\r\n#[Keywords]int #main(void)\r\n{\r\n    #[Keywords]char #*str1=#[Fields]\"cabbage\"#,*str2=#[Fields]\"potato\"#;\r\n    #[Keywords]char #*str= #[Fields]\"abc\"#;\r\n    #[Keywords]int # result;\r\n    #result = strspn(str1,str);\r\n    #[Keywords]if#(result)\r\n        #printf(#[Fields]\"The first %d is congruent\\n\"#,result);\r\n   #[Keywords] else#\r\n        #printf(#[Fields]\"No character is congruent\"#);\r\n    #result = strspn(str2,str);\r\n    #[Keywords]if#(result)\r\n        #printf(#[Fields]\"The first %d is congruent\\n\"#,result);\r\n   #[Keywords] else#\r\n        #printf(#[Fields]\"No character is congruent\"#);\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了三个字符串并分别赋予初值，其中最后一个变量是用于匹配的字符集。\r\n（2）程序通过调用strspn进行字符集的匹配，它从字符串str1中的第一个字符开始检查是不是属于字符串str中的任意字符，如果属于就继续匹配，直到匹配不成功，本例中会发现直到遇到字符'g'才匹配失败，因为字符'g'不属于字符串str中的任何一个字符。然后输出匹配结果。\r\n（3）程序第二次通过调用strspn对字符串str2进行字符集匹配，发现第一个字符就不属于字符集str中的任意字符。\r\n（4）输出匹配结果是显示前多少个字符匹配成功。\r\n本例程的运行结果是：\r\n[code=java]\r\nThe first 5 is congruent\r\nNo character is congruent\r\n[\/code]\r\n注意：本例程中，进行字符集匹配时，待匹配的字符串中的字符只要是字符集中的任意字符就匹配成功，要明确区分其余字符串匹配的不同。",
        0,
        129,
        1
      ],
      [
        326,
        "strstr：字符串匹配函数",
        "函数原型：char *strstr(char *str1, char *str2); \r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：在字符串中查找另一个字符串首次出现的位置，也就是在字符串str1中查找第一次出现字符串str2的位置。\r\n返回值：返回第一次匹配字符串的指针\r\n例程如下： 应用strstr匹配字符串。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #*str1 = #[Fields]\"Borland International\"#,*str2 = #[Fields]\"nation\"#;\r\n    #[Keywords]char #*result;\r\n    #result=strstr(str1, str2);\r\n    #[Keywords]if#(result)\r\n        #printf(#[Fields]\"The substring is: %s\\n\"#, ptr);\r\n   #[Keywords] else#\r\n        #printf(#[Fields]\"Not found the substring\"#);\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#} \r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了三个字符串变量并给前两个变量赋予初值，其中字符指针result用于记录匹配字符串的位置。\r\n（2）程序通过调用strstr进行字符串匹配，查找字符串str1中首次出现字符串str2的位置，返回匹配结果。\r\n（3）输出匹配结果时以匹配字符串的首字符作为子串的第一个字符输出，如果匹配不成功显示没有找到。\r\n本例程的运行结果是：\r\n[code=java]\r\nThe substring is national \r\n[\/code]\r\n注意：本例程中，匹配成功时的返回结果并不是进行匹配的字符串，而是第一次匹配成功的字符串首字符的指针。",
        0,
        129,
        1
      ],
      [
        327,
        "strtod：字符串转换成双精度函数",
        "函数原型：double strtod(char *str, char **endptr); \r\n头文件：#include<stdlib.h>\r\n是否是标准函数：是\r\n函数功能：将字符串转换非双精度值，也就是将字符串str转换为双精度值，其中进行转换字符串必须是双精度数的字符表示格式，如果字符串中有非法的非数字字符，则第二个参数将负责获取该非法字符，即字符串指针endptr用于进行错误检测，转换在此非法字符处停止进行。\r\n返回值：返回转换后的双精度结果\r\n例程如下： 应用strtod将字符串转换为双精度值。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h>\r\n#include <stdlib.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #str[20], *endptr;\r\n    #[Keywords]double #result;\r\n   #[Keywords] while#(1)\r\n    #{\r\n        #printf(#[Fields]\"Input a float:\"#);\r\n        #gets(str);\r\n        #result=strtod(str,&endptr);\r\n        #[Keywords]if#(result==-1)\r\n            #printf(#[Fields]\"The number is %lf\\n\"#,str,result);\r\n       #[Keywords] else#\r\n            #[Keywords]break#;\r\n    #}\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个用于转换的字符数组和一个用于进行错误检测的字符串指针，双精度result用于获取转换结果。\r\n（2）程序通过循环不断接收从标准输入流中输入的字符串，并通过调用strtod将输入的字符串转换为双精度值，通过返回值获取转换结果，并通过第二个参数进行错误检测。循环的最后将转换结果打印出来。\r\n（3）程序规定将字符串\"-1\"作为循环结束的标志，除非通过输入结束标志，否则循环条件总是成立的。\r\n（4）如果输入一个正确的双精度字符串，程序会正确的转换并补齐尾数；如果输入整数，程序会自动将其转换成双精度数；如果小数点后面的位数过长，超过了双精度的范围，程序会采取截断的方式；如果输入期间出现了非法字符，程序停止转换并保留已转换的结果；如果第一个就是非法字符则返回零。\r\n本例程的运行结果是：\r\n[code=java]\r\nInput a float: 4.2\r\nThe number is 4.20000\r\nInput a float: 79\r\nThe number is 79.00000\r\nInput a float: 1.1111111111\r\nThe number is 1.111111\r\nInput a float: 34.45abc\r\nThe number is 34.450000\r\nInput a float:abc\r\nThe number is 0.000000\r\nInput a float: -1\r\n[\/code]\r\n注意：本例程中，即便转换出现非法字符循环也不会停止，而只是通过第二个参数捕捉到了非法字符，可以编写程序对非法字符进行处理，本例中并没有这样做，循环只是以输入循环结束标志循环结束依据。",
        0,
        129,
        1
      ],
      [
        328,
        "strtok：字符串分隔函数",
        "函数原型：char *strstr(char *str1, char *str2); \r\n头文件：#include<string.h>\r\n是否是标准函数：是\r\n函数功能：在字符串中查找单词，这个单词始有第二个字符串中定义的分隔符分开，也就是在字符串str1中查找由字符串str2定义的分隔符，以分隔符为界，分隔出来的分隔符前面的所有字符组成一个单词，分离出第一个单词后将第一个参数置为空，可以继续分隔第二个单词。\r\n返回值：返回分隔出的单词的指针\r\n例程如下： 应用strtok分隔字符串。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h>\r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #*str1=#[Fields]\"I am very\\thappy,to,stduy\\nC\\nprogramme\"#;\r\n    #[Keywords]char #*str2=#[Fields]\" ,\\t\\n\"#;\r\n    #[Keywords]char #*token;\r\n    #printf(#[Fields]\"%s\\n\\nTokens:\\n\"#,str1);\r\n    #token = strtok(str1,str2);\r\n   #[Keywords] while#( token != NULL )\r\n    #{\r\n        #printf(#[Fields]\"%s\\n\"#,token);\r\n        #token = strtok(NULL,str2);\r\n    #}\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了三个字符串变量并给前两个变量赋予初值，其中第二个字符串是用于分隔的分隔符集，最后一个token用于记录分隔出来的单词，应该注意到第一个字符串中有许多分隔符。\r\n（2）为了突出分隔结果，我们首先将字符串str1打印出来，它是按照标准输出的格式进行输出。\r\n（3）程序通过调用strtok进行字符串分隔，查找字符串str1中首次出现字符串str2任意分隔符的位置，然后将分隔符之前的所有字符组成一个单词返回给token变量，从而得到分隔出来的首个单词。\r\n（4）在循环体中，我们每次循环都要将上一次分隔出来的单词打印出来，另外就像前面所说，将strtok函数第一个参数置为空可以达到继续进行分隔的目的，也就是在上一次分隔出来的单词之后继续进行分隔，直到所有单词都分隔完毕，token变量会得到空的返回值，我们结束循环。\r\n（5）打印分隔结果时，以换行区分每次分隔出的单词。\r\n本例程的运行结果是：\r\n[code=java]\r\nI am very\t\thappy,to,study\r\nC\r\nProgramme\r\nToken:\r\nI\r\nam\r\nvery\r\nhappy\r\nto\r\nstudy\r\nC\r\nProgramme\r\n[\/code]\r\n注意：本例程中，一定要记住如果在第一次分隔出单词后想继续进行分隔操作，务必要将函数的第一个参数置为空。",
        0,
        129,
        1
      ],
      [
        329,
        "strtol：字符串转换成长整型函数",
        "函数原型：long strtol(char *str, char **endptr, int base); \r\n头文件：#include<stdlib.h>\r\n是否是标准函数：是\r\n函数功能：将字符串转换为长整型值，也就是将字符串str转换为长整型值，其中进行转换字符串必须是长整型的字符表示格式，如果字符串中有非法的非数字字符，则第二个参数将负责获取该非法字符，即字符串指针endptr用于进行错误检测，转换在此非法字符处停止进行。\r\n返回值：返回转换后的长整型结果\r\n例程如下： 应用strtol将字符串转换为长整型值。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h>\r\n#include <stdlib.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #str[20], *endptr;\r\n    #[Keywords]long #result;\r\n   #[Keywords] while#(1)\r\n    #{\r\n        #printf(#[Fields]\"Input a long:\"#);\r\n        #gets(str);\r\n        #result=strtod(str,&endptr);\r\n        #[Keywords]if#(result!=-1)\r\n            #printf(#[Fields]\"The number is %ld\\n\"#,result);\r\n       #[Keywords] else#\r\n            #[Keywords]break#;\r\n    #}\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#}\r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个用于转换的字符数组和一个用于进行错误检测的字符串指针，长整型result用于获取转换结果。\r\n（2）程序通过循环不断接收从标准输入流中输入的字符串，并通过调用strtol将输入的字符串转换为长整型值，通过返回值获取转换结果，并通过第二个参数进行错误检测。循环的最后将转换结果打印出来。\r\n（3）程序规定将字符串\"-1\"作为循环结束的标志，除非通过输入结束标志，否则循环条件总是成立的。\r\n（4）如果输入一个正确的长整型字符串，程序会正确转换；如果输入小数，程序会将小数点后面的截断；如果转换的数过大，超过了长整型范围，程序返回长整型所能接受的最大值；如果输入期间出现了非法字符，程序停止转换并保留已转换的结果；如果第一个就是非法字符则返回零。\r\n本例程的运行结果是：\r\n[code=java]\r\nInput a long: -15\r\nThe number is -15\r\nInput a long: 1234.5678\r\nThe number is 1234\r\nInput a long: 333333333333\r\nThe number is 2147483647\r\nInput a long: -34abc\r\nThe number is -34\r\nInput a long: abc\r\nThe number is 0\r\nInput a float: -1\r\n[\/code]\r\n注意：本例程中，将字符串中的小数转换为长整型时，程序会将小数点看作非法字符，从而停止转换继续进行，因此无论小数点后面的数是多少都会截断，而不是我们习惯上的四舍五入或者五舍六入。",
        0,
        129,
        1
      ],
      [
        330,
        "strtoul：字符串转换成无符号长整型函数",
        "函数原型：unsigned long strtoul(char *str, char **endptr, int base); \r\n头文件：#include<stdlib.h>\r\n是否是标准函数：是\r\n函数功能：将字符串转换为无符号长整型值，也就是将字符串str转换为无符号长整型值，其中进行转换字符串必须是无符号长整型的字符表示格式，如果字符串中有非法的非数字字符，则第二个参数将负责获取该非法字符，即字符串指针endptr用于进行错误检测，转换在此非法字符处停止进行。\r\n返回值：返回转换后的无符号长整型结果\r\n例程如下： 应用strtoul将字符串转换为无符号长整型值。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h>\r\n#include <stdlib.h> \r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #str[20], *endptr;\r\n    #unsigned #[Keywords]long #result;\r\n   #[Keywords] while#(1)\r\n    #{\r\n        #printf(#[Fields]\"Input an unsigned long:\"#);\r\n        #gets(str);\r\n        #result=strtoud(str,&endptr);\r\n        #[Keywords]if#(result!=-1)\r\n            #printf(#[Fields]\"The number is %lu\\n\"#,result);\r\n       #[Keywords] else#\r\n            #[Keywords]break#;\r\n    #}\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#} \r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个用于转换的字符数组和一个用于进行错误检测的字符串指针，无符号长整型result用于获取转换结果。\r\n（2）程序通过循环不断接收从标准输入流中输入的字符串，并通过调用strtoul将输入的字符串转换为无符号长整型值，通过返回值获取转换结果，并通过第二个参数进行错误检测。循环的最后将转换结果打印出来。\r\n（3）程序规定将字符串\"1\"作为循环结束的标志，除非通过输入结束标志，否则循环条件总是成立的。\r\n（4）如果输入一个正确的长整型字符串，程序会正确转换；如果输入一个负数，程序返回零。\r\n本例程的运行结果是：\r\n[code=java]\r\nInput a long: 100\r\nThe number is 100\r\nInput a long: -36\r\nThe number is 0\r\nInput a float: 1\r\n[\/code]\r\n注意：本例程中，输入负数的时候程序会将负号看作非法字符，从而停止转换继续进行，没有发生任何实际的转换。",
        0,
        129,
        1
      ],
      [
        331,
        "strupr：字符串大写转换函数",
        "函数原型：char *strupr(char *str);\r\n头文件：#include<string.h>\r\n是否是标准函数：否\r\n函数功能：将字符串原有小写字符全部转换为大写字符，也就是将字符串str中的所有字符变成大写。\r\n返回值：返回指向被转换字符串的指针\r\n例程如下： 应用strupr将字符串转换成大写字符。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h>\r\n#[Keywords]int #main(void) \r\n{ \r\n    #[Keywords]char #*s=#[Fields]\" You#[Fields]'ll Never Walk Alone \"#;\r\n    #printf(#[Fields]\"%s\"#,strlwr(s));\r\n    #getch();\r\n    #[Keywords]return #0;\r\n#} \r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符串为待转换字符串并赋予初值。\r\n（2）程序通过调用strupr将字符串中的所有小写字符转换成大写字符，并返回转换后的结果。\r\n（3）最后将转换结果打印出来。\r\n本例程的运行结果是：\r\n[code=java]\r\nYOU’LL NEVER WALK ALONE \r\n[\/code]",
        0,
        129,
        1
      ],
      [
        332,
        "strupr：字符串大写转换函数",
        "函数原型：char *strupr(char *str);\r\n头文件：#include<string.h>\r\n是否是标准函数：否\r\n函数功能：将字符串原有小写字符全部转换为大写字符，也就是将字符串str中的所有字符变成大写。\r\n返回值：返回指向被转换字符串的指针\r\n例程如下： 应用strupr将字符串转换成大写字符。\r\n[code=java]\r\n#include <stdio.h> \r\n#include <string.h>\r\nint main(void) \r\n{ \r\n    char *s=\" You'll Never Walk Alone \";\r\n    printf(\"%s\",strlwr(s));\r\n    getch();\r\n    return 0;\r\n} \r\n[\/code]\r\n[color=blue]例程说明：\r\n（1）首先，程序声明了一个字符串为待转换字符串并赋予初值。\r\n（2）程序通过调用strupr将字符串中的所有小写字符转换成大写字符，并返回转换后的结果。\r\n（3）最后将转换结果打印出来。\r\n本例程的运行结果是：\r\n[code=java]\r\nYOU’LL NEVER WALK ALONE \r\n[\/code]",
        0,
        129,
        1
      ]
    ]
  },
  {
    "table" : "c_samples",
    "columns" : [
      "id",
      "title",
      "content",
      "importance",
      "showFlag",
      "version"
    ],
    "data" : [
      [
        0,
        "编程实例",
        "",
        9,
        111,
        1
      ],
      [
        1,
        "【程序1】",
        "题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？\r\n1.程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去掉不满足条件的排列。 \r\n2.程序源代码：\r\n[code=java]\r\n#include<stdio.h>\r\n#include<math.h>\r\n#[Keywords]int #main()\r\n{\r\n    #[Keywords]int #i,j,k ;\r\n    #[Keywords]int #num=0 ;\r\n    #[Keywords]int #s ;\r\n    #[Keywords]int #a ;\r\n    #printf(#[Fields]\"\\n\"#);\r\n    #[Keywords]for#(i=1;i<5;i++)\r\n    #[Keywords]for#(j=1;j<5;j++)\r\n    #[Keywords]for#(k=1;k<5;k++)\r\n    #{\r\n        #[Keywords]if#(i!=k&&i!=j&&j!=k)\r\n        #{\r\n            #num=num+1 ;\r\n            #s=i*100+j*10+k ;\r\n            #printf(#[Fields]\"%d \"#,s);\r\n            #[Keywords]if#(mod(num,8)==0)\r\n            #{\r\n                #printf(#[Fields]\"\\n\"#);\r\n            #}\r\n            \r\n        #}\r\n    #}  \r\n    #printf(#[Fields]\"\\n共有%d个，结果如上\\n\"#,num);\r\n    #scanf(#[Fields]\"%d\"#,&a);\r\n    #[Keywords]return #0 ;\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        2,
        "【程序2】",
        "题目：企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？\r\n1.程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。　　　　　　\r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n    #[Keywords]long #[Keywords]int #i ;\r\n    #[Keywords]int #bonus1,bonus2,bonus4,bonus6,bonus10,bonus ;\r\n    #scanf(#[Fields]\"%ld\"#,&i);\r\n    #bonus1=100000*0.1 ;\r\n    #bonus2=bonus1+100000*0.75 ;\r\n    #bonus4=bonus2+200000*0.5 ;\r\n    #bonus6=bonus4+200000*0.3 ;\r\n    #bonus10=bonus6+400000*0.15 ;\r\n    #　 #[Keywords]if#(i<=100000)\r\n    #　 bonus=i*0.1 ;\r\n    #　 #[Keywords]else #[Keywords]if#(i<=200000)\r\n    #　 　 　 　 　 bonus=bonus1+(i-100000)*0.075 ;\r\n    #　 　 　 #[Keywords]else #[Keywords]if#(i<=400000)\r\n    #　 　 　 　 　 bonus=bonus2+(i-200000)*0.05 ;\r\n    #　 　 　 #[Keywords]else #[Keywords]if#(i<=600000)\r\n    #　 　 　 　 　 bonus=bonus4+(i-400000)*0.03 ;\r\n    #　 　 　 #[Keywords]else #[Keywords]if#(i<=1000000)\r\n    #　 　 　 　 　 bonus=bonus6+(i-600000)*0.015 ;\r\n    #　 　 　 #[Keywords]else #\r\n    #　 　 　 　 bonus=bonus10+(i-1000000)*0.01 ;\r\n    #printf(#[Fields]\"bonus=%d\"#,bonus);\r\n#} \r\n[\/code]",
        8,
        111,
        1
      ],
      [
        3,
        "【程序3】",
        "题目：一个整数，它加上100后是一个完全平方数，再加上168又是一个完全平方数，请问该数是多少？\r\n1.程序分析：在10万以内判断，先将该数加上100后再开方，再将该数加上268后再开方，如果开方后的结果满足如下条件，即是结果。\r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"math.h\r\nmain()\r\n{\r\n    #[Keywords]long #[Keywords]int #i,x,y,z ;\r\n    #[Keywords]for#(i=1;i<100000;i++)\r\n    #{\r\n        #x=sqrt(i+100);\r\n        #\/*x为加上100后开方后的结果*\/\r\n        #　 　 y=sqrt(i+268);\r\n        #\/*y为再加上168后开方后的结果*\/\r\n        #\/*如果一个数的平方根的平方等于该数，这说明此数是完全平方数*\/\r\n        #　 　 #[Keywords]if#(x*x==i+100&&y*y==i+268)printf(#[Fields]\"\\n%ld\\n\"#,i);\r\n    #}\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        4,
        "【程序4】",
        "题目：输入某年某月某日，判断这一天是这一年的第几天？\r\n1.程序分析：以3月5日为例，应该先把前两个月的加起来，然后再加上5天即本年的第几天，特殊情况，闰年且输入月份大于3时需考虑多加一天。\r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n    #[Keywords]int #day,month,year,sum,leap ;\r\n    #printf(#[Fields]\"\\nplease input year,month,day\\n\"#);\r\n    #scanf(#[Fields]\"%d,%d,%d\"#,&year,&month,&day);\r\n    #\/*先计算某月以前月份的总天数*\/\r\n    #switch(month)\r\n    #{\r\n        #　 #[Keywords]case #1 :\r\n        #sum=0 ;\r\n        #[Keywords]break# ;\r\n        #　 #[Keywords]case #2 :\r\n        #sum=31 ;\r\n        #[Keywords]break# ;\r\n        #　 #[Keywords]case #3 :\r\n        #sum=59 ;\r\n        #[Keywords]break# ;\r\n        #　 #[Keywords]case #4 :\r\n        #sum=90 ;\r\n        #[Keywords]break# ;\r\n        #　 #[Keywords]case #5 :\r\n        #sum=120 ;\r\n        #[Keywords]break# ;\r\n        #　 #[Keywords]case #6 :\r\n        #sum=151 ;\r\n        #[Keywords]break# ;\r\n        #　 #[Keywords]case #7 :\r\n        #sum=181 ;\r\n        #[Keywords]break# ;\r\n        #　 #[Keywords]case #8 :\r\n        #sum=212 ;\r\n        #[Keywords]break# ;\r\n        #　 #[Keywords]case #9 :\r\n        #sum=243 ;\r\n        #[Keywords]break# ;\r\n        #　 #[Keywords]case #10 :\r\n        #sum=273 ;\r\n        #[Keywords]break# ;\r\n        #　 #[Keywords]case #11 :\r\n        #sum=304 ;\r\n        #[Keywords]break# ;\r\n        #　 #[Keywords]case #12 :\r\n        #sum=334 ;\r\n        #[Keywords]break# ;\r\n        #　 default :\r\n        #printf(#[Fields]\"data error\"#);\r\n        #[Keywords]break# ;\r\n    #}\r\n    #sum=sum+day ;\r\n    #\/*再加上某天的天数*\/\r\n    #\/*判断是不是闰年*\/\r\n    #　 #[Keywords]if#(year%400==0||(year%4==0&&year%100!=0))　 　 leap=1 ;\r\n    #[Keywords]else #\r\n    #　 　 leap=0 ;\r\n    #\/*如果是闰年且月份大于2,总天数应该加一天*\/\r\n    #[Keywords]if#(leap==1&&month>2)sum++;\r\n    #printf(#[Fields]\"It is the %dth day.\"#,sum);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        5,
        "【程序5】",
        "题目：输入三个整数x,y,z，请把这三个数由小到大输出。\r\n1.程序分析：我们想办法把最小的数放到x上，先将x与y进行比较，如果x>y则将x与y的值进行交换，然后再用x与z进行比较，如果x>z则将x与z的值进行交换，这样能使x最小。\r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n    #[Keywords]int #x,y,z,t ;\r\n    #scanf(#[Fields]\"%d%d%d\"#,&x,&y,&z);\r\n    #[Keywords]if#(x>y)\r\n    #{\r\n        #t=x ;\r\n        #x=y ;\r\n        #y=t ;\r\n    #}\r\n    #\/*交换x,y的值*\/\r\n    #[Keywords]if#(x>z)\r\n    #{\r\n        #t=z ;\r\n        #z=x ;\r\n        #x=t ;\r\n    #}\r\n    #\/*交换x,z的值*\/\r\n    #[Keywords]if#(y>z)\r\n    #{\r\n        #t=y ;\r\n        #y=z ;\r\n        #z=t ;\r\n    #}\r\n    #\/*交换z,y的值*\/\r\n    #printf(#[Fields]\"small to big: %d %d %d\\n\"#,x,y,z);\r\n#}\r\n[\/code]\r\n",
        8,
        111,
        1
      ],
      [
        6,
        "【程序6】",
        "题目：用*号输出字母C的图案。\r\n1.程序分析：可先用'*'号在纸上写出字母C，再分行输出。\r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n    #printf(#[Fields]\"Hello C-world!\\n\"#);\r\n    #printf(#[Fields]\" ****\\n\"#);\r\n    #printf(#[Fields]\" *\\n\"#);\r\n    #printf(#[Fields]\" * \\n\"#);\r\n    #printf(#[Fields]\" ****\\n\"#);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        7,
        "【程序7】",
        "题目：输出特殊图案，请在c环境中运行，看一看，Very Beautiful!\r\n1.程序分析：字符共有256个。不同字符，图形不一样。　　　　　　\r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n    #[Keywords]char #a=176,b=219 ;\r\n    #printf(#[Fields]\"%c%c%c%c%c\\n\"#,b,a,a,a,b);\r\n    #printf(#[Fields]\"%c%c%c%c%c\\n\"#,a,b,a,b,a);\r\n    #printf(#[Fields]\"%c%c%c%c%c\\n\"#,a,a,b,a,a);\r\n    #printf(#[Fields]\"%c%c%c%c%c\\n\"#,a,b,a,b,a);\r\n    #printf(#[Fields]\"%c%c%c%c%c\\n\"#,b,a,a,a,b);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        8,
        "【程序8】",
        "题目：输出9*9口诀。\r\n1.程序分析：分行与列考虑，共9行9列，i控制行，j控制列。\r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n　 #[Keywords]int #i,j,result;\r\n　 printf(#[Fields]\"\\n\"#);\r\n　 #[Keywords]for #(i=1;i<10;i++)\r\n　　 { \r\n\t\t#[Keywords]for#(j=1;j<10;j++)\r\n　　　　 {\r\n　　　　　 result=i*j;\r\n　　　　　 printf(#[Fields]\"%d*%d=%-3d\"#,i,j,result);\/*-3d表示左对齐，占3位*\/\r\n　　　　 #}\r\n　　　 printf(#[Fields]\"\\n\"#);\/*每一行后换行*\/\r\n　　 #}\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        9,
        "【程序9】",
        "题目：要求输出国际象棋棋盘。\r\n1.程序分析：用i控制行，j来控制列，根据i+j的和的变化来控制输出黑方格，还是白方格。\r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n    #[Keywords]int #i,j ;\r\n    #[Keywords]for#(i=0;i<8;i++) \r\n    #{\r\n　 　 #[Keywords]for#(j=0;j<8;j++)\r\n　 　 　 #[Keywords]if#((i+j)%2==0)\r\n　 　 　 　 printf(#[Fields]\"%c%c\"#,219,219);\r\n　 　 　 #[Keywords]else #\r\n　 　 　 　 printf(#[Fields]\" \"#);\r\n　 　 　 printf(#[Fields]\"\\n\"#); \r\n    #}\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        10,
        "【程序10】",
        "题目：打印楼梯，同时在楼梯上方打印两个笑脸。 \r\n1.程序分析：用i控制行，j来控制列，j根据i的变化来控制输出黑方格的个数。\r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n    #[Keywords]int #i,j ;\r\n    #printf(#[Fields]\"\\1\\1\\n\"#);\r\n    #\/*输出两个笑脸*\/\r\n    #[Keywords]for#(i=1;i<11;i++)　 \r\n    #{\r\n\t#　 #[Keywords]for#(j=1;j<=i;j++)\r\n\t#　 　 printf(#[Fields]\"%c%c\"#,219,219);\r\n\t#　 printf(#[Fields]\"\\n\"#);\r\n        #　\r\n    #}\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        11,
        "【程序11】",
        "题目：古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？\r\n1.程序分析：　兔子的规律为数列1,1,2,3,5,8,13,21....\r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n    #[Keywords]long #f1,f2 ;\r\n    #[Keywords]int #i ;\r\n    #f1=f2=1 ;\r\n    #[Keywords]for#(i=1;i<=20;i++)\r\n    #　\r\n    #{\r\n        #printf(#[Fields]\"%12ld %12ld\"#,f1,f2);\r\n        #　 　 　 #[Keywords]if#(i%2==0)printf(#[Fields]\"\\n\"#);\r\n        #\/*控制输出，每行四个*\/\r\n        #　 　 　 f1=f1+f2 ;\r\n        #\/*前两个月加起来赋值给第三个月*\/\r\n        #　 　 　 f2=f1+f2 ;\r\n        #\/*前两个月加起来赋值给第三个月*\/\r\n        #　\r\n    #}\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        12,
        "【程序12】",
        "题目：判断101-200之间有多少个素数，并输出所有素数。\r\n1.程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，则表明此数不是素数，反之是素数。 　　　　　　\r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"math.h\"#\r\nmain()\r\n{\r\n　\t#[Keywords]int #m,i,k,h=0,leap=1;\r\n　\tprintf(#[Fields]\"\\n\"#);\r\n　 \t#[Keywords]for#(m=101;m<=200;m++)\r\n　\t{ \r\n\t\t#k=sqrt(m+1);\r\n　　　 \t#[Keywords]for#(i=2;i<=k;i++)\r\n　　　　　 #[Keywords]if#(m%i==0)\r\n　　　　　　 {leap=0;#[Keywords]break#;#}\r\n　　　 \t#[Keywords]if#(leap) {\r\n\t\t\t#printf(#[Fields]\"%-4d\"#,m);h++;\r\n　　　　　　#[Keywords]if#(h%10==0)\r\n　　　　　　　　 printf(#[Fields]\"\\n\"#);\r\n　　　　#}\r\n　　　 \tleap=1;\r\n　　 #}\r\n　 printf(#[Fields]\"\\nThe total is %d\"#,h);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        13,
        "【程序13】",
        "题目：打印出所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个“水仙花数”，因为153=1的三次方＋5的三次方＋3的三次方。\r\n1.程序分析：利用for循环控制100-999个数，每个数分解出个位，十位，百位。\r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]int #i,j,k,n;\r\n\t#printf(#[Fields]\"#[Fields]'water flower'#number is:\"#);\r\n\t#[Keywords]for#(n=100;n<1000;n++)\r\n\t#{\r\n\t#　　i=n\/100;\/*分解出百位*\/\r\n\t#　　j=n\/10%10;\/*分解出十位*\/\r\n\t#　　k=n%10;\/*分解出个位*\/\r\n\t#　　#[Keywords]if#(i*100+j*10+k==i*i*i+j*j*j+k*k*k)\r\n\t#　　{\r\n\t#　　　 \tprintf(#[Fields]\"%-5d\"#,n);\r\n\t#　　#}\r\n\t#}\r\n\t#printf(#[Fields]\"\\n\"#);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        14,
        "【程序14】",
        "题目：将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。\r\n程序分析：对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成： \r\n(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。\r\n(2)如果n<>k，但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数你n,重复执行第一步。\r\n(3)如果n不能被k整除，则用k+1作为k的值,重复执行第一步。\r\n2.程序源代码：\r\n[code=java]\r\n\/* zheng #[Keywords]int #is divided yinshu*\/\r\nmain()\r\n{\r\n\t#[Keywords]int #n,i;\r\n\t#printf(#[Fields]\"\\nplease input a number:\\n\"#);\r\n\t#scanf(#[Fields]\"%d\"#,&n);\r\n\t#printf(#[Fields]\"%d=\"#,n);\r\n\t#[Keywords]for#(i=2;i<=n;i++)\r\n\t#{\r\n　　\t#[Keywords]while#(n!=i)\r\n　　\t{\r\n　　　\t\t#[Keywords]if#(n%i==0)\r\n　　　\t\t{ \r\n\t\t\t\t#printf(#[Fields]\"%d*\"#,i);\r\n　　　　\t\tn=n\/i;\r\n　　　 \t\t#}\r\n　　　 \t\telse\r\n　　　　 \t\t#[Keywords]break#;\r\n　　 \t#}\r\n\t#}\r\n\t#printf(#[Fields]\"%d\"#,n);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        15,
        "【程序15】",
        "题目：利用条件运算符的嵌套来完成此题：学习成绩>=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。\r\n1.程序分析：(a>b)?a:b这是条件运算符的基本例子。\r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n　 #[Keywords]int #score;\r\n　 #[Keywords]char #grade;\r\n　 printf(#[Fields]\"please input a score\\n\"#);\r\n　 scanf(#[Fields]\"%d\"#,&score);\r\n　 grade=score>=90?#[Fields]'A'#:(score>=60?#[Fields]'B'#:#[Fields]'C'#);\r\n　 printf(#[Fields]\"%d belongs to %c\"#,score,grade);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        16,
        "【程序16】",
        "题目：输入两个正整数m和n，求其最大公约数和最小公倍数。\r\n1.程序分析：利用辗除法。\r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n　 \t#[Keywords]int #a,b,num1,num2,temp;\r\n　\tprintf(#[Fields]\"please input two numbers:\\n\"#);\r\n　\tscanf(#[Fields]\"%d,%d\"#,&num1,&num2);\r\n　\t#[Keywords]if#(num1<num2)   \r\n　\t{ \r\n\t\t#temp=num1;\r\n　　\tnum1=num2;　\r\n　　 \tnum2=temp;\r\n　 \t#}\r\n\t#a=num1;b=num2;\r\n\t#[Keywords]while#(b!=0)\/*利用辗除法，直到b为0为止*\/\r\n　\t{\r\n　　\ttemp=a%b;\r\n　　\ta=b;\r\n　　\tb=temp;\r\n　 \t#}\r\n\t#printf(#[Fields]\"gongyueshu:%d\\n\"#,a);\r\n\t#printf(#[Fields]\"gongbeishu:%d\\n\"#,num1*num2\/a);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        17,
        "【程序17】",
        "题目：输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。\r\n1.程序分析：利用while语句,条件为输入的字符不为'\\n'.　　　　 \r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n\t#[Keywords]char #c;\r\n　 \t#[Keywords]int #letters=0,space=0,digit=0,others=0;\r\n　 \tprintf(#[Fields]\"please input some characters\\n\"#);\r\n　 \t#[Keywords]while#((c=getchar())!=#[Fields]'\\n'#)\r\n　\t{\r\n　 \t\t#[Keywords]if#(c>=#[Fields]'a'#&&c<=#[Fields]'z'#||c>=#[Fields]'A'#&&c<=#[Fields]'Z'#)\r\n　　\t\t letters++;\r\n　 \t\t#[Keywords]else #[Keywords]if#(c==#[Fields]' '#)\r\n　　\t\t space++;\r\n　　　\t #[Keywords]else #[Keywords]if#(c>=#[Fields]'0'#&&c<=#[Fields]'9'#)\r\n　　　　　　　 digit++;\r\n　　　　#[Keywords] else#\r\n　　　　　　　 others++;\r\n\t#}\r\n\t#printf(#[Fields]\"all in all:char=%d space=%d digit=%d others=%d\\n\"#,letters,\r\n\t#space,digit,others);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        18,
        "【程序18】",
        "题目：求s=a+aa+aaa+aaaa+aa...a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。\r\n1.程序分析：关键是计算出每一项的值。\r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n　 #[Keywords]int #a,n,count=1;\r\n　 #[Keywords]long #[Keywords]int #sn=0,tn=0;\r\n　 printf(#[Fields]\"please input a and n\\n\"#);\r\n　 scanf(#[Fields]\"%d,%d\"#,&a,&n);\r\n　 printf(#[Fields]\"a=%d,n=%d\\n\"#,a,n);\r\n　#[Keywords] while#(count<=n)\r\n　 {\r\n　　 tn=tn+a;\r\n　　 sn=sn+tn;\r\n　　 a=a*10;\r\n　　 ++count;\r\n　 #}\r\n\t#printf(#[Fields]\"a+aa+...=%ld\\n\"#,sn);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        19,
        "【程序19】",
        "题目：一个数如果恰好等于它的因子之和，这个数就称为“完数”。例如6=1＋2＋3.编程找出1000以内的所有完数。\r\n1. 程序分析：请参照程序<--上页程序14. \r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]static #[Keywords]int #k[10];\r\n\t#[Keywords]int #i,j,n,s;\r\n\t#[Keywords]for#(j=2;j<1000;j++)\r\n\t#{\r\n\t#　 n=-1;\r\n\t#　 s=j;\r\n\t#　 #[Keywords]for#(i=1;i<j;i++)\r\n\t   #{\r\n\t#　　　 #[Keywords]if#((j%i)==0)\r\n\t#　　　 {　n++;\r\n\t#　　　　  s=s-i;\r\n\t#　　\t  k[n]=i;\r\n\t#　　\t#}\r\n\t#　 \t#}\r\n\t#　\t #[Keywords]if#(s==0)\r\n\t#　\t {\r\n\t\t#　 \tprintf(#[Fields]\"%d is a wanshu\"#,j);\r\n\t\t#　 \t#[Keywords]for#(i=0;i<n;i++)\r\n\t\t#　\tprintf(#[Fields]\"%d,\"#,k[i]);\r\n\t\t#　\tprintf(#[Fields]\"%d\\n\"#,k[n]);\r\n\t#　 \t#}\r\n\t#}\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        20,
        "【程序20】",
        "题目：一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？\r\n1.程序分析：见下面注释\r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]float #sn=100.0,hn=sn\/2;\r\n\t#[Keywords]int #n;\r\n\t#[Keywords]for#(n=2;n<=10;n++)\r\n　 \t{\r\n　　\tsn=sn+2*hn;\/*第n次落地时共经过的米数*\/\r\n　　 \thn=hn\/2; \/*第n次反跳高度*\/\r\n　\t#}\r\n\t#printf(#[Fields]\"the total of road is %f\\n\"#,sn);\r\n\t#printf(#[Fields]\"the tenth is %f meter\\n\"#,hn);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        21,
        "【程序21】",
        "题目：猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。\r\n1.程序分析：采取逆向思维的方法，从后往前推断。\r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]long #ge,shi,qian,wan,x;\r\n\t#scanf(#[Fields]\"%ld\"#,&x);\r\n\t#wan=x\/10000;\r\n\t#qian=x%10000\/1000;\r\n\t#shi=x%100\/10;\r\n\t#ge=x%10;\r\n\t#[Keywords]if #(ge==wan&&shi==qian)\/*个位等于万位并且十位等于千位*\/\r\n\t#　 printf(#[Fields]\"#[Keywords]this# number is a huiwen\\n\"#);\r\n\t#else\r\n\t#　 printf(#[Fields]\"#[Keywords]this# number is not a huiwen\\n\"#);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        22,
        "【程序22】",
        "题目：两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。 \r\n1.程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，则表明此数不是素数，反之是素数。 　　　　　　\r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]char #i,j,k;\/*i是a的对手，j是b的对手，k是c的对手*\/\r\n\t#[Keywords]for#(i=#[Fields]'x'#;i<=#[Fields]'z'#;i++)\r\n　 \t\t#[Keywords]for#(j=#[Fields]'x'#;j<=#[Fields]'z'#;j++)\r\n　 \t\t{\r\n　 \t\t\t#[Keywords]if#(i!=j)\r\n　　\t\t\t#[Keywords]for#(k=#[Fields]'x'#;k<=#[Fields]'z'#;k++)\r\n　　 \t\t\t{ \r\n\t\t\t\t\t#[Keywords]if#(i!=k&&j!=k)\r\n\t#　　　 \t\t\t{\r\n\t\t\t\t\t\t#[Keywords]if#(i!=#[Fields]'x'#&&k!=#[Fields]'x'#&&k!=#[Fields]'z'#)\r\n\t#　　　\t\t\t\t\tprintf(#[Fields]\"order is a--%c\\tb--%c\\tc--%c\\n\"#,i,j,k);\r\n\t#　　　 \t\t\t#}\r\n　　\t\t\t#}\r\n　 \t\t#}\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        23,
        "【程序23】",
        "题目：打印出如下图案（菱形）\r\n[code=java]\r\n*\r\n***\r\n******\r\n********\r\n******\r\n***\r\n*\r\n[\/code]\r\n1.程序分析：先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重for循环，第一层控制行，第二层控制列。 \r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]int #i,j,k;\r\n\t#[Keywords]for#(i=0;i<=3;i++)\r\n　\t{\r\n　 \t\t#[Keywords]for#(j=0;j<=2-i;j++)\r\n　\t\t　 printf(#[Fields]\" \"#);\r\n　\t\t#[Keywords]for#(k=0;k<=2*i;k++)\r\n　　\t\tprintf(#[Fields]\"*\"#);\r\n　\t\tprintf(#[Fields]\"\\n\"#);\r\n　\t#}\r\n\t#[Keywords]for#(i=0;i<=2;i++)\r\n　\t{\r\n　\t\t#[Keywords]for#(j=0;j<=i;j++)\r\n　　\t\tprintf(#[Fields]\" \"#);\r\n　\t\t#[Keywords]for#(k=0;k<=4-2*i;k++)\r\n　　\t\tprintf(#[Fields]\"*\"#);\r\n　\t\tprintf(#[Fields]\"\\n\"#);\r\n　\t#}\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        24,
        "【程序24】",
        "题目：有一分数序列：2\/1，3\/2，5\/3，8\/5，13\/8，21\/13...求出这个数列的前20项之和。\r\n1.程序分析：请抓住分子与分母的变化规律。 \r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]int #n,t,number=20;\r\n\t#[Keywords]float #a=2,b=1,s=0;\r\n\t#[Keywords]for#(n=1;n<=number;n++)\r\n　 \t{\r\n　\t\ts=s+a\/b;\r\n　\t\tt=a;a=a+b;b=t;\/*这部分是程序的关键，请读者猜猜t的作用*\/\r\n　 \t#}\r\n\t#printf(#[Fields]\"sum is %9.6f\\n\"#,s);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        25,
        "【程序25】",
        "题目：求1+2!+3!+...+20!的和\r\n1.程序分析：此程序只是把累加变成了累乘。 \r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]float #n,s=0,t=1;\r\n\t#[Keywords]for#(n=1;n<=20;n++)\r\n\t#{\r\n\t#　 t*=n;\r\n\t#　 s+=t;\r\n\t#}\r\n\t#printf(#[Fields]\"1+2!+3!...+20!=%e\\n\"#,s);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        26,
        "【程序26】",
        "题目：利用递归方法求5!。\r\n1.程序分析：递归公式：fn=fn_1*4!\r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n\t#[Keywords]int #i;\r\n\t#[Keywords]int #fact();\r\n\t#[Keywords]for#(i=0;i<5;i++)\r\n\t#　 printf(#[Fields]\"\\40:%d!=%d\\n\"#,i,fact(i));\r\n#}\r\n#[Keywords]int #fact(j)\r\n#[Keywords]int #j;\r\n{\r\n\t#[Keywords]int #sum;\r\n\t#[Keywords]if#(j==0)\r\n\t#　 sum=1;\r\n\t#else\r\n\t#　 sum=j*fact(j-1);\r\n\t#[Keywords]return #sum;\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        27,
        "【程序27】",
        "题目：利用递归函数调用方式，将所输入的5个字符，以相反顺序打印出来。\r\n1.程序分析：\r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n\t#[Keywords]int #i=5;\r\n\t#[Keywords]void #palin(#[Keywords]int #n);\r\n\t#printf(#[Fields]\"\\40:\"#);\r\n\t#palin(i);\r\n\t#printf(#[Fields]\"\\n\"#);\r\n#}\r\n#[Keywords]void #palin(n)\r\n#[Keywords]int #n;\r\n{\r\n\t#[Keywords]char #next;\r\n\t#[Keywords]if#(n<=1)\r\n　 \t{\r\n　 \t\tnext=getchar();\r\n　 \t\tprintf(#[Fields]\"\\n\\0:\"#);\r\n　 \t\tputchar(next);\r\n　 \t#}\r\n\t#else\r\n　\t{\r\n　\t\tnext=getchar();\r\n　\t\tpalin(n-1);\r\n　\t\tputchar(next);\r\n　\t#}\r\n#}\r\n[\/code]\r\n",
        8,
        111,
        1
      ],
      [
        28,
        "【程序28】",
        "题目：有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？\r\n1.程序分析：利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道第四人的岁数，依次类推，推到第一人（10岁），再往回推。\r\n2.程序源代码：\r\n[code=java]\r\nage(n)\r\n#[Keywords]int #n;\r\n{\r\n\t#[Keywords]int #c;\r\n\t#[Keywords]if#(n==1) c=10;\r\n\t#[Keywords]else #c=age(n-1)+2;\r\n\t#return(c);\r\n#}\r\nmain()\r\n{ \r\n\t#printf(#[Fields]\"%d\"#,age(5));\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        29,
        "【程序29】",
        "题目：给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。\r\n1. 程序分析：学会分解出每一位数，如下解释：\r\n2.程序源代码：\r\n[code=java]\r\nmain( )\r\n{\r\n\t#[Keywords]long #a,b,c,d,e,x;\r\n\t#scanf(#[Fields]\"%ld\"#,&x);\r\n\t#a=x\/10000;\/*分解出万位*\/\r\n\t#b=x%10000\/1000;\/*分解出千位*\/\r\n\t#c=x%1000\/100;\/*分解出百位*\/\r\n\t#d=x%100\/10;\/*分解出十位*\/\r\n\t#e=x%10;\/*分解出个位*\/\r\n\t#[Keywords]if #(a!=0) printf(#[Fields]\"there are 5, %ld %ld %ld %ld %ld\\n\"#,e,d,c,b,a);\r\n\t#[Keywords]else #[Keywords]if #(b!=0) printf(#[Fields]\"there are 4, %ld %ld %ld %ld\\n\"#,e,d,c,b);\r\n\t#[Keywords]else #[Keywords]if #(c!=0) printf(#[Fields]\" there are 3,%ld %ld %ld\\n\"#,e,d,c);\r\n\t#[Keywords]else #[Keywords]if #(d!=0) printf(#[Fields]\"there are 2, %ld %ld\\n\"#,e,d);\r\n\t#[Keywords]else #[Keywords]if #(e!=0) printf(#[Fields]\" there are 1,%ld\\n\"#,e);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        30,
        "【程序30】",
        "题目：一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。　　　\r\n1.程序分析：同29例\r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]long #ge,shi,qian,wan,x;\r\n\t#scanf(#[Fields]\"%ld\"#,&x);\r\n\t#wan=x\/10000;\r\n\t#qian=x%10000\/1000;\r\n\t#shi=x%100\/10;\r\n\t#ge=x%10;\r\n\t#[Keywords]if #(ge==wan&&shi==qian)\/*个位等于万位并且十位等于千位*\/\r\n\t#　 printf(#[Fields]\"#[Keywords]this# number is a huiwen\\n\"#);\r\n\t#else\r\n\t#　 printf(#[Fields]\"#[Keywords]this# number is not a huiwen\\n\"#);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        31,
        "【程序31】",
        "题目：请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。\r\n1.程序分析：用情况语句比较好，如果第一个字母一样，则判断用情况语句或if语句判断第二个字母。\r\n2.程序源代码：\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]char #letter ;\r\n    #printf(#[Fields]\"please input the first letter of someday\\n\"#);\r\n    #\/*当所按字母为Y时才结束*\/\r\n   #[Keywords] while#((letter=getch())!=#[Fields]'Y'#)\r\n    #{\r\n        #switch(letter)\r\n        #{\r\n            #[Keywords]case ##[Fields]'S'# :\r\n            #printf(#[Fields]\"please input second letter\\n\"#);\r\n            #　 #[Keywords]if#((letter=getch())==#[Fields]'a'#)\r\n            #　 　 printf(#[Fields]\"saturday\\n\"#);\r\n            #　 　 #[Keywords]else #[Keywords]if#((letter=getch())==#[Fields]'u'#)\r\n            #　 　 　 　 printf(#[Fields]\"sunday\\n\"#);\r\n            #　 　 #[Keywords]else #printf(#[Fields]\"data error\\n\"#);\r\n            #　 　 　 　 #[Keywords]break# ;\r\n            #[Keywords]case ##[Fields]'F'# :\r\n            #printf(#[Fields]\"friday\\n\"#);\r\n            #[Keywords]break# ;\r\n            #[Keywords]case ##[Fields]'M'# :\r\n            #printf(#[Fields]\"monday\\n\"#);\r\n            #[Keywords]break# ;\r\n            #[Keywords]case ##[Fields]'T'# :\r\n            #printf(#[Fields]\"please input second letter\\n\"#);\r\n            #　 　 #[Keywords]if#((letter=getch())==#[Fields]'u'#)\r\n            #　 　 　 　 printf(#[Fields]\"tuesday\\n\"#);\r\n            #　 　 #[Keywords]else #[Keywords]if#((letter=getch())==#[Fields]'h'#)\r\n            #　 　 　 　 printf(#[Fields]\"thursday\\n\"#);\r\n            #　 　 #[Keywords]else #printf(#[Fields]\"data error\\n\"#);\r\n            #　 　 　 　 #[Keywords]break# ;\r\n            #[Keywords]case ##[Fields]'W'# :\r\n            #printf(#[Fields]\"wednesday\\n\"#);\r\n            #[Keywords]break# ;\r\n            #default :\r\n            #printf(#[Fields]\"data error\\n\"#);\r\n        #}\r\n    #}\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        32,
        "【程序32】",
        "题目：Press any key to change color, do you want to try it. Please hurry up!\r\n1.程序分析：　　　　　　　　　　　　\r\n2.程序源代码：\r\n[code=java]\r\n#include <conio.h>\r\n#[Keywords]void #main(void)\r\n{\r\n    #[Keywords]int #color ;\r\n    #[Keywords]for#(color=0;color<8;color++)　\r\n    #{\r\n        #textbackground(color);\r\n        #\/*设置文本的背景颜色*\/\r\n        #cprintf(#[Fields]\"This is color %d\\r\\n\"#,color);\r\n        #cprintf(#[Fields]\"Press any key to #[Keywords]continue#\\r\\n\"#);\r\n        #getch();\r\n        #\/*输入字符看不见*\/\r\n        #　\r\n    #}\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        33,
        "【程序33】",
        "题目：学习gotoxy()与clrscr()函数　　　\r\n1.程序分析：\r\n2.程序源代码：\r\n[code=java]\r\n#include <conio.h>\r\n#[Keywords]void #main(void)\r\n{\r\n\t#clrscr();\/*清屏函数*\/\r\n\t#textbackground(2);\r\n\t#gotoxy(1, 5);\/*定位函数*\/\r\n\t#cprintf(#[Fields]\"Output at row 5 column 1\\n\"#);\r\n\t#textbackground(3);\r\n\t#gotoxy(20, 10);\r\n\t#cprintf(#[Fields]\"Output at row 10 column 20\\n\"#);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        34,
        "【程序34】",
        "题目：练习函数调用\r\n程序源代码：\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]void #hello_world(void)\r\n{\r\n\t#printf(#[Fields]\"Hello, world!\\n\"#);\r\n#}\r\n#[Keywords]void #three_hellos(void)\r\n{\r\n\t#[Keywords]int #counter;\r\n\t#[Keywords]for #(counter = 1; counter <= 3; counter++)\r\n\t\t#hello_world();\/*调用此函数*\/\r\n#}\r\n#[Keywords]void #main(void)\r\n{\r\n\t#three_hellos();\/*调用此函数*\/\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        35,
        "【程序35】",
        "题目：文本颜色设置\r\n程序源代码：\r\n[code=java]\r\n#include <conio.h>\r\n#[Keywords]void #main(void)\r\n{\r\n\t#[Keywords]int #color;\r\n\t#[Keywords]for #(color = 1; color < 16; color++)\r\n\t#　 {\r\n\t\t#　 textcolor(color);\/*设置文本颜色*\/\r\n\t\t#　 cprintf(#[Fields]\"This is color %d\\r\\n\"#, color);\r\n\t#　 #}\r\n\t#textcolor(128 + 15);\r\n\t#cprintf(#[Fields]\"This is blinking\\r\\n\"#);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        36,
        "【程序36】",
        "题目：求100之内的素数　　　\r\n程序源代码：\r\n[code=java]\r\n#include <stdio.h>\r\n#include #[Fields]\"math.h\"#\r\n#define N 101\r\nmain()\r\n{\r\n\t#[Keywords]int #i,j,line,a[N];\r\n\t#[Keywords]for#(i=2;i<N;i++) a[i]=i;\r\n\t#[Keywords]for#(i=2;i<sqrt(N);i++)\r\n\t#　 #[Keywords]for#(j=i+1;j<N;j++)\r\n\t#　 {\r\n\t#　　\t#[Keywords]if#(a[i]!=0&&a[j]!=0)\r\n\t#　　 \t#[Keywords]if#(a[j]%a[i]==0)\r\n\t#　　\ta[j]=0;\r\n\t\t#}\r\n\t#printf(#[Fields]\"\\n\"#);\r\n\t#[Keywords]for#(i=2,line=0;i<N;i++)\r\n\t#{\r\n\t#　 #[Keywords]if#(a[i]!=0)\r\n\t#　 {\r\n\t\t\t#printf(#[Fields]\"%5d\"#,a[i]);\r\n\t#　 \t\tline++;\r\n\t\t#}\r\n\t#　 #[Keywords]if#(line==10)\r\n\t#　 {\r\n\t\t\t#printf(#[Fields]\"\\n\"#);\r\n\t\t\t#line=0;\r\n\t\t#}\r\n\t#}\r\n#}\r\n[\/code]\r\n",
        8,
        111,
        1
      ],
      [
        37,
        "【程序37】",
        "题目：对10个数进行排序\r\n1.程序分析：可以利用选择法，即从后9个比较过程中，选择一个最小的与第一个元素交换，下次类推，即用第二个元素与后8个进行比较，并进行交换。 　　　　　　 \r\n2.程序源代码：\r\n[code=java]\r\n#define N 10\r\nmain()\r\n{\r\n\t#[Keywords]int #i,j,min,tem,a[N];\r\n\t#\/*input data*\/\r\n\t#printf(#[Fields]\"please input ten num:\\n\"#);\r\n\t#[Keywords]for#(i=0;i<N;i++)\r\n\t#{\r\n\t\t#printf(#[Fields]\"a[%d]=\"#,i);\r\n\t\t#scanf(#[Fields]\"%d\"#,&a[i]);\r\n\t#}\r\n\t#printf(#[Fields]\"\\n\"#);\r\n\t#[Keywords]for#(i=0;i<N;i++)\r\n\t\t#printf(#[Fields]\"%5d\"#,a[i]);\r\n\t#printf(#[Fields]\"\\n\"#);\r\n\t#\/*sort ten num*\/\r\n\t#[Keywords]for#(i=0;i<N-1;i++)\r\n\t#{\r\n\t\t#min=i;\r\n\t\t#[Keywords]for#(j=i+1;j<N;j++)\r\n\t\t\t#[Keywords]if#(a[min]>a[j]) min=j;\r\n\t\t#tem=a[i];\r\n\t\t#a[i]=a[min];\r\n\t\t#a[min]=tem;\r\n\t#}\r\n\t#\/*output data*\/\r\n\t#printf(#[Fields]\"After sorted \\n\"#);\r\n\t#[Keywords]for#(i=0;i<N;i++)\r\n\t\t#printf(#[Fields]\"%5d\"#,a[i]);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        38,
        "【程序38】",
        "题目：求一个3*3矩阵对角线元素之和 \r\n1.程序分析：利用双重for循环控制输入二维数组，再将a[i][i]累加后输出。\r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]float #a[3][3],sum=0;\r\n\t#[Keywords]int #i,j;\r\n\t#printf(#[Fields]\"please input rectangle element:\\n\"#);\r\n\t#[Keywords]for#(i=0;i<3;i++)\r\n\t#　 #[Keywords]for#(j=0;j<3;j++)\r\n\t#　 scanf(#[Fields]\"%f\"#,&a[i][j]);\r\n\t#[Keywords]for#(i=0;i<3;i++)\r\n\t#　 sum=sum+a[i][i];\r\n\t#printf(#[Fields]\"duijiaoxian he is %6.2f\"#,sum);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        39,
        "【程序39】",
        "题目：有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。\r\n1.程序分析：首先判断此数是否大于最后一个数，然后再考虑插入中间的数的情况，插入后此元素之后的数，依次后移一个位置。 \r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]int #a[11]={1,4,6,9,13,16,19,28,40,100#};\r\n\t#[Keywords]int #temp1,temp2,number,end,i,j;\r\n\t#printf(#[Fields]\"original array is:\\n\"#);\r\n\t#[Keywords]for#(i=0;i<10;i++)\r\n\t#　 printf(#[Fields]\"%5d\"#,a[i]);\r\n\t#printf(#[Fields]\"\\n\"#);\r\n\t#printf(#[Fields]\"insert a #[Keywords]new #number:\"#);\r\n\t#scanf(#[Fields]\"%d\"#,&number);\r\n\t#end=a[9];\r\n\t#[Keywords]if#(number>end)\r\n\t#　  a[10]=number;\r\n\t#else\r\n\t#　 {#[Keywords]for#(i=0;i<10;i++)\r\n\t#　　 {\r\n\t\t\t#[Keywords]if#(a[i]>number)\r\n\t#　　　 \t{\r\n\t\t\t\t#temp1=a[i];\r\n\t#　　　　\ta[i]=number;\r\n\t#　　　\t\t#[Keywords]for#(j=i+1;j<11;j++)\r\n\t#　　　 \t\t{\r\n\t\t\t\t\t#temp2=a[j];\r\n\t#　　　　 \t\ta[j]=temp1;\r\n\t#　　　　 \t\ttemp1=temp2;\r\n\t#　　　 \t\t#}\r\n\t#　　　 \t\t#[Keywords]break#;\r\n\t#　　　\t#}\r\n\t#　　 #}\r\n\t#}\r\n\t#[Keywords]for#(i=0;i<11;i++)\r\n\t#　 printf(#[Fields]\"%6d\"#,a[i]);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        40,
        "【程序40】",
        "题目：将一个数组逆序输出。\r\n1.程序分析：用第一个与最后一个交换。\r\n2.程序源代码：\r\n[code=java]\r\n#define N 5\r\nmain()\r\n{ \r\n\t#[Keywords]int #a[N]={9,6,5,4,1#},i,temp;\r\n　\tprintf(#[Fields]\"\\n original array:\\n\"#);\r\n　\t#[Keywords]for#(i=0;i<N;i++)\r\n　 \t\tprintf(#[Fields]\"%4d\"#,a[i]);\r\n　  #[Keywords]for#(i=0;i<N\/2;i++)\r\n　  {\r\n\t\t#temp=a[i];\r\n　　 \ta[i]=a[N-i-1];\r\n　　 \ta[N-i-1]=temp;\r\n　  #}\r\n\t#printf(#[Fields]\"\\n sorted array:\\n\"#);\r\n\t#[Keywords]for#(i=0;i<N;i++)\r\n　\t\tprintf(#[Fields]\"%4d\"#,a[i]);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        41,
        "【程序41】",
        "题目：学习static定义静态变量的用法　　　\r\n程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nvarfunc()\r\n{\r\n\t#[Keywords]int #var=0;\r\n\t#[Keywords]static #[Keywords]int #static_var=0;\r\n\t#printf(#[Fields]\"\\40:var equal %d \\n\"#,var);\r\n\t#printf(#[Fields]\"\\40:#[Keywords]static #var equal %d \\n\"#,static_var);\r\n\t#printf(#[Fields]\"\\n\"#);\r\n\t#var++;\r\n\t#static_var++;\r\n#}\r\n#[Keywords]void #main()\r\n{\r\n\t#[Keywords]int #i;\r\n　  #[Keywords]for#(i=0;i<3;i++)\r\n　　   varfunc();\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        42,
        "【程序42】",
        "题目：学习使用auto定义变量的用法\r\n程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n\t#[Keywords]int #i,num;\r\n\t#num=2;\r\n　 #[Keywords]for #(i=0;i<3;i++)\r\n　 { \r\n\t\t#printf(#[Fields]\"\\40: The num equal %d \\n\"#,num);\r\n　　 \tnum++;\r\n　　 \t{\r\n\t#　　 \tauto #[Keywords]int #num=1;\r\n\t#　　 \tprintf(#[Fields]\"\\40: The internal block num equal %d \\n\"#,num);\r\n\t#　　 \tnum++;\r\n　　\t#}\r\n　 #}\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        43,
        "【程序43】",
        "题目：学习使用static的另一用法。　　　\r\n程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n\t#[Keywords]int #i,num;\r\n\t#num=2;\r\n\t#[Keywords]for#(i=0;i<3;i++)\r\n\t#{\r\n\t\t#printf(#[Fields]\"\\40: The num equal %d \\n\"#,num);\r\n\t\t#num++;\r\n\t\t#{\r\n\t\t\t#[Keywords]static #[Keywords]int #num=1;\r\n\t\t\t#printf(#[Fields]\"\\40:The internal block num equal %d\\n\"#,num);\r\n\t\t\t#num++;\r\n\t\t#}\r\n\t#}\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        44,
        "【程序44】",
        "题目：学习使用external的用法。\r\n程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\n#[Keywords]int #a,b,c;\r\n#[Keywords]void #add()\r\n{ \r\n\t#[Keywords]int #a;\r\n\t#a=3;\r\n\t#c=a+b;\r\n#}\r\n#[Keywords]void #main()\r\n{ \r\n\t#a=b=4;\r\n\t#add();\r\n\t#printf(#[Fields]\"The value of c is equal to %d\\n\"#,c);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        45,
        "【程序45】",
        "题目：学习使用register定义变量的方法。\r\n1.程序分析：\r\n2.程序源代码：\r\n[code=java]\r\n#[Keywords]void #main()\r\n{\r\n\t#register #[Keywords]int #i;\r\n\t#[Keywords]int #tmp=0;\r\n\t#[Keywords]for#(i=1;i<=100;i++)\r\n\t\t#tmp+=i;\r\n\t#printf(#[Fields]\"The sum is %d\\n\"#,tmp);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        46,
        "【程序46】",
        "题目：宏#define命令练习(1)　　　\r\n程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\n#define TRUE 1\r\n#define FALSE 0\r\n#define SQ(x) (x)*(x)\r\n#[Keywords]void #main()\r\n{\r\n\t#[Keywords]int #num;\r\n\t#[Keywords]int #again=1;\r\n\t#printf(#[Fields]\"\\40: Program will stop #[Keywords]if #input value less than 50.\\n\"#);\r\n\t#[Keywords]while#(again)\r\n\t#{\r\n\t\t#printf(#[Fields]\"\\40:Please input number==>\"#);\r\n\t\t#scanf(#[Fields]\"%d\"#,&num);\r\n\t\t#printf(#[Fields]\"\\40:The square #[Keywords]for #[Keywords]this# number is %d \\n\"#,SQ(num));\r\n\t\t#[Keywords]if#(num>=50)\r\n\t\t#　 again=TRUE;\r\n\t\t#else\r\n\t\t#　 again=FALSE;\r\n\t#}\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        47,
        "【程序47】",
        "题目：宏#define命令练习(2)\r\n程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\n#define exchange(a,b) { \r\n\t#\/*宏定义中允许包含两道衣裳命令的情形，此时必须在最右边加上#[Fields]\"\\\"#*\/\r\n\t#[Keywords]int #t;\r\n\t#t=a;\r\n\t#a=b;\r\n\t#b=t;\r\n#}\r\n#[Keywords]void #main(void)\r\n{\r\n\t#[Keywords]int #x=10;\r\n\t#[Keywords]int #y=20;\r\n\t#printf(#[Fields]\"x=%d; y=%d\\n\"#,x,y);\r\n\t#exchange(x,y);\r\n\t#printf(#[Fields]\"x=%d; y=%d\\n\"#,x,y);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        48,
        "【程序48】",
        "题目：宏#define命令练习(3)　　　\r\n程序源代码：\r\n[code=java]\r\n#define LAG >\r\n#define SMA <\r\n#define EQ ==\r\n#include #[Fields]\"stdio.h\"#\r\n#[Keywords]void #main()\r\n{ \r\n\t#[Keywords]int #i=10;\r\n\t#[Keywords]int #j=20;\r\n\t#[Keywords]if#(i LAG j)\r\n\t\t#printf(#[Fields]\"\\40: %d larger than %d \\n\"#,i,j);\r\n\t#[Keywords]else #[Keywords]if#(i EQ j)\r\n\t\t#printf(#[Fields]\"\\40: %d equal to %d \\n\"#,i,j);\r\n\t#[Keywords]else #[Keywords]if#(i SMA j)\r\n\t\t#printf(#[Fields]\"\\40:%d smaller than %d \\n\"#,i,j);\r\n\t#else\r\n\t\t#printf(#[Fields]\"\\40: No such value.\\n\"#);\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        49,
        "【程序49】",
        "题目：#if #ifdef和#ifndef的综合应用。\r\n程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\n#define MAX\r\n#define MAXIMUM(x,y) (x>y)?x:y\r\n#define MINIMUM(x,y) (x>y)?y:x\r\n#[Keywords]void #main()\r\n{ \r\n\t#[Keywords]int #a=10,b=20;\r\n\t#ifdef MAX\r\n\t\t#printf(#[Fields]\"\\40: The larger one is %d\\n\"#,MAXIMUM(a,b));\r\n\t#else\r\n\t\t#printf(#[Fields]\"\\40: The lower one is %d\\n\"#,MINIMUM(a,b));\r\n\t#endif\r\n\t#ifndef MIN\r\n\t\t#printf(#[Fields]\"\\40: The lower one is %d\\n\"#,MINIMUM(a,b));\r\n\t#else\r\n\t\t#printf(#[Fields]\"\\40: The larger one is %d\\n\"#,MAXIMUM(a,b));\r\n\t#endif\r\n\t#undef MAX\r\n\t#ifdef MAX\r\n\t\t#printf(#[Fields]\"\\40: The larger one is %d\\n\"#,MAXIMUM(a,b));\r\n\t#else\r\n\t\t#printf(#[Fields]\"\\40: The lower one is %d\\n\"#,MINIMUM(a,b));\r\n\t#endif\r\n\t#define MIN\r\n\t#ifndef MIN\r\n\t\t#printf(#[Fields]\"\\40: The lower one is %d\\n\"#,MINIMUM(a,b));\r\n\t#else\r\n\t\t#printf(#[Fields]\"\\40: The larger one is %d\\n\"#,MAXIMUM(a,b));\r\n\t#endif\r\n#}\r\n[\/code]",
        8,
        111,
        1
      ],
      [
        50,
        "【程序50】",
        "题目：#include 的应用练习　　　\r\n程序源代码：\r\ntest.h 文件如下：\r\n[code=java]\r\n#define LAG >\r\n#define SMA <\r\n#define EQ ==\r\n#include #[Fields]\"test.h\"# \/*一个新文件50.c，包含test.h*\/\r\n#include #[Fields]\"stdio.h\"#\r\n#[Keywords]void #main()\r\n{ \r\n\t#[Keywords]int #i=10;\r\n\t#[Keywords]int #j=20;\r\n\t#[Keywords]if#(i LAG j)\r\n\t\t#printf(#[Fields]\"\\40: %d larger than %d \\n\"#,i,j);\r\n\t#[Keywords]else #[Keywords]if#(i EQ j)\r\n\t\t#printf(#[Fields]\"\\40: %d equal to %d \\n\"#,i,j);\r\n\t#[Keywords]else #[Keywords]if#(i SMA j)\r\n\t\t#printf(#[Fields]\"\\40:%d smaller than %d \\n\"#,i,j);\r\n\t#else\r\n\t\t#printf(#[Fields]\"\\40: No such value.\\n\"#);\r\n#}\r\n[\/code]",
        0,
        111,
        1
      ],
      [
        51,
        "【程序51】",
        "题目：学习使用按位与 & 。　　　\r\n1.程序分析：0&0=0; 0&1=0; 1&0=0; 1&1=1\r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n    #[Keywords]int #a,b ;\r\n    #a=077 ;\r\n    #b=a&3 ;\r\n    #printf(#[Fields]\"\\40: The a & b(decimal) is %d \\n\"#,b);\r\n    #b&=7 ;\r\n    #printf(#[Fields]\"\\40: The a & b(decimal) is %d \\n\"#,b);\r\n#}\r\n[\/code]",
        0,
        111,
        1
      ],
      [
        52,
        "【程序52】",
        "题目：学习使用按位或 | 。\r\n1.程序分析：0|0=0; 0|1=1; 1|0=1; 1|1=1　　　　　　　　　　　　\r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n    #[Keywords]int #a,b ;\r\n    #a=077 ;\r\n    #b=a|3 ;\r\n    #printf(#[Fields]\"\\40: The a & b(decimal) is %d \\n\"#,b);\r\n    #b|=7 ;\r\n    #printf(#[Fields]\"\\40: The a & b(decimal) is %d \\n\"#,b);\r\n#}\r\n[\/code]",
        0,
        111,
        1
      ],
      [
        53,
        "【程序53】",
        "题目：学习使用按位异或 ^ 。　　　\r\n1.程序分析：0^0=0; 0^1=1; 1^0=1; 1^1=0\r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n    #[Keywords]int #a,b ;\r\n    #a=077 ;\r\n    #b=a^3 ;\r\n    #printf(#[Fields]\"\\40: The a & b(decimal) is %d \\n\"#,b);\r\n    #b^=7 ;\r\n    #printf(#[Fields]\"\\40: The a & b(decimal) is %d \\n\"#,b);\r\n#}\r\n[\/code]",
        0,
        111,
        1
      ],
      [
        54,
        "【程序54】",
        "题目：取一个整数a从右端开始的4～7位。\r\n程序分析：可以这样考虑： \r\n(1)先使a右移4位。\r\n(2)设置一个低4位全为1,其余全为0的数。可用~(~0<<4)\r\n(3)将上面二者进行&运算。\r\n2.程序源代码：\r\n[code=java]\r\nmain()\r\n{\r\n    #unsigned a,b,c,d ;\r\n    #scanf(#[Fields]\"%o\"#,&a);\r\n    #b=a>>4 ;\r\n    #c=~(~0<<4);\r\n    #d=b&c ;\r\n    #printf(#[Fields]\"%o\\n%o\\n\"#,a,d);\r\n#}\r\n[\/code]",
        0,
        111,
        1
      ],
      [
        55,
        "【程序55】",
        "题目：学习使用按位取反~。　　　\r\n1.程序分析：~0=1; ~1=0;\r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\nmain()\r\n{\r\n    #[Keywords]int #a,b ;\r\n    #a=234 ;\r\n    #b=~a ;\r\n    #printf(#[Fields]\"\\40: The a#[Fields]'s 1 complement(decimal) is %d \\n\"#,b);\r\n    #a=~a ;\r\n    #printf(#[Fields]\"\\40: The a#[Fields]'s 1 complement(hexidecimal) is %x \\n\"#,a);\r\n#}\r\n[\/code]",
        0,
        111,
        1
      ],
      [
        56,
        "【程序56】",
        "题目：画图，学用circle画圆形。　　　\r\n程序源代码：\r\n[code=java]\r\n\/*circle*\/\r\n#include #[Fields]\"graphics.h\"# \r\nmain()\r\n{\r\n    #[Keywords]int #driver,mode,i ;\r\n    #[Keywords]float #j=1,k=1 ;\r\n    #driver=VGA ;\r\n    #mode=VGAHI ;\r\n    #initgraph(&driver,&mode,#[Fields]\"\"#);\r\n    #setbkcolor(YELLOW);\r\n    #[Keywords]for#(i=0;i<=25;i++)\r\n    #{\r\n        #setcolor(8);\r\n        #circle(310,250,k);\r\n        #k=k+j ;\r\n        #j=j+0.3 ;\r\n    #}\r\n#}\r\n[\/code]",
        0,
        111,
        1
      ],
      [
        57,
        "【程序57】",
        "题目：画图，学用line画直线。\r\n程序源代码：\r\n[code=java]\r\n#include #[Fields]\"graphics.h\"#\r\nmain()\r\n{\r\n\t#[Keywords]int #driver,mode,i;\r\n\t#[Keywords]float #x0,y0,y1,x1;\r\n\t#[Keywords]float #j=12,k;\r\n\t#driver=VGA;mode=VGAHI;\r\n\t#initgraph(&driver,&mode,#[Fields]\"\"#);\r\n\t#setbkcolor(GREEN);\r\n\t#x0=263;y0=263;y1=275;x1=275;\r\n\t#[Keywords]for#(i=0;i<=18;i++)\r\n\t#{\r\n\t\t#setcolor(5);\r\n\t\t#line(x0,y0,x0,y1);\r\n\t\t#x0=x0-5;\r\n\t\t#y0=y0-5;\r\n\t\t#x1=x1+5;\r\n\t\t#y1=y1+5;\r\n\t\t#j=j+10;\r\n\t#}\r\n\t#x0=263;y1=275;y0=263;\r\n\t#[Keywords]for#(i=0;i<=20;i++)\r\n\t#{\r\n\t\t#setcolor(5);\r\n\t\t#line(x0,y0,x0,y1);\r\n\t\t#x0=x0+5;\r\n\t\t#y0=y0+5;\r\n\t\t#y1=y1-5;\r\n\t#}\r\n#}\r\n[\/code]",
        0,
        111,
        1
      ],
      [
        58,
        "【程序58】",
        "题目：画图，学用rectangle画方形。　　　\r\n1.程序分析：利用for循环控制100-999个数，每个数分解出个位，十位，百位。\r\n2.程序源代码：\r\n[code=java]\r\n#include #[Fields]\"graphics.h\"#\r\nmain()\r\n{\r\n\t#[Keywords]int #x0,y0,y1,x1,driver,mode,i;\r\n\t#driver=VGA;mode=VGAHI;\r\n\t#initgraph(&driver,&mode,#[Fields]\"\"#);\r\n\t#setbkcolor(YELLOW);\r\n\t#x0=263;y0=263;y1=275;x1=275;\r\n\t#[Keywords]for#(i=0;i<=18;i++)\r\n\t#{\r\n\t\t#setcolor(1);\r\n\t\t#rectangle(x0,y0,x1,y1);\r\n\t\t#x0=x0-5;\r\n\t\t#y0=y0-5;\r\n\t\t#x1=x1+5;\r\n\t\t#y1=y1+5;\r\n\t#}\r\n\t#settextstyle(DEFAULT_FONT,HORIZ_DIR,2);\r\n\t#outtextxy(150,40,#[Fields]\"How beautiful it is!\"#);\r\n\t#line(130,60,480,60);\r\n\t#setcolor(2);\r\n\t#circle(269,269,137);\r\n#}\r\n[\/code]\r\n",
        0,
        111,
        1
      ],
      [
        59,
        "【程序59】",
        "题目：画图，综合例子。\r\n程序源代码：\r\n[code=java]\r\n\/*这份代码经源码格式软件格式化过\r\n     #yang_hx@neusoft.com      *\/\r\n# define PAI 3.1415926\r\n# define B 0.809\r\n# include #[Fields]\"graphics.h\"#\r\n# include #[Fields]\"math.h\"#\r\nmain()\r\n{\r\n    #[Keywords]int #i,j,k,x0,y0,x,y,driver,mode ;\r\n    #[Keywords]float #a ;\r\n    #driver=CGA ;\r\n    #mode=CGAC0 ;\r\n    #initgraph(&driver,&mode,#[Fields]\"\"#);\r\n    #setcolor(3);\r\n    #setbkcolor(GREEN);\r\n    #x0=150 ;\r\n    #y0=100 ;\r\n    #circle(x0,y0,10);\r\n    #circle(x0,y0,20);\r\n    #circle(x0,y0,50);\r\n    #[Keywords]for#(i=0;i<16;i++)\r\n    #{\r\n        #a=(2*PAI\/16)*i ;\r\n        #x=ceil(x0+48*cos(a));\r\n        #y=ceil(y0+48*sin(a)*B);\r\n        #setcolor(2);\r\n        #line(x0,y0,x,y);\r\n    #}\r\n    #setcolor(3);\r\n    #circle(x0,y0,60);\r\n    #\/* Make 0 time normal size letters *\/\r\n    #settextstyle(DEFAULT_FONT,HORIZ_DIR,0);\r\n    #outtextxy(10,170,#[Fields]\"press a key\"#);\r\n    #getch();\r\n    #setfillstyle(HATCH_FILL,YELLOW);\r\n    #floodfill(202,100,WHITE);\r\n    #getch();\r\n    #[Keywords]for#(k=0;k<=500;k++)\r\n    #{\r\n        #setcolor(3);\r\n        #[Keywords]for#(i=0;i<=16;i++)\r\n        #{\r\n            #a=(2*PAI\/16)*i+(2*PAI\/180)*k ;\r\n            #x=ceil(x0+48*cos(a));\r\n            #y=ceil(y0+48+sin(a)*B);\r\n            #setcolor(2);\r\n            #line(x0,y0,x,y);\r\n            #　\r\n        #}\r\n        #[Keywords]for#(j=1;j<=50;j++) \r\n        #{\r\n            #a=(2*PAI\/16)*i+(2*PAI\/180)*k-1 ;\r\n            #x=ceil(x0+48*cos(a));\r\n            #y=ceil(y0+48*sin(a)*B);\r\n            #line(x0,y0,x,y);  　\r\n        #}\r\n    #}\r\n    #restorecrtmode();\r\n#}\r\n[\/code]",
        0,
        111,
        1
      ]
    ]
  },
  {
    "table" : "c_source",
    "columns" : [
      "id",
      "title",
      "content",
      "importance",
      "showFlag",
      "version"
    ],
    "data" : [
      [
        0,
        "基础篇",
        "",
        9,
        118,
        1
      ],
      [
        1,
        "第一个C程序",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/* The first C programme *\/\r\n#[Tags]\/* 包含标准输入输出头文件 *\/\r\n#[Tags]\/* 主函数 *\/\r\n#include<stdio.h>main()\r\n{\r\n    #printf(#[Fields]\"Hello World!\\n\"#);\r\n    #[Tags]\/* 打印输出信息 *\/\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        2,
        "运行多个源文件",
        "代码如下：\r\nprint.h\r\n[code=java]\r\n#include #[Fields]\"stdio.h\"#\r\n#[Keywords]void #printHello(void);\r\n[\/code]\r\nprint.c\r\n[code=java]\r\n#include #[Fields]\"print.h\"#\r\n#[Keywords]void #printHello()\r\n{\r\n\t#printf(#[Fields]\"hello word!\\n\"#);\r\n#}\r\n[\/code]\r\nhelloword.c\r\n[code=java]\r\n#include #[Fields]\"print.h\"#\r\n#[Keywords]int #main(void){\r\n\t#printHello();\r\n\t#[Keywords]return #0;\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        3,
        "求整数之积",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/* Input two numbers, output the product *\/\r\n#include<stdio.h>\r\nmain()\r\n{\r\n    #[Keywords]int #x,y,m ;\r\n    #\/* 定义整型变量x，y，m *\/\r\n    #printf(#[Fields]\"Please input x and y\\n\"#);\r\n    #\/* 输出提示信息 *\/\r\n    #scanf(#[Fields]\"%d%d\"#,&x,&y);\r\n    #\/* 读入两个乘数，赋给x，y变量 *\/\r\n    #m=x*y ;\r\n    #\/* 计算两个乘数的积，赋给变量m *\/\r\n    #printf(#[Fields]\"%d * %d = %d\\n\"#,x,y,m);\r\n    #\/* 输出结果 *\/\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        4,
        "比较实数大小",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/* 输入两个浮点数，输出它们中的大数 *\/\r\n#include<stdio.h>\r\nmain()\r\n{\r\n    #[Keywords]float #x,y,c ;\r\n    #\/* 变量定义 *\/\r\n    #printf(#[Fields]\"Please input x and y:\\n\"#);\r\n    #\/* 提示用户输入数据 *\/\r\n    #scanf(#[Fields]\"%f%f\"#,&x,&y);\r\n    #c=x>y?x:y ;\r\n    #\/* 计算c=max(x,y) *\/\r\n    #printf(#[Fields]\"MAX of (%f,%f) is %f\"#,x,y,c);\r\n    #\/* 输出c *\/\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        5,
        "字符的输出",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\nmain()\r\n{\r\n    #[Keywords]char #ch,nch ;\r\n    #[Keywords]int #count ;\r\n    #[Keywords]int #k ;\r\n    #printf(#[Fields]\"Please input a string with a # in the end.\\n\"#);\r\n    #scanf(#[Fields]\"%c\"#,&ch);\r\n   #[Keywords] while#(ch!=#[Fields]'#'#)\r\n    #{\r\n        #[Keywords]if#(ch>=#[Fields]'0'#&&ch<=#[Fields]'9'#)\r\n        #{\r\n            #count=ch-#[Fields]'0'#+1 ;\r\n            #scanf(#[Fields]\"%c\"#,&nch);\r\n            #[Keywords]for#(k=0;k<count;k++)printf(#[Fields]\"%c\"#,nch);\r\n        #}\r\n        #[Keywords]else #\r\n        #printf(#[Fields]\"%c\"#,ch);\r\n        #printf(#[Fields]\" \"#);\r\n        #scanf(#[Fields]\"%c\"#,&ch);\r\n    #}\r\n    #printf(#[Fields]\"#\\n\"#);\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        6,
        "显示变量所占字节数",
        "代码如下：\r\n[code=java]\r\n\/* 输出不同类型所占的字节数*\/\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Tags]\/* sizeof()是保留字，它的作用是求某类型或某变量类型的字节数, *\/\r\n    #[Tags]\/* 括号中可以是类型保留字或变量。*\/\r\n    #[Tags]\/*int型在不同的机器，不同的编译器中的字节数不一样,*\/\r\n    #[Tags]\/*一般来说在TC2.0编译器中字节数为2,在VC编译器中字节数为4 *\/\r\n    #printf(#[Fields]\"The bytes of the variables are:\\n\"#);\r\n    #printf(#[Fields]\"int:%d bytes\\n\"#,sizeof(#[Keywords]int#));\r\n    #[Tags]\/* char型的字节数为1 *\/\r\n    #printf(#[Fields]\"char:%d byte\\n\"#,sizeof(char));\r\n    #[Tags]\/* short型的字节数为2 *\/\r\n    #printf(#[Fields]\"short:%d bytes\\n\"#,sizeof(short));\r\n    #[Tags]\/* long型的字节数为4 *\/\r\n    #printf(#[Fields]\"long:%d bytes\\n\"#,sizeof(#[Keywords]long#));\r\n    #[Tags]\/* float型的字节数为4 *\/\r\n    #printf(#[Fields]\"float:%d bytes\\n\"#,sizeof(#[Keywords]float#));\r\n    #[Tags]\/* double型的字节数为8 *\/\r\n    #printf(#[Fields]\"double:%d bytes\\n\"#,sizeof(double));\r\n    #[Tags]\/* #[Keywords]long #double型的字节数为8或10或12 *\/\r\n    #printf(#[Fields]\"#[Keywords]long #double:%d bytes\\n\"#,sizeof(#[Keywords]long #double));\r\n    #getchar();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        7,
        "自增自减运算",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\nmain()\r\n{\r\n\t#[Keywords]int #a=5,b,c,i=10;\r\n\t#b=a++;\r\n\t#c=++b;\r\n\t#printf(#[Fields]\"a = %d, b = %d, c = %d\\n\"#,a,b,c);\r\n\t#printf(#[Fields]\"i,i++,i++ = %d,%d,%d\\n\"#,i,i++,i++);\r\n\t#printf(#[Fields]\"%d\\n\"#,++i);\r\n\t#printf(#[Fields]\"%d\\n\"#,--i);\r\n\t#printf(#[Fields]\"%d\\n\"#,i++);\r\n\t#printf(#[Fields]\"%d\\n\"#,i--);\r\n\t#printf(#[Fields]\"%d\\n\"#,-i++);\r\n\t#printf(#[Fields]\"%d\\n\"#,-i--);\r\n\t#getchar();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        8,
        "数列求和",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\nmain()\r\n{\r\n\t#[Keywords]int #i,j,n;\r\n\t#[Keywords]long #sum=0,temp=0;\r\n\t#printf(#[Fields]\"Please input a number to n:\\n\"#);\r\n\t#scanf(#[Fields]\"%d\"#,&n);\r\n\t#[Keywords]if#(n<1)\r\n\t#{\r\n\t\t#printf(#[Fields]\"The n must no less than 1!\\n\"#);\r\n\t\t#[Keywords]return#;#\r\n\t#}\r\n\t#[Keywords]for#(i=1;i<=n;i++)\r\n\t#{\r\n\t\t#temp=0;\r\n\t\t#[Keywords]for#(j=1;j<=i;j++)\r\n\t\t\t#temp+=j;\r\n\t\t#sum+=temp;\r\n\t#}\r\n\t#printf(#[Fields]\"The sum of the sequence(%d) is %d\\n\"#,n,sum);\r\n\t#getchar();\r\n\t#getchar();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        9,
        "乘法口诀表",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#include <conio.h>\r\n#[Keywords]void #main(void)\r\n{\r\n\t#[Keywords]int #i,j,x,y;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"\\n\\n        * * * 乘法口诀表 * * * \\n\\n\"#);\r\n\t#x=9;\r\n\t#y=5;\r\n\t#[Keywords]for#(i=1;i<=9;i++)\r\n\t#{\r\n\t\t#gotoxy(x,y);\r\n\t\t#printf(#[Fields]\"%2d \"#,i);\r\n\t\t#x+=3;\r\n\t#}\r\n\t#x=7;\r\n\t#y=6;\r\n\t#[Keywords]for#(i=1;i<=9;i++)\r\n\t#{\r\n\t\t#gotoxy(x,y);\r\n\t\t#printf(#[Fields]\"%2d \"#,i);\r\n\t\t#y++;\r\n\t#}\r\n\t#x=9;\r\n\t#y= 6;\r\n\t#[Keywords]for#(i=1;i<=9;i++)\r\n\t#{\r\n\t\t#[Keywords]for#(j=1;j<=9;j++)\r\n\t\t#{\r\n\t\t\t#gotoxy(x,y);\r\n\t\t\t#printf(#[Fields]\"%2d \"#,i*j);\r\n\t\t\t#y++;\r\n\t\t#}\r\n\t\t#y-=9;\r\n\t\t#x+=3;\r\n\t#}\r\n\t#printf(#[Fields]\"\\n\\n\"#);\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        10,
        "猜数字游戏",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#include <conio.h>\r\n#[Keywords]void #main()\r\n{\r\n\t#[Keywords]int #Password=0,Number=0,price=58,i=0;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"\\n====This is a Number Guess Game!====\\n\"#);\r\n\t#[Keywords]while#( Password != 1234 )\r\n\t#{\r\n\t\t#[Keywords]if#( i >= 3 )\r\n\t\t\t#[Keywords]return#;#\r\n\t\t#i++;\r\n\t\t#puts(#[Fields]\"Please input Password: \"#);\r\n\t\t#scanf(#[Fields]\"%d\"#,&Password);\r\n\t#}\r\n\t#i=0;\r\n\t#[Keywords]while#( Number!=price )\r\n\t#{\r\n\t\t#do{\r\n\t\t\t#puts(#[Fields]\"Please input a number between 1 and 100: \"#);\r\n\t\t\t#scanf(#[Fields]\"%d\"#,&Number);\r\n\t\t\t#printf(#[Fields]\"Your input number is %d\\n\"#,Number);\r\n\t\t#}#[Keywords]while#( !(Number>=1 && Number<=100) );\r\n\t\t#[Keywords]if#( Number >= 90 )\r\n\t\t#{\r\n\t\t\t#printf(#[Fields]\"Too Bigger! Press any key to #[Keywords]try #again!\\n\"#);\r\n\t\t#}\r\n\t\t#[Keywords]else #[Keywords]if#( Number >= 70 && Number < 90 )\r\n\t\t#{\r\n\t\t\t#printf(#[Fields]\"Bigger!\\n\"#);\r\n\t\t#}\r\n\t\t#[Keywords]else #[Keywords]if#( Number >= 1 && Number <= 30 )\r\n\t\t#{\r\n\t\t\t#printf(#[Fields]\"Too Small! Press any key to #[Keywords]try #again!\\n\"#);\r\n\t\t#}\r\n\t\t#[Keywords]else #[Keywords]if#( Number > 30 && Number <= 50 )\r\n\t\t#{\r\n\t\t\t#printf(#[Fields]\"Small! Press any key to #[Keywords]try #again!\\n\"#);\r\n\t\t#}\r\n\t\t#else\r\n\t\t#{\r\n\t\t\t#[Keywords]if#( Number == price )\r\n\t\t\t#{\r\n\t\t\t\t#printf(#[Fields]\"OK! You are right! Bye Bye!\\n\"#);\r\n\t\t\t#}\r\n\t\t\t#[Keywords]else #[Keywords]if#( Number < price )\r\n\t\t\t#{\r\n\t\t\t\t#printf(#[Fields]\"Sorry,Only a little smaller! Press any key to #[Keywords]try #again!\\n\"#);\r\n\r\n\t\t\t#}\r\n\t\t\t#[Keywords]else #[Keywords]if#( Number > price )\r\n\t\t\t\t#printf(#[Fields]\" Sorry, Only a little bigger! Press any key to #[Keywords]try #again!\\n\"#);\r\n\t\t#}\r\n\t\t#getch();\r\n\t#}\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        11,
        "模拟ATM（自动柜员机）界面",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n\t#[Keywords]int #Password=0,Number=0,price=58,i=0;\r\n\r\n\t#[Keywords]while#( Password != 1234 )\r\n\t#{\r\n\t\t#[Keywords]if#( i >= 3 )\r\n\t\t\t#[Keywords]return#;#\r\n\t\t#i++;\r\n\t\t#puts(#[Fields]\"Please input Password: \"#);\r\n\t\t#scanf(#[Fields]\"%d\"#,&Password);\r\n\t#}\r\n\t#i=0;\r\n\t#[Keywords]while#( Number!=price )\r\n\t#{\r\n\t\t#do{\r\n\t\t\t#puts(#[Fields]\"Please input a number between 1 and 100: \"#);\r\n\t\t\t#scanf(#[Fields]\"%d\"#,&Number);\r\n\t\t\t#printf(#[Fields]\"Your input number is %d\\n\"#,Number);\r\n\t\t#}#[Keywords]while#( !(Number>=1 && Number<=100) );\r\n\t\t#[Keywords]if#( Number >= 90 )\r\n\t\t#{\r\n\t\t\t#printf(#[Fields]\"Too Bigger! Press any key to #[Keywords]try #again!\\n\"#);\r\n\t\t#}\r\n\t\t#[Keywords]else #[Keywords]if#( Number >= 70 && Number < 90 )\r\n\t\t#{\r\n\t\t\t#printf(#[Fields]\"Bigger!\\n\"#);\r\n\t\t#}\r\n\t\t#[Keywords]else #[Keywords]if#( Number >= 1 && Number <= 30 )\r\n\t\t#{\r\n\t\t\t#printf(#[Fields]\"Too Small! Press any key to #[Keywords]try #again!\\n\"#);\r\n\t\t#}\r\n\t\t#[Keywords]else #[Keywords]if#( Number > 30 && Number <= 50 )\r\n\t\t#{\r\n\t\t\t#printf(#[Fields]\"Small! Press any key to #[Keywords]try #again!\\n\"#);\r\n\t\t#}\r\n\t\t#else\r\n\t\t#{\r\n\t\t\t#[Keywords]if#( Number == price )\r\n\t\t\t#{\r\n\t\t\t\t#printf(#[Fields]\"OK! You are right! Bye Bye!\\n\"#);\r\n\t\t\t#}\r\n\t\t\t#[Keywords]else #[Keywords]if#( Number < price )\r\n\t\t\t#{\r\n\t\t\t\t#printf(#[Fields]\"Sorry,Only a little smaller! Press any key to #[Keywords]try #again!\\n\"#);\r\n\r\n\t\t\t#}\r\n\t\t\t#[Keywords]else #[Keywords]if#( Number > price )\r\n\t\t\t\t#printf(#[Fields]\" Sorry, Only a little bigger! Press any key to #[Keywords]try #again!\\n\"#);\r\n\t\t#}\r\n\t\t#getch();\r\n\t#}\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        12,
        "用一维数组统计学生成绩",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n\t#[Keywords]char #SelectKey,CreditMoney,DebitMoney;\r\n\t#[Keywords]while#(1)\r\n\t#{\r\n\t\t#do{\r\n\t\t\t#clrscr();\r\n\t\t\t#puts(#[Fields]\"=========================\"#);\r\n\t\t\t#puts(#[Fields]\"|  Please select key:   |\"#);\r\n\t\t\t#puts(#[Fields]\"|  1. Quary             |\"#);\r\n\t\t\t#puts(#[Fields]\"|  2. Credit            |\"#);\r\n\t\t\t#puts(#[Fields]\"|  3. Debit             |\"#);\r\n\t\t\t#puts(#[Fields]\"|  4. Return            |\"#);\r\n\t\t\t#puts(#[Fields]\"=========================\"#);\r\n\t\t\t#SelectKey = getch();\r\n\t\t#}#[Keywords]while#( SelectKey!=#[Fields]'1'# && SelectKey!=#[Fields]'2'# && SelectKey!=#[Fields]'3'# && SelectKey!=#[Fields]'4'# );\r\n\t\t#switch(SelectKey)\r\n\t\t#{\r\n\t\t\t#[Keywords]case ##[Fields]'1'#:\r\n\t\t\t\t#clrscr();\r\n\t\t\t\t#puts(#[Fields]\"================================\"#);\r\n\t\t\t\t#puts(#[Fields]\"|    Your balance is $1000.    |\"#);\r\n\t\t\t\t#puts(#[Fields]\"|  Press any key to return...  |\"#);\r\n\t\t\t\t#puts(#[Fields]\"================================\"#);\r\n\t\t\t\t#getch();\r\n\t\t\t\t#[Keywords]break#;\r\n\t\t\t#[Keywords]case ##[Fields]'2'#:\r\n\t\t\t\t#do{\r\n\t\t\t\t\t#clrscr();\r\n\t\t\t\t\t#puts(#[Fields]\"==================================\"#);\r\n\t\t\t\t\t#puts(#[Fields]\"|   Please select Credit money:  |\"#);\r\n\t\t\t\t\t#puts(#[Fields]\"|   1. $50                       |\"#);\r\n\t\t\t\t\t#puts(#[Fields]\"|   2. $100                      |\"#);\r\n\t\t\t\t\t#puts(#[Fields]\"|   3. Return                    |\"#);\r\n\t\t\t\t\t#puts(#[Fields]\"==================================\"#);\r\n\t\t\t\t\t#CreditMoney = getch();\r\n\t\t\t\t#}#[Keywords]while#( CreditMoney!=#[Fields]'1'# && CreditMoney!=#[Fields]'2'# && CreditMoney!=#[Fields]'3'# );\r\n\t\t\t\t#switch(CreditMoney)\r\n\t\t\t\t#{\r\n\t\t\t\t\t#[Keywords]case ##[Fields]'1'#:\r\n\t\t\t\t\t\t#clrscr();\r\n\t\t\t\t\t\t#puts(#[Fields]\"=========================================\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"|  Your Credit money is $50,Thank you!  |\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"|         Press any key to return...    |\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"=========================================\"#);\r\n\t\t\t\t\t\t#getch();\r\n\t\t\t\t\t\t#[Keywords]break#;\r\n\t\t\t\t\t#[Keywords]case ##[Fields]'2'#:\r\n\t\t\t\t\t\t#clrscr();\r\n\t\t\t\t\t\t#puts(#[Fields]\"==========================================\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"|  Your Credit money is $100,Thank you!  |\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"|         Press any key to return...     |\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"==========================================\"#);\r\n\t\t\t\t\t\t#getch();\r\n\t\t\t\t\t\t#[Keywords]break#;\r\n\t\t\t\t\t#[Keywords]case ##[Fields]'3'#:\r\n\t\t\t\t\t\t#[Keywords]break#;\r\n\t\t\t\t#}\r\n\t\t\t\t#[Keywords]break#;\r\n\t\t\t#[Keywords]case ##[Fields]'3'#:\r\n\t\t\t\t#do{\r\n\t\t\t\t\t#clrscr();\r\n\t\t\t\t\t#puts(#[Fields]\"====================================\"#);\r\n\t\t\t\t\t#puts(#[Fields]\"|   Please select Debit money:     |\"#);\r\n\t\t\t\t\t#puts(#[Fields]\"|   1. $50                         |\"#);\r\n\t\t\t\t\t#puts(#[Fields]\"|   2. $100                        |\"#);\r\n\t\t\t\t\t#puts(#[Fields]\"|   3. $500                        |\"#);\r\n\t\t\t\t\t#puts(#[Fields]\"|   4. $1000                       |\"#);\r\n\t\t\t\t\t#puts(#[Fields]\"|   5. Return                      |\"#);\r\n\t\t\t\t\t#puts(#[Fields]\"====================================\"#);\r\n\t\t\t\t\t#DebitMoney = getch();\r\n\t\t\t\t#}#[Keywords]while#(\tDebitMoney!=#[Fields]'1'# && DebitMoney!=#[Fields]'2'# && DebitMoney!=#[Fields]'3'# \\\r\n\t\t\t\t #&& DebitMoney!=#[Fields]'4'# && DebitMoney!=#[Fields]'5'# );\r\n\t\t\t\t#switch(DebitMoney)\r\n\t\t\t\t#{\r\n\t\t\t\t\t#[Keywords]case ##[Fields]'1'#:\r\n\t\t\t\t\t\t#clrscr();\r\n\t\t\t\t\t\t#puts(#[Fields]\"===========================================\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"|   Your Debit money is $50,Thank you!    |\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"|        Press any key to return...       |\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"===========================================\"#);\r\n\t\t\t\t\t\t#getch();\r\n\t\t\t\t\t\t#[Keywords]break#;\r\n\t\t\t\t\t#[Keywords]case ##[Fields]'2'#:\r\n\t\t\t\t\t\t#clrscr();\r\n \t\t\t\t\t\t#puts(#[Fields]\"===========================================\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"|   Your Debit money is $100,Thank you!   |\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"|        Press any key to return...       |\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"===========================================\"#);\r\n\t\t\t\t\t\t#getch();\r\n\t\t\t\t\t\t#[Keywords]break#;\r\n\t\t\t\t\t#[Keywords]case ##[Fields]'3'#:\r\n\t\t\t\t\t\t#clrscr();\r\n\t\t\t\t\t\t#puts(#[Fields]\"===========================================\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"|   Your Debit money is $500,Thank you!   |\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"|        Press any key to return...       |\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"===========================================\"#);\r\n\t\t\t\t\t\t#getch();\r\n\t\t\t\t\t\t#[Keywords]break#;\r\n\t\t\t\t\t#[Keywords]case ##[Fields]'4'#:\r\n\t\t\t\t\t\t#clrscr();\r\n\t\t\t\t\t\t#puts(#[Fields]\"===========================================\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"|   Your Debit money is $1000,Thank you!  |\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"|        Press any key to return...       |\"#);\r\n\t\t\t\t\t\t#puts(#[Fields]\"===========================================\"#);\r\n\t\t\t\t\t\t#getch();\r\n\t\t\t\t\t\t#[Keywords]break#;\r\n\t\t\t\t\t#[Keywords]case ##[Fields]'5'#:\r\n\t\t\t\t\t\t#[Keywords]break#;\r\n\t\t\t\t#}\r\n\t\t\t\t#[Keywords]break#;\r\n\t\t\t#[Keywords]case ##[Fields]'4'#:\r\n\t\t\t\t#clrscr();\r\n\t\t\t\t#puts(#[Fields]\"================================\"#);\r\n\t\t\t\t#puts(#[Fields]\"|   Thank you #[Keywords]for #your using!  |\"#);\r\n\t\t\t\t#puts(#[Fields]\"|            Good bye!         |\"#);\r\n\t\t\t\t#puts(#[Fields]\"================================\"#);\r\n\t\t\t\t#[Keywords]return#;#\r\n\t\t#}\r\n\t#}\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        13,
        "用二维数组实现矩阵转置",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/* 用二维数组实现矩阵的转置 *\/\r\n#include <stdio.h>\r\n#define ROW 3\r\n#define COL 4\r\nmain()\r\n{\r\n\t#[Keywords]int #matrixA[ROW][COL],matrixB[COL][ROW];\r\n\t#[Keywords]int #i,j;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"Enter elements of the matrixA,\"#);\r\n\t#printf(#[Fields]\"%d*%d:\\n\"#,ROW,COL);\r\n\t#[Keywords]for#( i=0; i<ROW; i++ )\r\n\t#{\r\n\t\t#[Keywords]for#( j=0; j<COL; j++ )\r\n\t\t#{\r\n\t\t\t#scanf(#[Fields]\"%d\"#,&matrixA[i][j]);\r\n\t\t#}\r\n\t#}\r\n\t#[Keywords]for#( i=0; i<ROW; i++ )\r\n\t#{\r\n\t\t#[Keywords]for#( j=0; j<COL; j++ )\r\n\t\t#{\r\n\t\t\t#matrixB[j][i] = matrixA[i][j];\r\n\t\t#}\r\n\t#}\r\n\t#printf(#[Fields]\"MatrixB,\"#);\r\n\t#printf(#[Fields]\"%d*%d:\\n\"#,COL,ROW);\r\n\t#[Keywords]for#( i=0; i<COL; i++ )\r\n\t#{\r\n\t\t#[Keywords]for#( j=0; j<ROW; j++ )\r\n\t\t#{\r\n\t\t\t#printf(#[Fields]\"%8d\"#,matrixB[i][j]);\r\n\t\t#}\r\n\t\t#printf(#[Fields]\"\\n\"#);\r\n\t#}\r\n\t#printf(#[Fields]\"\\n  Press Any Key to Quit...  \\n\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        14,
        "求解二维数组的最大最小元素",
        "代码如下：\r\n[code=java]\r\n#define MAXN 20\r\n#[Keywords]int #a[MAXN][MAXN];\r\nmain()\r\n{\r\n\t#[Keywords]int #min,\t\/* 存储最小值 *\/\r\n\t    #max;\t\/* 存储最大值 *\/\r\n\t#[Keywords]int #row,col,n;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"Please input the order of the matrix:\\n\"#);\/* 输入方阵的阶次 *\/\r\n\t#scanf(#[Fields]\"%d\"#,&n);\r\n\t#printf(#[Fields]\"Please input the elements of the matrix,\\n from a[0][0] to a[%d][%d]:\\n\"#,n-1,n-1);\r\n\t#[Keywords]for#(row=0;row<n;row++)\r\n\t\t#[Keywords]for#(col=0;col<n;col++)\r\n\t\t\t#scanf(#[Fields]\"%d\"#,&a[row][col]);\r\n\t#[Keywords]for#(min=a[0][0],row=0;row<n;row++)\r\n\t#{\r\n\t\t#\/* 从每行选出最大数 *\/\r\n\t\t#[Keywords]for#(max=a[row][0],col=1;col<n;col++)\/*从row行选出最大数 *\/\r\n\t\t\t#[Keywords]if#(max<a[row][col])\r\n\t\t\t\t#max=a[row][col];\r\n\t\t#[Keywords]if#(min>max)\/* 保存至row行的最小数 *\/\r\n\t\t\t#min=max;\r\n\t#}\r\n\t#printf(#[Fields]\"The minimum of maximum number is %d\\n\"#,min);\r\n\t#[Keywords]for#(max=a[0][0],row=0;row<n;row++)\r\n\t#{\r\n\t\t#\/* 每行选出最小数 *\/\r\n\t\t#[Keywords]for#(min=a[row][0],col=1;col<n;col++)\/* 从row行选出最小数 *\/\r\n\t\t\t#[Keywords]if#(min>a[row][col])\r\n\t\t\t\t#min=a[row][col];\r\n\t\t#[Keywords]if#(max<min)\/*保存至row行的最大数 *\/\r\n\t\t\t#max=min;\r\n\t#}\r\n\t#printf(#[Fields]\"The maximum of minimum numbers is %d\\n\"#,max);\r\n\t#printf(#[Fields]\"\\nPress any key to quit...\\n\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        15,
        "利用数组求前n个质数",
        "代码如下：\r\n[code=java]\r\n#define N 50\r\nmain()\r\n{\r\n\t#[Keywords]int #primes[N];\r\n\t#[Keywords]int #pc,m,k;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"\\n The first %d prime numbers are:\\n\"#,N);\r\n\t#primes[0]=2;\/*2是第一个质数*\/\r\n\t#pc=1;\/*已有第一个质数*\/\r\n\t#m=3;\/*被测试的数从3开始*\/\r\n\t#[Keywords]while#(pc<N)\r\n\t#{\r\n\t #\/*调整m使它为下一个质数*\/\r\n\t#k=0;\r\n\t#[Keywords]while#(primes[k]*primes[k]<=m)\r\n\t\t#[Keywords]if#(m%primes[k]==0)\r\n\t\t#{\/*m是合数*\/\r\n\t\t    #m+=2;\/*让m取下一个奇数*\/\r\n\t\t    #k=1;\/*不必用primes[0]=2去测试m，所以k从一开始*\/\r\n\t\t#}\r\n\t\t#else\r\n\t\t#k++;\/*继续用下一个质数去测试*\/\r\n\t#primes[pc++]=m;\r\n\t#m+=2;\/*除2外，其余质数均是奇数*\/\r\n\t#}\r\n\t#\/*输出primes[0]至primes[pc-1]*\/\r\n\t#[Keywords]for#(k=0;k<pc;k++)\r\n\t\t#printf(#[Fields]\"%4d\"#,primes[k]);\r\n\t#printf(#[Fields]\"\\n\\n Press any key to quit...\\n \"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        16,
        "编制万年历",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/*这份代码经源码格式软件格式化过 *\/\r\n#include #[Fields]\"stdio.h\r\n#[Keywords]long #[Keywords]int #f(#[Keywords]int #year,#[Keywords]int #month)\r\n{\r\n    #\/*f(年，月)＝年－1，如月<3;否则，f(年，月)＝年*\/\r\n    #[Keywords]if#(month<3)#[Keywords]return #year-1 ;\r\n    #[Keywords]else #[Keywords]return #year ;\r\n#}\r\n#[Keywords]long #[Keywords]int #g(#[Keywords]int #month)\r\n{\r\n    #\/*g(月)＝月＋13，如月<3;否则，g(月)＝月＋1*\/\r\n    #[Keywords]if#(month<3)#[Keywords]return #month+13 ;\r\n    #[Keywords]else #[Keywords]return #month+1 ;\r\n#}\r\n#[Keywords]long #[Keywords]int #n(#[Keywords]int #year,#[Keywords]int #month,#[Keywords]int #day)\r\n{\r\n    #\/*N=1461*f(年、月)\/4+153*g(月)\/5+日*\/\r\n    #[Keywords]return #1461L*f(year,month)\/4+153L*g(month)\/5+day ;\r\n#}\r\n#[Keywords]int #w(#[Keywords]int #year,#[Keywords]int #month,#[Keywords]int #day)\r\n{\r\n    #\/*w=(N-621049)%7(0<=w<7)*\/\r\n    #return(#[Keywords]int#)((n(year,month,day)%7-621049L%7+7)%7);\r\n#}\r\n#[Keywords]int #date[12][6][7];\r\n#[Keywords]int #day_tbl[][12]=\r\n{\r\n    #{\r\n        #31,28,31,30,31,30,31,31,30,31,30,31\r\n    #}\r\n    #,\r\n    #{\r\n        #31,29,31,30,31,30,31,31,30,31,30,31\r\n    #}\r\n#}\r\n;\r\nmain()\r\n{\r\n    #[Keywords]int #sw,leap,i,j,k,wd,day ;\r\n    #[Keywords]int #year ;\r\n    #\/*年*\/\r\n    #[Keywords]char #title[]=#[Fields]\"SUN MON TUE WED THU FRI SAT\"# ;\r\n    #clrscr();\r\n    #printf(#[Fields]\"Please input the year whose calendar you want to know: \"#);\r\n    #\/*输入年*\/\r\n    #scanf(#[Fields]\"%d%*c\"#,&year);\r\n    #\/*输入年份值和掠过值后的回车*\/\r\n    #sw=w(year,1,1);\r\n    #leap=year%4==0&&year%100||year%400==0 ;\r\n    #\/*判闰年*\/\r\n    #[Keywords]for#(i=0;i<12;i++)\r\n    #[Keywords]for#(j=0;j<6;j++)\r\n    #[Keywords]for#(k=0;k<7;k++)\r\n    #date[i][j][k]=0 ;\r\n    #\/*日期表置0*\/\r\n    #\/*一年十二个月*\/\r\n    #[Keywords]for#(i=0;i<12;i++)#[Keywords]for#(wd=0,day=1;day<=day_tbl[leap][i];day++)\r\n    #{\r\n        #\/*将第i＋1月的日期填入日期表*\/\r\n        #date[i][wd][sw]=day ;\r\n        #sw=++sw%7 ;\r\n        #\/*每星期七天，以0至6计数*\/\r\n        #[Keywords]if#(sw==0)wd++;\r\n        #\/*日期表每七天一行，星期天开始新的一行*\/\r\n    #}\r\n    \r\n    #printf(#[Fields]\"\\n|==================The Calendar of Year %d =====================|\\n|\"#,year);\r\n    #[Keywords]for#(i=0;i<6;i++)\r\n    #{\r\n        #\/*先测算第i+1月和第i+7月的最大星期数*\/\r\n        #\/*日期表的第六行有日期，则wd!=0*\/\r\n        #[Keywords]for#(wd=0,k=0;k<7;k++)wd+=date[i][5][k]+date[i+6][5][k];\r\n        #wd=wd?6:5 ;\r\n        #printf(#[Fields]\"%2d  %s  %2d  %s |\\n|\"#,i+1,title,i+7,title);\r\n        #[Keywords]for#(j=0;j<wd;j++)\r\n        #{\r\n            #printf(#[Fields]\"   \"#);\r\n            #\/*输出四个空白符*\/\r\n            #\/*左栏为第i+1月，右栏为第i+7月*\/\r\n            #[Keywords]for#(k=0;k<7;k++)\r\n            #[Keywords]if#(date[i][j][k])\r\n            #printf(#[Fields]\"%4d\"#,date[i][j][k]);\r\n            #[Keywords]else #printf(#[Fields]\"    \"#);\r\n            #printf(#[Fields]\"     \"#);\r\n            #\/*输出十个空白符*\/\r\n            #[Keywords]for#(k=0;k<7;k++)\r\n            #[Keywords]if#(date[i+6][j][k])\r\n            #printf(#[Fields]\"%4d\"#,date[i+6][j][k]);\r\n            #[Keywords]else #printf(#[Fields]\"    \"#);\r\n            #printf(#[Fields]\" |\\n|\"#);\r\n        #}\r\n        #\/*scanf(#[Fields]\"%*c\"#);\/*键入回车输出下一个月的日历*\/\r\n        \r\n    #}\r\n    #puts(#[Fields]\"=================================================================|\"#);\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        17,
        "对数组元素排序",
        "代码如下：\r\n[code=java]\r\nrest(#[Keywords]int #a[], #[Keywords]int #n)\r\n{\r\n\t#[Keywords]int #i,low,high,t;\r\n\t#[Keywords]for#(i=0,low=0,high=n-1;i<=high;)\r\n\t#{\r\n\t\t#[Keywords]if#(a[i]>0)\r\n\t\t#{\r\n\t\t\t#\/*a[i]与a[high]交换，随之high减1*\/\r\n\t\t\t#t=a[i];\r\n\t\t\t#a[i]=a[high];\r\n\t\t\t#a[high]=t;\r\n\t\t\t#high--;\r\n\t\t#}\r\n\t\t#[Keywords]else #[Keywords]if#(a[i]==0)\r\n\t\t\t#i++; \/* 掠过该元素 *\/\r\n\t\t#else\r\n\t\t#{\r\n\t\t\t#\/*a[i]与a[low]交换，随之low增1, i增1*\/\r\n\t\t\t#t=a[i];\r\n\t\t\t#a[i]=a[low];\r\n\t\t\t#a[low]=t;\r\n\t\t\t#low++;\r\n\t\t\t#i++;\r\n\t\t#}\r\n\t#}\r\n#}\r\n#[Keywords]int #s[]={8,4,0,-1,6,0,-5#};\r\nmain()\r\n{\r\n\t#[Keywords]int #i;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"\\n The arry before rest is:\\n\"#);\r\n\t#[Keywords]for#(i=0;i<sizeof(s)\/sizeof(s[0]);i++)\r\n\t\t#printf(#[Fields]\"%4d\"#,s[i]);\r\n\t#rest(s,sizeof(s)\/sizeof(s[0]));\r\n\t#printf(#[Fields]\"\\n The arry after rest is:\\n\"#);\r\n\t#[Keywords]for#(i=0;i<sizeof(s)\/sizeof(s[0]);i++)\r\n\t\t#printf(#[Fields]\"%4d\"#,s[i]);\r\n\t#printf(#[Fields]\"\\n Press any key to quit...\\n\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        18,
        "任意进制数的转换",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/* 函数trans将无符号整数n翻译成d（2<＝d<＝16）进制表示的字符串s *\/\r\n#define M sizeof(unsigned #[Keywords]int#)*8 \r\n#[Keywords]int #trans(unsigned n,#[Keywords]int #d,#[Keywords]char #s[])\r\n{\r\n    #[Keywords]static #[Keywords]char #digits[]=#[Fields]\"0123456789ABCDEF\"# ;\r\n    #[Tags]\/* 十六进制数字的字符 *\/\r\n    #[Keywords]char #buf[M+1];\r\n    #[Keywords]int #j,i=M ;\r\n    #[Keywords]if#(d<2||d>16)\r\n    #{\r\n        #s[0]=#[Fields]'\\0'# ;\r\n        #[Tags]\/* 不合理的进制，置s为空字符串 *\/\r\n        #[Keywords]return #0 ;\r\n        #[Tags]\/* 不合理的进制，函数返回0 *\/\r\n    #}\r\n    #buf[i]=#[Fields]'\\0'# ;\r\n    #[Keywords]do #\r\n    #{\r\n        #buf[--i]=digits[n%d];\r\n        #[Tags]\/*译出最低位，对应字符存入对应工作数组中*\/\r\n        #n\/=d ;\r\n    #}\r\n   #[Keywords] while#(n);\r\n    #[Tags]\/* 将译出在工作数组中的字符串复制到s *\/\r\n    #[Keywords]for#(j=0;(s[j]=buf[i])!=#[Fields]'\\0'#;j++,i++);\r\n    #[Tags]\/* 其中控制条件可简写成s[j]=buf[i] *\/\r\n    #[Keywords]return #j ;\r\n#}\r\n#[Tags]\/* 主函数用于测试函数 trans() *\/\r\nmain()\r\n{\r\n    #unsigned #[Keywords]int #num=253 ;\r\n    #[Keywords]int #scale[]=\r\n    #{\r\n        #2,3,10,16,1\r\n    #}\r\n    #;\r\n    #[Keywords]char #str[33];\r\n    #[Keywords]int #i ;\r\n    #clrscr();\r\n    #[Keywords]for#(i=0;i<sizeof(scale)\/sizeof(scale[0]);i++)\r\n    #{\r\n        #[Keywords]if#(trans(num,scale[i],str))\r\n        #printf(#[Fields]\"%5d = %s(%d)\\n\"#,num,str,scale[i]);\r\n        #[Keywords]else #\r\n        #printf(#[Fields]\"%5d => (%d) Error! \\n\"#,num,scale[i]);\r\n    #}\r\n    #printf(#[Fields]\"\\n Press any key to quit...\\n\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        19,
        "判断回文数",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/* 函数circle用于判断正整数n的d进制数表示形式是否是回文数 *\/\r\n#[Keywords]int #circle(#[Keywords]int #n, #[Keywords]int #d)\r\n{\r\n\t#[Keywords]int #s=0,m=n;\r\n\t#[Keywords]while#(m)\r\n\t#{\r\n\t\t#s=s*d+m%d;\r\n\t\t#m\/=d;\r\n\t#}\r\n\t#[Keywords]return #s==n;\r\n#}\r\n#[Tags]\/* main函数用于测试circle函数 *\/\r\n#[Keywords]int #num[]={232,27,851#};\r\n#[Keywords]int #scale[]={2,10,16#};\r\nmain()\r\n{\r\n\t#[Keywords]int #i,j;\r\n\t#clrscr();\r\n\t#[Keywords]for#(i=0;i<sizeof(num)\/sizeof(num[0]);i++)\r\n\t\t#[Keywords]for#(j=0;j<sizeof(scale)\/sizeof(scale[0]);j++)\r\n\t\t\t#[Keywords]if#(circle(num[i],scale[j]))\r\n\t\t\t\t#printf(#[Fields]\"%d -> (%d) is a Circle Number!\\n\"#,num[i],scale[j]);\r\n\t\t\t#else\r\n\t\t\t\t#printf(#[Fields]\"%d -> (%d) is not a Circle Number!\\n\"#,num[i],scale[j]);\r\n\t#printf(#[Fields]\"\\n Press any key to quit...\\n\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        20,
        "求数组前n元素之和",
        "代码如下：\r\n[code=java]\r\n#[Keywords]int #a[]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15#};\r\nmain()\r\n{\r\n\t#[Keywords]int #i;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"\\n The arry is:\\n\"#);\r\n\t#[Keywords]for#(i=0;i<sizeof(a)\/sizeof(a[0]);i++)\r\n\t\t#printf(#[Fields]\" %d \"#,a[i]);\r\n\t#printf(#[Fields]\"\\n SUM of the arry is: %d\\n\"#,sum(a,sizeof(a)\/sizeof(a[0])));\r\n\t#printf(#[Fields]\"\\n Press any key to quit...\\n\"#);\r\n\t#getch();\r\n#}\r\nsum(#[Keywords]int #a[],#[Keywords]int #n)\r\n{\r\n\t#[Keywords]if#(n<=0)\r\n\t\t#[Keywords]return #0;\r\n\t#[Keywords]return #a[n-1]+sum(a,n-1);\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        21,
        "求解钢材切割的最佳订单",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define N 20\r\n#define DELTA 2\r\n#[Keywords]int #bestlen;\r\n#[Keywords]int #bestsele[N];\r\n#[Keywords]int #sele[N];\r\n#[Keywords]int #n;\r\n#[Keywords]int #orderlen[N];\r\n#[Keywords]int #total;\r\nmain()\r\n{\r\n\t#[Keywords]int #i;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"\\n Please enter total length of the steel:\\n\"#);\/* 输入钢材总长 *\/\r\n\t#scanf(#[Fields]\"%d\"#,&total);\r\n\t#printf(#[Fields]\"\\n Please enter number of order:\\n\"#);  \/* 输入定单数 *\/\r\n\t#scanf(#[Fields]\"%d\"#,&n);\r\n\t#printf(#[Fields]\"\\n Please enter the orders:\\n\"#); \/* 输入各定单 *\/\r\n\t#[Keywords]for#(i=0;i<n;i++)\r\n\t\t#scanf(#[Fields]\"%d\"#,&orderlen[i]);\r\n\t#bestlen=0;\t\/*最佳解用料的初值 *\/\r\n\t#[Keywords]for#(i=0;i<n;i++)\r\n\t\t#sele[i]=bestsele[i]=0;\t\/*置当前选择和最佳选择初值 *\/\r\n\t#try();\t\/* 调用函数求解 *\/\r\n\t#[Keywords]for#(i=0;i<n;i++) \/* 输出结果 *\/\r\n\t\t#[Keywords]if#(bestsele[i])\r\n\t\t\t#printf(#[Fields]\"order %d length = %d\\n\"#,i+1,orderlen[i]);\r\n\t#printf(#[Fields]\"\\n Press any key to quit...\"#);\r\n\t#getch();\r\n#}\r\ntry()\r\n{\r\n\t#[Keywords]int #i,len;\r\n\t#[Keywords]for#(len=i=0;i<n;i++)\t\/* 求当前选中的用料量 *\/\r\n\t\t#[Keywords]if#(sele[i])\r\n\t\t\t#len+=orderlen[i]+DELTA;\r\n\t#[Keywords]if#(len-DELTA<=total)\t\/* 注意最后一段可能不需要切割 *\/\r\n\t#{\r\n\t\t#[Keywords]if#(bestlen < len)\r\n\t\t#{\r\n\t\t\t#\/* 找到一个更好的解 *\/\r\n\t\t\t#bestlen = len;\r\n\t\t\t#[Keywords]for#(i=0;i<n;i++)\r\n\t\t\t\t#bestsele[i]=sele[i];\r\n\t\t#}\r\n\t\t#[Keywords]for#(i=0;i<n;i++) \/* 对所有未选定单逐一作选中尝试循环 *\/\r\n\t\t\t#[Keywords]if#(!sele[i])\r\n\t\t\t#{\r\n\t\t\t\t#sele[i]=1;\t\/* 做选中尝试*\/\r\n\t\t\t\t#try();\r\n\t\t\t\t#sele[i]=0;\r\n\t\t\t#}\r\n\t#}\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        22,
        "通过指针比较整数大小",
        "代码如下：\r\n[code=java]\r\nmain()\r\n{\r\n\t#[Keywords]int #x,y,z;\t#[Tags]\/* 定义三个int型变量 *\/\r\n\t#[Keywords]int #*xp = &x,\t#[Tags]\/* 定义指针变量xp,并赋值为x的地址，使xp指向x *\/\r\n\t    #[Tags]*yp = &y,\t\/#[Tags]* 定义指针变量yp,并赋值为y的地址，使yp指向y #[Tags]*\/\r\n\t    #[Tags]*zp = &z;\t\/#[Tags]* 定义指针变量zp,并赋值为z的地址，使zp指向z #[Tags]*\/\r\n\t#[Keywords]int #t;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"\\nPlease input x,y,z:\\n\"#);\r\n\t#scanf(#[Fields]\"%d%d%d\"#,xp,yp,zp);\t#[Tags]\/* 通过变量的指针，为变量输入值 *\/\r\n\t#[Keywords]if#(*xp>*yp)\t#[Tags]\/* 通过指向变量的指针引用变量的值 *\/\r\n\t#{\r\n\t\t#t=*xp;\t\/* 通过指向变量的指针引用变量的值 *\/\r\n\t\t#[Tags]*xp=#[Tags]*yp;\/#[Tags]* 通过指向变量x的指针xp,引用变量x的值 #[Tags]*\/\r\n\t\t#[Tags]*yp=t;\t\/#[Tags]* 通过指向变量y的指针yp,引用变量y的值 #[Tags]*\/\r\n\t#}\r\n\t#[Keywords]if#(*xp>*zp)\t#[Tags]\/* 通过指向变量的指针,引用变量的值 *\/\r\n\t#{\r\n\t\t#t=*xp;\t#[Tags]\/* 通过指向变量x的指针xp,引用变量x的值 *\/\r\n\t\t#[Tags]*xp=#[Tags]*zp;\/#[Tags]* 通过指向变量x的指针xp,引用变量x的值 #[Tags]*\/\r\n\t\t#[Tags]*zp=t;\t\/#[Tags]* 通过指向变量z的指针zp,引用变量z的值 #[Tags]*\/\r\n\t#}\r\n\t#[Keywords]if#(*yp>*zp)\t#[Tags]\/* 通过指向变量的指针,引用变量的值 *\/\r\n\t#{\r\n\t\t#t=*yp;\t#[Tags]\/* 通过指向变量的指针,引用变量的值 *\/\r\n\t\t#[Tags]*yp=#[Tags]*zp;\/#[Tags]* 通过指向变量y的指针yp,引用变量y的值 #[Tags]*\/\r\n\t\t#[Tags]*zp=t;\/#[Tags]* 通过指向变量z的指针zp,引用变量z的值 #[Tags]*\/\r\n\t#}\r\n\t#printf(#[Fields]\"x = %d\\ty = %d\\tz = %d\\n\"#,x,y,z);\r\n\t#printf(#[Fields]\"\\nPress any key to quit...\\n\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        23,
        "指向数组的指针",
        "代码如下：\r\n[code=java]\r\n#[Keywords]int #a[ ]={1,2,3,4,5#};\r\n#define N sizeof a\/sizeof a[0]\r\nmain()\r\n{\r\n\t#[Keywords]int #j,   #[Tags]\/*游标变量*\/\r\n\t      #[Tags]*p; #[Tags]\/*指针变量*\/\r\n\t#clrscr();\r\n\t#[Keywords]for#(j=0;j<N;j++) #[Tags]\/*数组名和下标顺序访问数组的元素*\/\r\n\t\t#printf(#[Fields]\"a[%d]\\t= %d\\t\"#,j,a[j]);\r\n\t#printf(#[Fields]\"\\n\"#);\r\n\t#[Keywords]for#(p=a;p<a+N;p++)#[Tags]\/*让指针顺序指向数组的各元素，遍历数组*\/\r\n\t#printf(#[Fields]\"*p\\t= %d\\t\"#,*p);\r\n\t#printf(#[Fields]\"\\n\"#);#[Tags]\/*指针与游标变量结合，改变游标变量遍历数组*\/\r\n\t#[Keywords]for#(p=a,j=0;p+j<a+N;j++)\r\n\t\t#printf(#[Fields]\"*(p+%d)\\t= %d\\t\"#,j,*(p+j));\r\n\t#printf(#[Fields]\"\\n\"#);#[Tags]\/*指针与游标变量结合，用指针和下标遍历数组*\/\r\n\t#[Keywords]for#(p=a+N-1,j=N-1;j>=0;j--)\r\n\t\t#printf(#[Fields]\"p[-%d]\\t= %d\\t\"#,j,p[-j]);\r\n\t#printf(#[Fields]\"\\nPress any key to quit...\\n\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        24,
        "寻找指定元素的指针",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define MAX 20\r\n#[Keywords]int #search(#[Keywords]int #*apt,\/*已知数表的首元指针*\/\r\n\t#[Keywords]int #n,\/*数表中元素个数*\/\r\n\t#[Keywords]int #key)\/*要寻找的值*\/\r\n{\r\n\t#[Keywords]int #*p;\r\n\t#[Keywords]for#(p=apt;p<apt+n;p++)\r\n\t\t#[Keywords]if#(*p==key)\r\n\t\t\t#[Keywords]return #p-apt;\/*返回找到元素的下标*\/\r\n\t#[Keywords]return #-1;\r\n#}\r\n#[Keywords]int #*find(#[Keywords]int #*apt,\/*已知数表的首元指针*\/\r\n\t\t#[Keywords]int #n,\/*数表中元素个数*\/\r\n\t\t#[Keywords]int #key)\/*要寻找的值*\/\r\n{\r\n\t#[Keywords]int #*p;\r\n\t#[Keywords]for#(p=apt;p<apt+n;p++)\r\n\t\t#[Keywords]if#(*p==key)\r\n\t\t#[Keywords]return #p;\/*返回找到元素的指针*\/\r\n\t#[Keywords]return #NULL;\r\n#}\r\n#[Keywords]int #a[]={90,80,70,60,50,40,30,20,10,9,8,7,6,5,42,40,50,1,2,3#};\r\nmain()\r\n{\r\n\t#[Keywords]int #i,key;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"The elements of array a is:\\n\"#);\r\n\t#[Keywords]for#(i=0;i<sizeof(a)\/sizeof(a[0]);i++)\r\n\t\t#printf(#[Fields]\" %d\"#,a[i]);\r\n\t#printf(#[Fields]\"\\nThe address of a[0] is: %d.\\n\"#,&a[0]);\r\n\t#puts(#[Fields]\"\\nPlease input the key number you want to search:\"#);\r\n\t#scanf(#[Fields]\"%d\"#,&key);\r\n\t#i=search(a,sizeof(a)\/sizeof(a[0]),key);\r\n\t#printf(#[Fields]\"\\nThe label number of the key number %d in the array is: %d.\"#,key,i);\r\n\t#printf(#[Fields]\"\\nThe po#[Keywords]int #value of the key number %d in the array is: %d.\"#,key,find(a, sizeof(a)\/sizeof(a[0]),key));\r\n\r\n\t#puts(#[Fields]\"\\n\\n Press any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        25,
        "寻找相同元素的指针",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define ROWS 4\r\n#define COLS 4\r\n#[Keywords]int #nums[ROWS][COLS]={{1000,1000,1000,1000#},\r\n\t\t         #{900,500,400,100#},\r\n\t\t         #{90,50,40,10#},\r\n\t\t         #{9,5,4,1#}#};\r\n#[Keywords]char #*roms[ROWS][COLS]={{#[Fields]\"m\"#,#[Fields]\"m\"#,#[Fields]\"m\"#,#[Fields]\"m\"##},\r\n\t\t              #{#[Fields]\"cm\"#,#[Fields]\"d\"#,#[Fields]\"cd\"#,#[Fields]\"c\"##},\r\n\t\t              #{#[Fields]\"xc\"#,#[Fields]\"l\"#,#[Fields]\"xl\"#,#[Fields]\"x\"##},\r\n\t\t              #{#[Fields]\"ix\"#,#[Fields]\"v\"#,#[Fields]\"iv\"#,#[Fields]\"i\"##}#};\r\nmain(#[Keywords]int #argc,#[Keywords]char #*argv[ ])\r\n{\r\n\t#[Keywords]int #low,high;\r\n\t#[Keywords]char #roman[25];\r\n\t#[Keywords]if#(argc<2)\r\n\t#{\tprintf(#[Fields]\"Usage:roman decimal_number\\n\"#);\/*运行程序需带整数参数*\/\r\n\t \t#exit(0);\r\n\t#}\r\n\t#high=low=atoi(argv[1]);\/*将第一个参数转换成整数*\/\r\n\t#checknum(low);\r\n\t#[Keywords]if#(argc>2)\r\n\t#{\/*带两个参数*\/\r\n\t#high=atoi(argv[2]);\r\n\t#checknum(high);\r\n\t#[Keywords]if#(low>high)\r\n\t\t#{\r\n\t\t\t#low=high;\r\n\t\t\t#high=atoi(argv[1]);\r\n\t\t#}\r\n\t#}\r\n\t#else\r\n\t\t#low=1;\r\n\t#[Keywords]for#(;low<=high;low++)\r\n\t#{\r\n\t\t#to_roman(low,roman);\r\n\t\t#printf(#[Fields]\"%d\\t%s\\n\"#,low,roman);\r\n\t#}\r\n#}\r\nchecknum(#[Keywords]int #val)\/*检查参数合理性*\/\r\n{\r\n\t#[Keywords]if#(val<1||val>9999)\r\n\t#{\r\n\t\t#printf(#[Fields]\"The number must be in range 1..9999.\\n\"#);\r\n\t\t#exit(0);\r\n\t#}\r\n#}\r\nto_roman(#[Keywords]int #decimal,#[Keywords]char #roman[ ])\/*将整数转换成罗马数字表示*\/\r\n{\r\n\t#[Keywords]int #power,index;\r\n\t#roman[0]=#[Fields]'\\0'#;\r\n\t#[Keywords]for#(power=0;power<ROWS;power++)\r\n\t\t#[Keywords]for#(index=0;index<COLS;index++)\r\n\t\t\t#[Keywords]while#(decimal>=nums[power][index])\r\n\t\t\t#{\r\n\t\t\t\t#strcat(roman,roms[power][index]);\r\n\t\t\t\t#decimal-=nums[power][index];\r\n\t\t\t#}\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        26,
        "阿拉伯数字转换为罗马数字",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define ROWS 4\r\n#define COLS 4\r\n#[Keywords]int #nums[ROWS][COLS]={{1000,1000,1000,1000#},\r\n\t\t         #{900,500,400,100#},\r\n\t\t         #{90,50,40,10#},\r\n\t\t         #{9,5,4,1#}#};\r\n#[Keywords]char #*roms[ROWS][COLS]={{#[Fields]\"m\"#,#[Fields]\"m\"#,#[Fields]\"m\"#,#[Fields]\"m\"##},\r\n\t\t              #{#[Fields]\"cm\"#,#[Fields]\"d\"#,#[Fields]\"cd\"#,#[Fields]\"c\"##},\r\n\t\t              #{#[Fields]\"xc\"#,#[Fields]\"l\"#,#[Fields]\"xl\"#,#[Fields]\"x\"##},\r\n\t\t              #{#[Fields]\"ix\"#,#[Fields]\"v\"#,#[Fields]\"iv\"#,#[Fields]\"i\"##}#};\r\nmain(#[Keywords]int #argc,#[Keywords]char #*argv[ ])\r\n{\r\n\t#[Keywords]int #low,high;\r\n\t#[Keywords]char #roman[25];\r\n\t#[Keywords]if#(argc<2)\r\n\t#{\tprintf(#[Fields]\"Usage:roman decimal_number\\n\"#);\/*运行程序需带整数参数*\/\r\n\t \t#exit(0);\r\n\t#}\r\n\t#high=low=atoi(argv[1]);\/*将第一个参数转换成整数*\/\r\n\t#checknum(low);\r\n\t#[Keywords]if#(argc>2)\r\n\t#{\/*带两个参数*\/\r\n\t#high=atoi(argv[2]);\r\n\t#checknum(high);\r\n\t#[Keywords]if#(low>high)\r\n\t\t#{\r\n\t\t\t#low=high;\r\n\t\t\t#high=atoi(argv[1]);\r\n\t\t#}\r\n\t#}\r\n\t#else\r\n\t\t#low=1;\r\n\t#[Keywords]for#(;low<=high;low++)\r\n\t#{\r\n\t\t#to_roman(low,roman);\r\n\t\t#printf(#[Fields]\"%d\\t%s\\n\"#,low,roman);\r\n\t#}\r\n#}\r\nchecknum(#[Keywords]int #val)\/*检查参数合理性*\/\r\n{\r\n\t#[Keywords]if#(val<1||val>9999)\r\n\t#{\r\n\t\t#printf(#[Fields]\"The number must be in range 1..9999.\\n\"#);\r\n\t\t#exit(0);\r\n\t#}\r\n#}\r\nto_roman(#[Keywords]int #decimal,#[Keywords]char #roman[ ])\/*将整数转换成罗马数字表示*\/\r\n{\r\n\t#[Keywords]int #power,index;\r\n\t#roman[0]=#[Fields]'\\0'#;\r\n\t#[Keywords]for#(power=0;power<ROWS;power++)\r\n\t\t#[Keywords]for#(index=0;index<COLS;index++)\r\n\t\t\t#[Keywords]while#(decimal>=nums[power][index])\r\n\t\t\t#{\r\n\t\t\t\t#strcat(roman,roms[power][index]);\r\n\t\t\t\t#decimal-=nums[power][index];\r\n\t\t\t#}\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        27,
        "字符替换",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define MAX 50\r\n#[Tags]\/* 函数rep实现对s中出现的s1中的字符替换为s2中相应的字符 *\/\r\nrep(char*s,char*s1,char*s2)\r\n{\r\n    #char*p ;\r\n    \r\n    #\/*顺序访问字符串s中的每个字符*\/\r\n    #[Keywords]for#(;*s;s++)\r\n    #{\r\n        #[Keywords]for#(p=s1;*p&&*p!=*s;p++);\r\n        #\/*检查当前字符是否在字符串s1中出现*\/\r\n        #[Keywords]if#(*p)*s=*(p-s1+s2);\r\n        #\/*当前字符在字符串s1中出现，用字符串s2中的对应字符代替s中的字符*\/\r\n    #}\r\n#}\r\n#[Tags]\/*示意程序*\/\r\nmain()\r\n{\r\n    #[Keywords]char #s[MAX];\r\n    #\/*=#[Fields]\"ABCABC\"#;*\/\r\n    #[Keywords]char #s1[MAX],s2[MAX];\r\n    #clrscr();\r\n    #puts(#[Fields]\"Please input the string #[Keywords]for #s:\"#);\r\n    #scanf(#[Fields]\"%s\"#,s);\r\n    #puts(#[Fields]\"Please input the string #[Keywords]for #s1:\"#);\r\n    #scanf(#[Fields]\"%s\"#,s1);\r\n    #puts(#[Fields]\"Please input the string #[Keywords]for #s2:\"#);\r\n    #scanf(#[Fields]\"%s\"#,s2);\r\n    #rep(s,s1,s2);\r\n    #puts(#[Fields]\"The string of s after displace is:\"#);\r\n    #printf(#[Fields]\"%s\\n\"#,s);\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        28,
        "从键盘读入实数",
        "代码如下：\r\n[code=java]\r\n#define ERR 5\r\n#define OK 6\r\n#include <stdio.h>\r\n#[Keywords]int #status;\r\n#[Keywords]double #result,sig,scale;\r\n#[Keywords]int #sign(#[Keywords]int #c)#[Tags]\/*处理数的符号函数*\/\r\n{\r\n\t#[Keywords]if#(c==#[Fields]'-'#)#[Tags]\/*若为负号，置负数标记*\/\r\n\t\t#sig=-sig;\r\n#}\r\n#[Keywords]int #integer(#[Keywords]int #c)#[Tags]\/*转换整数部分，转换一位整数位*\/\r\n{\r\n\t#result=result*10.0+c-#[Fields]'0'#;\r\n#}\r\n#[Keywords]int #decimal(#[Keywords]int #c)#[Tags]\/*转换小数部分，转换一位小数位*\/\r\n{\r\n\t#result+=(c-#[Fields]'0'#)*scale;\r\n\t#scale\/=10.0;\r\n#}\r\n#[Tags]\/*状态表*\/\r\n#[Keywords]int #statbl[ ][4]={{   1,2,3,ERR#},#[Tags]\/*0*\/\r\n\t        #{ERR,2,3,ERR#},#[Tags]\/*1*\/\r\n\t        #{OK,2,4,OK#},#[Tags]\/*2*\/\r\n\t        #{ERR,4,ERR,ERR#},#[Tags]\/*3*\/\r\n\t        #{OK,4,OK,OK#}#};#[Tags]\/*4*\/\r\n#[Tags]\/*转换函数表*\/\r\nint(*funtbl[ ][4])( )={{sign,integer,NULL,NULL#},\r\n\t                #{NULL,integer,NULL,NULL#},\r\n\t                #{NULL,integer,NULL,NULL#},\r\n\t                #{NULL,decimal,NULL,NULL#},\r\n                                    #{NULL,decimal,NULL,NULL#}#};\r\n#[Keywords]int #readreal(#[Keywords]double #*dp)\r\n{\r\n\t#[Keywords]int #c,ckind;\r\n\t#sig=1.0;\r\n\t#result=0.0;\r\n\t#scale=0.1;\r\n\t#[Keywords]while#((c=getchar( ))==#[Fields]' '#||c==#[Fields]'\\n'#||c==#[Fields]'\\t'#);#[Tags]\/*跳过前导空白符*\/\r\n\t#status=0;#[Tags]\/*置初始状态*\/\r\n\t#[Keywords]for#(;;)\r\n\t#{\r\n\t\t#\/*分类当前字符*\/\r\n\t\t#[Keywords]if#(c==#[Fields]'+'#||c==#[Fields]'-'#) ckind=0;#[Tags]\/*数的符号字符*\/\r\n\t\t#[Keywords]else #[Keywords]if#(c>=#[Fields]'0'#&&c<=#[Fields]'9'#) ckind=1;#[Tags]\/*数字符*\/\r\n\t\t#[Keywords]else #[Keywords]if#(c==#[Fields]'.'#) ckind=2;#[Tags]\/*小数点*\/\r\n\t\t#[Keywords]else #ckind=3;#[Tags]\/* 其它字符 *\/\r\n\r\n\t\t#[Keywords]if#(funtbl[status][ckind])#[Tags]\/* 如有转换函数 *\/\r\n\t\t\t#(*funtbl[status][ckind])(c);#[Tags]\/* 执行相应的函数 *\/\r\n\t\t#status=statbl[status][ckind];#[Tags]\/*设置新的状态*\/\r\n\t\t#[Keywords]if#(status==ERR||status==OK)#[Keywords]break#;#[Tags]\/* 结束：出错或成功 *\/\r\n\t\t#c=getchar();\r\n\t#}\r\n\t#ungetc(c,stdin); #[Tags]\/* 归还数德结束符 *\/\r\n\t#[Keywords]if#(status==OK)\r\n\t#{\r\n\t\t#*dp=result *sig;#[Tags]\/* 读入数按指针参数赋给相应变量 *\/\r\n\t\t#[Keywords]return #1;\r\n\t#}\r\n\t#[Keywords]return #-1; #[Tags]\/* 出错返回 *\/\r\n#}\r\nmain()\r\n{\r\n\t#[Keywords]double #x;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"\\nPlease input real numbers (use nonreal #[Keywords]char #to end input):\\n\"#);\r\n\t#[Keywords]while#(readreal(&x)==1)\r\n\t\t#printf(#[Fields]\"The real number you input is: %f\\n\"#,x);\r\n\t#printf(#[Fields]\"\\nYou have inputted nonreal char.\\n Press any key to quit...\\n\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        29,
        "字符行排版",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/* 字符排版函数,将字符行内单字之间的空白字符平均分配插入到单字之间*\/\r\n#define N 80\r\nedit(#[Keywords]char #*s)\r\n{\r\n\t#[Keywords]int #i,sp,w,inw,v,r;\r\n\t#[Keywords]char #buf[N],*str;\r\n\t#[Keywords]for#(inw=sp=w=i=0;s[i];i++)\r\n\t#{\r\n\t\t#[Keywords]if#(s[i]==#[Fields]' '#)\r\n\t\t#{\t\t#[Tags]\/* 统计空白个数*\/\r\n\t\t\t#sp++;\r\n\t\t\t#inw=0;\t#[Tags]\/* 置空白符状态*\/\r\n\t\t#}\r\n\t\t#[Keywords]else #[Keywords]if#(!inw)\r\n\t\t#{\r\n\t\t\t#w++;\t#[Tags]\/* 统计单字个数*\/\r\n\t\t\t#inw=1;\t#[Tags]\/* 置单字状态*\/\r\n\t\t#}\r\n\t#}\r\n\t#[Keywords]if#(w<=1)\r\n\t\t#[Keywords]return#;#\t#[Tags]\/* 单字数不超过1, 不排版 *\/\r\n\t#v=sp\/(w-1);\t#[Tags]\/* 每个间隔平均空白符 *\/\r\n\t#r=sp%(w-1);\t#[Tags]\/* 多余的空白符 *\/\r\n\t#strcpy(buf,s);\r\n\t#[Keywords]for#(str=buf;;)\r\n\t#{\r\n\t\t#[Keywords]while#(*str==#[Fields]' '#)str++; #[Tags]\/* 掠过空白符 *\/\r\n\t\t#[Keywords]for#(;*str&&*str!=#[Fields]' '#;) #[Tags]\/* 复制单字 *\/\r\n\t\t\t#[Tags]*s++=#[Tags]*str++;\r\n\t\t#[Keywords]if#(--w==0)\r\n\t\t\t#[Keywords]return#;#\t\t#[Tags]\/* 全部单字复制完毕，返回 *\/\r\n\t\t#[Keywords]for#(i=0;i<v;i++)\r\n\t\t\t#[Tags]*s++=' ';\t\/#[Tags]* 插入间隔空白符 #[Tags]*\/\r\n\t\t#[Keywords]if#(r)\r\n\t\t#{\r\n\t\t\t#[Tags]*s++=' ';\t\/#[Tags]* 插入一个多余空白符 #[Tags]*\/\r\n\t\t\t#r--;\r\n\t\t#}\r\n\t#}\r\n#}\r\n#[Keywords]char #buff[N];\r\nmain()\t\t#[Tags]\/* 用于测试edit函数 *\/\r\n{\r\n\t#clrscr();\r\n\t#puts(#[Fields]\"This is a typeset program!\\nPlease input a character line:\\n\"#);\r\n\t#gets(buff);\r\n\t#edit(buff);\r\n\t#printf(#[Fields]\"\\nThe character line after typeset is:\\n\\n%s\\n\"#,buff);\r\n\t#puts(#[Fields]\"\\n Press any key to quit...\\n \"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        30,
        "字符排列",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/* 字符串的所有字符排列函数，用已知字符串s中的所有字符，生成由其中n个字符组成的所有字符排列 *\/\r\n#define N 20\r\n#[Keywords]char #w[N];\r\nperm(#[Keywords]int #n, #[Keywords]char #*s)\r\n{\r\n\t#[Keywords]char #s1[N];\r\n\t#[Keywords]int #i;\r\n\t#[Keywords]if#(n<1)\r\n\t\t#printf(#[Fields]\"%s\\n\"#,w); #[Tags]\/* 一个排列生成输出 *\/\r\n\t#else\r\n\t#{\r\n\t\t#strcpy(s1,s);\t#[Tags]\/* 保存本层次可使用的字符 *\/\r\n\t\t#[Keywords]for#(i=0;*(s1+i);i++)\t#[Tags]\/* 依次选本层次可用字符 *\/\r\n\t\t#{\r\n\t\t\t#[Tags]*(w+n-1)=#[Tags]*(s1+i);#[Tags]\/* 将选用字符填入正在生成的字符排列中 *\/\r\n\t\t\t#[Tags]*(s1+i)=#[Tags]*s1;\r\n\t\t\t#[Tags]*s1=#[Tags]*(w+n-1);\r\n\t\t\t#perm(n-1,s1+1);\t #[Tags]\/* 递归 *\/\r\n\t\t#}\r\n\t#}\r\n#}\r\nmain()\r\n{\r\n\t#[Keywords]int #n=2;\r\n\t#[Keywords]char #s[N];\r\n\t#w[n]=#[Fields]'\\0'#;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"This is a #[Keywords]char #permutation program!\\nPlease input a string:\\n\"#);\r\n\t#scanf(#[Fields]\"%s\"#,s);\r\n\t#puts(#[Fields]\"\\nPlease input the #[Keywords]char #number of permuted:\\n\"#);\r\n\t#scanf(#[Fields]\"%d\"#,&n);\r\n\t#puts(#[Fields]\"The permuted chars are:\\n\"#);\r\n\t#perm(n,s);\r\n\t#puts(#[Fields]\"\\nPress any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        31,
        "判断字符串是否回文",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define MAX 50\r\n#[Keywords]int #cycle(#[Keywords]char #*s)\r\n{\r\n\t#[Keywords]char #*h,*t;\r\n\r\n\t#[Keywords]for#(h=s,t=s+strlen(s)-1;t>h;h++,t--)\r\n\t\t#[Keywords]if#(*h!=*t) #[Keywords]break#;\r\n\t#[Keywords]return #t<=h;\r\n#}\r\nmain()\r\n{\r\n\t#[Keywords]char #s[MAX];\r\n\t#clrscr();\r\n\t#[Keywords]while#(1)\r\n\t#{\r\n\t\t#puts(#[Fields]\"Please input the string you want to judge (input ^ to quit):\"#);\r\n\t\t#scanf(#[Fields]\"%s\"#,s);\r\n\t\t#[Keywords]if#(s[0]==#[Fields]'^'#)\r\n\t\t\t#[Keywords]break#;\r\n\t\t#[Keywords]if#(cycle(s))\r\n\t\t\t#printf(#[Fields]\" %s is a cycle string.\\n\"#,s);\r\n\t\t#else\r\n\t\t\t#printf(#[Fields]\" %s is not a cycle string.\\n\"#,s);\r\n\t#}\r\n\t#puts(#[Fields]\"\\nThank you #[Keywords]for #your using,bye bye!\\n\"#);\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        32,
        "通讯录的输入输出",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define ZIPLEN 10\r\n#define PHONLEN 15\r\n#[Tags]\/*struct addr类型定义*\/\r\nstruct addr\r\n{\r\n\t#[Keywords]char #*name;#[Tags]\/*姓名*\/\r\n\t#[Keywords]char #*address;#[Tags]\/*地址*\/\r\n\t#[Keywords]char #zip[ZIPLEN];#[Tags]\/*邮政编码*\/\r\n\t#[Keywords]char #phone[PHONLEN];#[Tags]\/*电话号码*\/\r\n#};\r\nmain()#[Tags]\/*本主函数示意上述输入输出函数的用法*\/\r\n{\r\n\t#struct addr p[100];\r\n\t#[Keywords]int #i,j;\r\n\t#clrscr();\r\n\t#[Keywords]for#(i=0;readaddr(p+i);i++);\r\n\t#[Keywords]for#(j=0;j<i;j++) writeaddr(p+j);\r\n\t#puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n#[Tags]\/* 函数readaddr用于输入一个通信录函数 *\/\r\n#[Keywords]int #readaddr(struct addr *dpt)\r\n{\r\n\t#[Keywords]int #len;\r\n\t#[Keywords]char #buf[120];#[Tags]\/*输入字符串的缓冲区*\/\r\n\t#printf(#[Fields]\"\\nPlease input the Name:\\n\"#);#[Tags]\/*输入姓名*\/\r\n\t#[Keywords]if#(scanf(#[Fields]\"%s\"#,buf)==1)\r\n\t#{\r\n\t\t#len=strlen(buf);\r\n\t\t#dpt->name=(#[Keywords]char #*)malloc(len+1);#[Tags]\/*申请存贮姓名的空间*\/\r\n\t\t#strcpy(dpt->name,buf);\r\n\t#}\r\n\t#[Keywords]else #[Keywords]return #0;#[Tags]\/*Ctrl+Z结束输入*\/\r\n\t#printf(#[Fields]\"Please input the Address:\\n\"#);#[Tags]\/*输入地址*\/\r\n\t#[Keywords]if#(scanf(#[Fields]\"%s\"#,buf)==1)\r\n\t#{\r\n\t\t#len=strlen(buf);\r\n\t\t#dpt->address=(#[Keywords]char #*)malloc(len+1);#[Tags]\/*申请存贮地址的空间*\/\r\n\t\t#strcpy(dpt->address,buf);\r\n\t#}\r\n\t#else\r\n\t#{#[Tags]\/*Ctrl+Z结束输入*\/\r\n\t\t#free(dpt->name);#[Tags]\/*释放存贮姓名的空间*\/\r\n\t\t#[Keywords]return #0;\r\n\t#}\r\n\t#printf(#[Fields]\"Please input the Zip code:\\n\"#);#[Tags]\/*输入邮编*\/\r\n\t#[Keywords]if#(scanf(#[Fields]\"%s\"#,buf)==1)\r\n\t\t#strncpy(dpt->zip,buf,ZIPLEN-1);\r\n\t#else\r\n\t#{\r\n\t\t#free(dpt->name);#[Tags]\/*释放存贮姓名的空间*\/\r\n\t\t#free(dpt->address);#[Tags]\/*释放存贮地址的空间*\/\r\n\t\t#[Keywords]return #0;#[Tags]\/*Ctrl+Z结束输入*\/\r\n\t#}\r\n\t#printf(#[Fields]\"Please input the Phone number:\\n\"#);#[Tags]\/*输入电话号码*\/\r\n\t#[Keywords]if#(scanf(#[Fields]\"%s\"#,buf)==1)\r\n\t\t#strncpy(dpt->phone,buf,PHONLEN-1);\r\n\t#else\r\n\t#{\r\n\t\t#free(dpt->name);\r\n\t\t#free(dpt->address);\r\n\t\t#[Keywords]return #0;#[Tags]\/*Ctrl+Z结束输入*\/\r\n\t#}\r\n\t#[Keywords]return #1;\r\n#}\r\n#[Tags]\/* 函数writeaddr用于输出通讯录 *\/\r\n#[Keywords]int #writeaddr(struct addr*dpt)\r\n{\r\n\t#printf(#[Fields]\"Name\t:   %s\\n\"#,\tdpt->name);#[Tags]\/*输出姓名*\/\r\n\t#printf(#[Fields]\"Address\t:   %s\\n\"#,\tdpt->address);#[Tags]\/*输出地址*\/\r\n\t#printf(#[Fields]\"Zip\t:   %s\\n\"#,\tdpt->zip);#[Tags]\/*输出邮编*\/\r\n\t#printf(#[Fields]\"Phone\t:   %s\\n\\n\"#,\tdpt->phone);#[Tags]\/*输出电话号码*\/\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        33,
        "扑克牌的结构表示",
        "代码如下：\r\n[code=java]\r\nenum suits{CLUBS,DIAMONDS,HEARTS,SPADES#};\r\nstruct card\r\n{\r\n\t#enum suits suit;\r\n\t#[Keywords]char #value[3];\r\n#};\r\nstruct card deck[52];\r\n#[Keywords]char #cardval[][3]={#[Fields]\"A\"#,#[Fields]\"2\"#,#[Fields]\"3\"#,#[Fields]\"4\"#,#[Fields]\"5\"#,#[Fields]\"6\"#,#[Fields]\"7\"#,#[Fields]\"8\"#,#[Fields]\"9\"#,#[Fields]\"10\"#,#[Fields]\"J\"#,#[Fields]\"Q\"#,#[Fields]\"K\"##};\r\n#[Keywords]char #suitsname[][9]={#[Fields]\"CLUBS\"#,#[Fields]\"DIAMONDS\"#,#[Fields]\"HEARTS\"#,#[Fields]\"SPADES\"##};\r\nmain()\r\n{\r\n\t#[Keywords]int #i,j;\r\n\t#enum suits s;\r\n\t#clrscr();\r\n\t#[Keywords]for#(i=0;i<=12;i++)\r\n\t\t#[Keywords]for#(s=CLUBS;s<=SPADES;s++)\r\n\t\t#{\r\n\t\t\t#j=i*4+s;\r\n\t\t\t#deck[j].suit=s;\r\n\t\t\t#strcpy(deck[j].value,cardval[i]);\r\n\t\t#}\r\n\t#[Keywords]for#(j=0;j<52;j++)\r\n\t\t#printf(#[Fields]\"(%s%3s)%c\"#,suitsname[deck[j].suit],deck[j].value,j%4==3?#[Fields]'\\n'#:#[Fields]'\\t'#);\r\n\t#puts(#[Fields]\"\\nPress any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        34,
        "用“结构”统计学生成绩",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define N 200\r\n#define SCORES 5\r\n#define NUMLEN 10\r\nstruct std_type{\r\n\t#[Keywords]char #no[NUMLEN];#[Tags]\/*学号*\/\r\n\t#[Keywords]char #*name;#[Tags]\/*名字符串指针*\/\r\n\t#[Keywords]int #scores[SCORES];#[Tags]\/*五门功课的成绩*\/\r\n#};\r\nstruct std_type students[N];\r\n#[Keywords]int #order[N];\r\n#[Keywords]int #total[N];\r\n#[Tags]\/*[函数]输入一个学生信息函数*\/\r\n#[Keywords]int #readastu(struct std_type *spt)\r\n{\r\n\t#[Keywords]int #len,j;\r\n\t#[Keywords]char #buf[120];#[Tags]\/*输入字符串的缓冲区*\/\r\n\t#printf(#[Fields]\"\\nNumber   :   \"#);#[Tags]\/*输入学号*\/\r\n\t#[Keywords]if#(scanf(#[Fields]\"%s\"#,buf)==1)\r\n\t\t#strncpy(spt->no,buf,NUMLEN-1);\r\n\t#else\r\n\t\t#[Keywords]return #0;#[Tags]\/*Ctrl+Z结束输入*\/\r\n\t#printf(#[Fields]\"Name   :   \"#);#[Tags]\/*输入姓名*\/\r\n\t#[Keywords]if#(scanf(#[Fields]\"%s\"#,buf)==1)\r\n\t#{\r\n\t\t#len=strlen(buf);\r\n\t\t#spt->name=(#[Keywords]char #*)malloc(len+1);#[Tags]\/*申请存贮姓名的空间*\/\r\n\t\t#strcpy(spt->name,buf);\r\n\t#}\r\n\t#[Keywords]else #[Keywords]return #0;#[Tags]\/*Ctrl+Z结束输入*\/\r\n\t#printf(#[Fields]\"Scores   :   \"#);#[Tags]\/*输入成绩*\/\r\n\t#[Keywords]for#(j=0;j<SCORES;j++)\r\n\t\t#[Keywords]if#(scanf(#[Fields]\"%d\"#,spt->scores+j)!=1)\r\n\t\t\t#[Keywords]break#;\r\n\t\t\t#[Keywords]if#(j==0)#[Tags]\/*一个成绩也未输入*\/\r\n\t\t\t#{\r\n\t\t\t\t#free(spt->name);#[Tags]\/*释放存贮姓名的空间*\/\r\n\t\t\t\t#[Keywords]return #0;\r\n\t\t\t#}\r\n\t\t\t#[Keywords]for#(;j<SCORES;j++)#[Tags]\/*少数未输入的成绩用0分代之*\/\r\n\t\t\t\t#spt->scores[j]=0;\r\n\t\t\t#[Keywords]return #1;\r\n\t#}\r\n#[Tags]\/*[函数]输出一个学生信息的函数*\/\r\n#[Keywords]int #writeastu(struct std_type *spt)\r\n{\r\n\t#[Keywords]int #i;\r\n\r\n\t#printf(#[Fields]\"Number   :   %s\\n\"#,spt->no);#[Tags]\/*输出学号*\/\r\n\t#printf(#[Fields]\"Name     :   %s\\n\"#,spt->name);#[Tags]\/*输出姓名*\/\r\n\t#printf(#[Fields]\"Scores   :   \"#);#[Tags]\/*输出成绩*\/\r\n\t#[Keywords]for#(i=0;i<SCORES;i++)\r\n\t\t#printf(#[Fields]\"%4d\"#,spt->scores[i]);\r\n\t#printf(#[Fields]\"\\n\\n\"#);\r\n#}\r\nmain()\r\n{\r\n\t#[Keywords]int #n,i,j,t;\r\n\r\n\t#clrscr();\r\n\t#[Keywords]for#(n=0;readastu(students+n);n++);\r\n\t#\/*采用冒泡法对学生信息数组排序*\/\r\n\t#[Keywords]for#(i=0;i<n;i++)\r\n\t#{\r\n\t\t#order[i]=i;#[Tags]\/*预置第i个输入的学生*\/\r\n\t\t#[Keywords]for#(t=0,j=0;j<SCORES;j++)#[Tags]\/*求第i个学生的总分*\/\r\n\t\t\t#t+=students[i].scores[j];\r\n\t\t#total[i]=t;\r\n\t#}\r\n\t#\/*冒泡排序*\/\r\n\t#[Keywords]for#(i=0;i<n-1;i++)#[Tags]\/*共扫视n-1遍*\/\r\n\t\t#[Keywords]for#(j=0;j<n-1-i;j++)\r\n\t\t\t#[Keywords]if#(total[order[j]]<total[order[j+1]])\r\n\t\t\t#{#[Tags]\/*交换名次*\/\r\n\t\t\t #t=order[j];\r\n\t\t\t #order[j]=order[j+1];\r\n\t\t\t #order[j+1]=t;\r\n\t\t\t#}\r\n\t#[Keywords]for#(j=0;j<n;j++)#[Tags]\/*输出*\/\r\n\t\t#writeastu(students+order[j]);\r\n\t#printf(#[Fields]\"\\n Press any key to quit...\\n\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        35,
        "报数游戏",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\nstruct ele{\r\n\t#[Keywords]int #no;\r\n\t#struct ele *link;\r\n#}\r\nmain()\r\n{\r\n\t#[Keywords]int #n,m,i;\r\n\t#struct ele *h,*u,*p;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"Please input n&m:\\n\"#);\r\n\t#scanf(#[Fields]\"%d%d\"#,&n,&m);#[Tags]\/*输入n和m*\/\r\n\t#h=u=(struct ele *)malloc(sizeof(struct ele));#[Tags]\/*形成首表元*\/\r\n\t#h->no=1;\r\n\t#[Keywords]for#(i=2;i<=n;i++)#[Tags]\/*形成其余的n-1个表元*\/\r\n\t#{\r\n\t\t#u->link=(struct ele *)malloc(sizeof(struct ele));\r\n\t\t#u=u->link;\r\n\t\t#u->no=i;#[Tags]\/*第i个表元置编号i*\/\r\n\t#}\r\n\t#u->link=h;#[Tags]\/*末表元后继首表元，形成环*\/\r\n\t#puts(#[Fields]\"\\nThe numbers of who will quit the cycle in turn are:\"#);\r\n\t#[Keywords]while#(n)\r\n\t#{\r\n\t\t#[Keywords]for#(i=1;i<m;i++)#[Tags]\/*掠过m－1个表元*\/\r\n\t\t\t#u=u->link;\r\n\t\t#p=u->link;#[Tags]\/*p指向第m个表元*\/\r\n\t\t#u->link=p->link;#[Tags]\/*第m个表元从环中脱钩*\/\r\n\t\t#printf(#[Fields]\"%4d\"#,p->no);\r\n\t\t#free(p);#[Tags]\/*释放第m个表元占用的空间*\/\r\n\t\t#n--;\r\n\t#}\r\n\t#printf(#[Fields]\"\\n\\n Press any key to quit...\\n\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        36,
        "模拟社会关系",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define CHILDREN 5\r\nstruct person{\r\n\t#[Keywords]char #*name;#[Tags]\/*名字符串指针*\/\r\n\t#[Keywords]char #sex;#[Tags]\/*性别：男用字符#[Fields]'M'#；女用字符#[Fields]'F'#*\/\r\n\t#struct person *father;#[Tags]\/*指向父亲*\/\r\n\t#struct person *mother;#[Tags]\/*指向母亲*\/\r\n\t#struct person *mate;#[Tags]\/*指向配偶*\/\r\n\t#struct person *children[CHILDREN];#[Tags]\/*指向子女*\/\r\n#};\r\n#[Tags]\/* [函数]newperson增加新人 *\/\r\nstruct person *newperson(#[Keywords]char #*name,#[Keywords]char #sex)\r\n{\r\n\t#struct person *p;\r\n\t#[Keywords]int #index;\r\n\t#p=(struct person *)malloc(sizeof(struct person));\r\n\t#p->name=(#[Keywords]char #*)malloc(strlen(name)+1);\r\n\t#strcpy(p->name,name);\r\n\t#p->sex=sex;\r\n\t#p->father=NULL;\r\n\t#p->mother=NULL;\r\n\t#p->mate=NULL;\r\n\t#[Keywords]for#(index=0;index<CHILDREN;index++)\r\n\t\t#p->children[index]=NULL;\r\n\t#[Keywords]return #p;\r\n#}\r\n#[Tags]\/* [函数]father_child建立父－子关系 *\/\r\nfather_child(struct person *father,struct person *child)\r\n{\r\n\t#[Keywords]int #index;\r\n\t#[Keywords]for#(index=0;index<CHILDREN-1;index++)#[Tags]\/*寻找一个空缺的子女指针*\/\r\n\t\t#[Keywords]if#(father->children[index]==NULL)#[Tags]\/*若没有空缺，则填在最后*\/\r\n\t\t\t#[Keywords]break#;\r\n\t#father->children[index]=child;#[Tags]\/*建立父－子关系*\/\r\n\t#child->father=father;\r\n#}\r\n#[Tags]\/* [函数]mother_child建立母－子关系 *\/\r\nmother_child(struct person *mother,struct person *child)\r\n{\r\n\t#[Keywords]int #index;\r\n\t#[Keywords]for#(index=0;index<CHILDREN-1;index++)#[Tags]\/*寻找一个空缺的子女指针*\/\r\n\t\t#[Keywords]if#(mother->children[index]==NULL)#[Tags]\/*若没有空缺，则填在最后*\/\r\n\t\t\t#[Keywords]break#;\r\n\t#mother->children[index]=child;#[Tags]\/*建立母－子关系*\/\r\n#}\r\n#[Tags]\/* [函数]mate 建立配偶关系 *\/\r\nmate(struct person *h,struct person *w)\r\n{\r\n\t#h->mate=w;\/*建立配偶关系*\/\r\n\t#w->mate=h;\r\n#}\r\n#[Tags]\/* [函数]brotherinlow 检查两人是否是堂兄妹 *\/\r\n#[Keywords]int #brothersinlaw(struct person *p1,struct person *p2)\r\n{\r\n\t#struct person *f1,*f2;\r\n\t#[Keywords]if#(p1==NULL||p2==NULL||p1==p2) #[Keywords]return #0;\r\n\t#[Keywords]if#(p1->sex==p2->sex) #[Keywords]return #0;#[Tags]\/*不可能是堂兄妹*\/\r\n\t#f1=p1->father;\r\n\t#f2=p2->father;\r\n\t#[Keywords]if#(f1!=NULL&&f1==f2) #[Keywords]return #0;#[Tags]\/*是兄妹，不是堂兄妹*\/\r\n\t#[Keywords]while#(f1!=NULL&&f2!=NULL&&f1!=f2)#[Tags]\/*考虑远房情况*\/\r\n\t#{\r\n\t\t#f1=f1->father;\r\n\t\t#f2=f2->father;\r\n\t\t#[Keywords]if#(f1!=NULL&&f2!=NULL&&f1==f2) #[Keywords]return #1;\r\n\t#}\r\n\t#[Keywords]return #0;\r\n#}\r\n#[Tags]\/* 函数print_relate用于输出人物p的姓名，性别和各种关系 *\/\r\n#[Keywords]void #print_relate(struct person *p)\r\n{\r\n\t#[Keywords]int #index,i;\r\n\t#[Keywords]if#(p->name==NULL)\r\n\t\t#[Keywords]return#;#\r\n\t#[Keywords]if#(p->sex==#[Fields]'M'#)\r\n\t\t#printf(#[Fields]\" %s is male.\"#,p->name);\r\n\t#else\r\n\t\t#printf(#[Fields]\" %s is female.\"#,p->name);\r\n\t#[Keywords]if#(p->father!=NULL)\r\n\t\t#printf(#[Fields]\" %s#[Fields]'s father is %s.\"#,p->name,p->father->name);\r\n\t#[Keywords]if#(p->mother!=NULL)\r\n\t\t#printf(#[Fields]\" %s#[Fields]'s mother is %s.\"#,p->name,p->mother->name);\r\n\t#printf(#[Fields]\"\\n\"#);\r\n\t#[Keywords]if#(p->mate!=NULL)\r\n\t\t#[Keywords]if#(p->sex==#[Fields]'M'#)\r\n\t\t\t#printf(#[Fields]\" His wife is %s.\"#,p->mate->name);\r\n\t\t#else\r\n\t\t\t#printf(#[Fields]\" Her husband is %s.\"#,p->mate->name);\r\n\t#[Keywords]if#(p->children!=NULL)\r\n\t#{\t#[Keywords]for#(index=0;index<CHILDREN-1;index++)#[Tags]\/*寻找一个空缺的子女指针*\/\r\n\t\t#[Keywords]if#(p->children[index]==NULL)#[Tags]\/*若没有空缺，index为子女个数 *\/\r\n\t\t\t#[Keywords]break#;\r\n\t\t#[Keywords]if#(index>0)\r\n\t\t\t#printf(#[Fields]\" Children are:\"#);\r\n\t\t#[Keywords]for#(i=0;i<index;i++)\r\n\t\t\t#printf(#[Fields]\" %s\"#,p->children[i]->name);\r\n\t#}\r\n\t#printf(#[Fields]\"\\n\"#);\r\n#}\r\nmain()\r\n{\r\n\t#[Keywords]char #*name[8]={#[Fields]\"John\"#,#[Fields]\"Kate\"#,#[Fields]\"Maggie\"#,#[Fields]\"Herry\"#,#[Fields]\"Jason\"#,#[Fields]\"Peter\"#,#[Fields]\"Marry\"#,#[Fields]\"Jenny\"##};\r\n\t#[Keywords]char #male=#[Fields]'M'#,female=#[Fields]'F'#;\r\n\t#struct person *pGrandfather,*pFather1,*pFather2,*pMother1,*pMother2,*pSon,*pDaughter,*pCousin;\r\n\t#clrscr();\r\n\t#pGrandfather = newperson(name[0],male);\r\n\t#pFather1 = newperson(name[3],male);\r\n\t#pFather2 = newperson(name[4],male);\r\n\t#pMother1 = newperson(name[1],female);\r\n\t#pMother2 = newperson(name[2],female);\r\n\t#pSon = newperson(name[5],male);\r\n\t#pDaughter = newperson(name[6],female);\r\n\t#pCousin = newperson(name[7],female);\r\n\t#father_child(pGrandfather,pFather1);\r\n\t#father_child(pGrandfather,pFather2);\r\n\t#father_child(pFather1,pSon);\r\n\t#father_child(pFather1,pDaughter);\r\n\t#father_child(pFather2,pCousin);\r\n\t#mate(pFather1,pMother1);\r\n\t#mate(pFather2,pMother2);\r\n\t#mother_child(pMother1,pSon);\r\n\t#mother_child(pMother1,pDaughter);\r\n\t#mother_child(pMother2,pCousin);\r\n\t#[Tags]\/* 输出各种关系 *\/\r\n\t#print_relate(pGrandfather);\r\n\t#print_relate(pFather1);\r\n\t#print_relate(pFather2);\r\n\t#print_relate(pMother1);\r\n\t#print_relate(pMother2);\r\n\t#print_relate(pSon);\r\n\t#print_relate(pDaughter);\r\n\t#print_relate(pCousin);\r\n\t#[Keywords]if#(!brothersinlaw(pDaughter,pCousin))\r\n\t\t#printf(#[Fields]\"%s and %s are not brothers (sisters) in law.\\n\"#,pDaughter->name,pCousin->name);\r\n\t#else\r\n\t\t#printf(#[Fields]\"%s and %s are brothers (sisters) in law.\\n\"#,pDaughter->name,pCousin->name);\r\n\t#[Keywords]if#(!brothersinlaw(pSon,pCousin))\r\n\t\t#printf(#[Fields]\"%s and %s are not brothers (sisters) in law.\\n\"#,pSon->name,pCousin->name);\r\n\t#else\r\n\t\t#printf(#[Fields]\"%s and %s are brothers (sisters) in law.\\n\"#,pSon->name,pCousin->name);\r\n\t#[Keywords]if#(!brothersinlaw(pSon,pDaughter))\r\n\t\t#printf(#[Fields]\"%s and %s are not brothers (sisters) in law.\\n\"#,pSon->name,pDaughter->name);\r\n\t#else\r\n\t\t#printf(#[Fields]\"%s and %s are brothers (sisters) in law.\\n\"#,pSon->name,pDaughter->name);\r\n\r\n\t#puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        37,
        "统计文件的字符数",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\nmain()\r\n{\r\n\t#[Keywords]char #fname[80];#[Tags]\/*存贮文件名*\/\r\n\t#FILE *rfp;\r\n\t#[Keywords]long #count;#[Tags]\/*文件字符计数器*\/\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"Please input the file#[Fields]'s name:\\n\"#);\r\n\t#scanf(#[Fields]\"%s\"#,fname);\r\n\t#[Keywords]if#((rfp=fopen(fname,#[Fields]\"r\"#))==NULL)\r\n\t#{\r\n\t\t#printf(#[Fields]\"Can#[Fields]'t open file %s.\\n\"#,fname);\r\n\t\t#exit(1);\r\n\t#}\r\n\t#count=0;\r\n\t#[Keywords]while#(fgetc(rfp)!=EOF)\r\n\t\t#count++;\r\n\t#fclose(rfp);#[Tags]\/*关闭文件*\/\r\n\t#printf(#[Fields]\"There are %ld characters in file %s.\\n\"#,count,fname);\r\n\t#puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        38,
        "同时显示两个文件的内容",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define PAGELINE   20\r\n#define PAGESPLINE 2\r\n#define TXTWIDTH   30\r\n#define TXTGAP     10\r\nlinecount()#[Tags]\/*完成对输出行的计数和一页满后，输出空行*\/\r\n{\r\n\t#[Keywords]static #[Keywords]int #pline=0;\r\n\t#[Keywords]int #i;\r\n\t#[Keywords]if#(++pline==PAGELINE)\r\n\t#{\r\n\t\t#[Keywords]for#(i=0;i<PAGESPLINE;i++)#[Tags]\/*输出一页后的空行*\/\r\n\t\t\t#printf(#[Fields]\"\\n\"#);\r\n\t\t#pline=0;\r\n\t#}\r\n#}\r\n#[Keywords]int #readline(FILE *fpt)#[Tags]\/*完成从指定的文件中读出一行多至30个字符并输出*\/\r\n{\r\n\t#[Keywords]int #c,cpos=0;\r\n\t#[Keywords]while#((c=fgetc(fpt))!=#[Fields]'\\n'#)\r\n\t#{\r\n\t\t#[Keywords]if#(feof(fpt))\r\n\t\t\t#[Keywords]break#;#[Tags]\/*文件结束推出循环*\/\r\n\t\t#printf(#[Fields]\"%c\"#,c);\r\n\t\t#cpos++;\r\n\t\t#[Keywords]if#(cpos>=TXTWIDTH)\r\n\t\t\t#[Keywords]break#;\r\n\t#}\r\n\t#[Keywords]return #cpos;#[Tags]\/*返回读入并输出的字符数*\/\r\n#}\r\nmain()\r\n{\r\n\t#FILE *fpt1,*fpt2;\r\n\t#[Keywords]char #fname[120];#[Tags]\/*存贮文件名*\/\r\n\t#[Keywords]int #fill1,fill2;#[Tags]\/*分别记录两个文件当前行读入并输出的字符数*\/\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"Enter file 1 name.\\n\"#);\r\n\t#scanf(#[Fields]\"%s\"#,fname);\r\n\t#fpt1=fopen(fname,#[Fields]\"r\"#);#[Tags]\/*打开文件1*\/\r\n\t#[Keywords]if#(fpt1==NULL)\r\n\t#{\tprintf(#[Fields]\"Can#[Fields]'t open file %s.\\n\"#,fname);\r\n\t\t#exit(1);\r\n\t#}\r\n\t#printf(#[Fields]\"Enter file 2 name.\\n\"#);\r\n\t#scanf(#[Fields]\"%s\"#,fname);\r\n\t#fpt2=fopen(fname,#[Fields]\"r\"#);#[Tags]\/*打开文件2*\/\r\n\t#[Keywords]if#(fpt2==NULL)\r\n\t#{\tprintf(#[Fields]\"Can#[Fields]'t open file %s.\\n\"#,fname);\r\n\t\t#fclose(fpt1);\r\n\t\t#exit(2);\r\n\t#}\r\n\t#[Keywords]while#(!feof(fpt1)||!feof(fpt2))#[Tags]\/*在有文件还未结束时循环*\/\r\n\t#{\r\n\t\t#fill1=fill2=0;\r\n\t\t#[Keywords]if#(!feof(fpt1)) fill1=readline(fpt1);#[Tags]\/*在文件未结束时读文件*\/\r\n\t\t#printf(#[Fields]\"%*c\"#,TXTWIDTH-fill1+TXTGAP,#[Fields]''#);\r\n\t\t#[Keywords]if#(!feof(fpt2)) fill2=readline(fpt2);#[Tags]\/*在文件未结束时读文件*\/\r\n\t\t#printf(#[Fields]\"%*c%2d\\n\"#,TXTWIDTH-fill2+4,#[Fields]''#,fill1+fill2);\r\n\t\t#linecount();#[Tags]\/*调用行计数函数*\/\r\n\t#}\r\n\t#puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        39,
        "简单的文本编辑器",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define MAXLEN 80\r\n#define MAXLINE 200\r\n#[Keywords]char #buffer[MAXLEN],fname[120];\r\n#[Keywords]char #*lineptr[MAXLINE];\r\nFILE *fp;\r\n#[Keywords]void #edit(),replace(),insert(),delete(),quit();\r\n#[Keywords]char #comch[]=#[Fields]\"EeRrIiDdQq\"#;#[Tags]\/*命令符*\/\r\nvoid(*comfun[])()={edit,replace,insert,delete,quit#};#[Tags]\/*对应处理函数*\/\r\n#[Keywords]int #modified=0,#[Tags]\/*正文被修改标志*\/\r\n\t#last;#[Tags]\/*当前正文行数*\/\r\n#[Keywords]char #*chpt;#[Tags]\/*输入命令行字符指针*\/\r\nmain()\r\n{\r\n\t#[Keywords]int #j;\r\n\t#last=0;\r\n\t#[Keywords]while#(1)\r\n\t#{\r\n\t\t#printf(#[Fields]\"\\nInput a command:[e,r,i,d,q].\\n\"#);\r\n\t\t#gets(buffer);#[Tags]\/*读入命令行*\/\r\n\t\t#[Keywords]for#(chpt=buffer;*chpt==#[Fields]''#||*chpt==#[Fields]'\\t'#;chpt++);#[Tags]\/*掠过空白符*\/\r\n\t\t#[Keywords]if#(*chpt==#[Fields]'\\0'#) #[Keywords]continue#;#[Tags]\/*空行重新输入*\/\r\n\t\t#[Keywords]for#(j=0;comch[j]!=#[Fields]'\\0'#&&comch[j]!=*chpt;j++);#[Tags]\/*查命令符*\/\r\n\t\t#[Keywords]if#(comch[j]==#[Fields]'\\0'#) #[Keywords]continue#;#[Tags]\/*非法命令符*\/\r\n\t\t#chpt++;#[Tags]\/*掠过命令符，指向参数*\/\r\n\t\t#(*comfun[j\/2])();#[Tags]\/*执行对应函数*\/\r\n\t\t#fprintf(stdout,#[Fields]\"The text is:\\n\"#);\r\n\t\t#[Keywords]for#(j=0;j<last;j++)#[Tags]\/*显示正文*\/\r\n\t\t\t#fputs(lineptr[j],stdout);\r\n\t#}\r\n#}\r\n#[Keywords]void #quit()\r\n{\r\n\t#[Keywords]int #c;\r\n\t#[Keywords]if#(modified)#[Tags]\/* 如正文被修改 *\/\r\n\t#{\r\n\t\t#printf(#[Fields]\"Save? (y\/n)\"#);\r\n\t\t#[Keywords]while#(!(((c=getchar())>=#[Fields]'a'#&&c<=#[Fields]'z'#)||(c>=#[Fields]'A'#&&c<=#[Fields]'Z'#)));\r\n\t\t#[Keywords]if#(c==#[Fields]'y'#||c==#[Fields]'Y'#)\r\n\t\t\t#save(fname); #[Tags]\/* 保存被修改过的正文 *\/\r\n\t#}\r\n\t#[Keywords]for#(c=0;c<last;c++)\r\n\t\t#free(lineptr[c]);\t#[Tags]\/* 释放内存 *\/\r\n\t#exit(0);\r\n#}\r\n\r\n#[Keywords]void #insert()\r\n{\r\n\t#[Keywords]int #k,m,i;\r\n\t#sscanf(chpt,#[Fields]\"%d%d\"#,&k,&m);\t#[Tags]\/* 读入参数 *\/\r\n\t#[Keywords]if#(m<0||m>last||last+k>=MAXLINE)#[Tags]\/* 检查参数合理性 *\/\r\n\t#{\r\n\t\t#printf(#[Fields]\"Error!\\n\"#);\r\n\t\t#[Keywords]return#;#\r\n\t#}\r\n\t#[Keywords]for#(i=last;i>m;i--)#[Tags]\/* 后继行向后移 *\/\r\n\t\t#lineptr[i+k-1]=lineptr[i-1];\r\n\t#[Keywords]for#(i=0;i<k;i++)   #[Tags]\/* 读入k行正文，并插入 *\/\r\n\t#{\r\n\t\t#fgets(buffer,MAXLEN,stdin);\r\n\t\t#lineptr[m+i]=(#[Keywords]char #*)malloc(strlen(buffer)+1);\r\n\t\t#strcpy(lineptr[m+i],buffer);\r\n\t#}\r\n\t#last+=k;\t#[Tags]\/* 修正正文行数 *\/\r\n\t#modified=1;\t#[Tags]\/* 正文被修改 *\/\r\n#}\r\n#[Keywords]void #delete()\r\n{\r\n\t#[Keywords]int #i,j,m,n;\r\n\t#sscanf(chpt,#[Fields]\"%d%d\"#,&m,&n);\t#[Tags]\/* 读入参数 *\/\r\n\t#[Keywords]if#(m<=0||m>last||n<m)\t#[Tags]\/* 检查参数合理性 *\/\r\n\t#{\r\n\t\t#printf(#[Fields]\"Error!\\n\"#);\r\n\t\t#[Keywords]return#;#\r\n\t#}\r\n\t#[Keywords]if#(n>last)\r\n\t\t#n=last;\t\t#[Tags]\/* 修正参数 *\/\r\n\t#[Keywords]for#(i=m;i<=n;i++)\t#[Tags]\/* 删除正文 *\/\r\n\t\t#free(lineptr[i-1]);\r\n\t#[Keywords]for#(i=m,j=n+1;j<=last;i++,j++)\r\n\t\t#lineptr[i-1]=lineptr[j-1];\r\n\t#last=i-1;\t#[Tags]\/* 修正正文行数 *\/\r\n\t#modified=1;\t#[Tags]\/* 正文被修改 *\/\r\n#}\r\n#[Keywords]void #replace()\r\n{\r\n\t#[Keywords]int #k,m,n,i,j;\r\n\t#sscanf(chpt,#[Fields]\"%d%d%d\"#,&k,&m,&n);\t#[Tags]\/* 读入参数 *\/\r\n\t#[Keywords]if#(m<=0||m>last||n<m||last-(n-m+1)+k>=MAXLINE)#[Tags]\/* 检查参数合理性 *\/\r\n\t#{\r\n\t\t#printf(#[Fields]\"Error!\\n\"#);\r\n\t\t#[Keywords]return#;#\r\n\t#}\r\n\t#\/* 先完成删除 *\/\r\n\t#[Keywords]if#(n>last)\r\n\t\t#n=last;\t\t#[Tags]\/* 修正参数 *\/\r\n\t#[Keywords]for#(i=m;i<=n;i++)\t#[Tags]\/* 删除正文 *\/\r\n\t\t#free(lineptr[i-1]);\r\n\t#[Keywords]for#(i=m,j=n+1;j<=last;i++,j++)\r\n\t\t#lineptr[i-1]=lineptr[j-1];\r\n\t#last=i-1;\r\n\t#\/* 以下完成插入 *\/\r\n\t#[Keywords]for#(i=last;i>=m;i--)\r\n\t\t#lineptr[i+k-1]=lineptr[i-1];\r\n\t#[Keywords]for#(i=0;i<k;i++)\r\n\t#{\r\n\t\t#fgets(buffer,MAXLEN,stdin);\r\n\t\t#lineptr[m+i-1]=(#[Keywords]char #*)malloc(strlen(buffer)+1);\r\n\t\t#strcpy(lineptr[m+i-1],buffer);\r\n\t#}\r\n\t#last+=k;\t#[Tags]\/* 修正正文行数 *\/\r\n\t#modified=1;\t#[Tags]\/* 正文被修改 *\/\r\n#}\r\nsave(#[Keywords]char #*fname)\t#[Tags]\/* 保存文件 *\/\r\n{\r\n\t#[Keywords]int #i;\r\n\t#FILE *fp;\r\n\t#[Keywords]if#((fp=fopen(fname,#[Fields]\"w\"#))==NULL)\r\n\t#{\r\n\t\t#fprintf(stderr,#[Fields]\"Can#[Fields]'t open %s.\\n\"#,fname);\r\n\t\t#exit(1);\r\n\t#}\r\n\t#[Keywords]for#(i=0;i<last;i++)\r\n\t#{\r\n\t\t#fputs(lineptr[i],fp);\r\n\t\t#free(lineptr[i]);\r\n\t#}\r\n\t#fclose(fp);\r\n#}\r\n#[Keywords]void #edit()\t#[Tags]\/* 编辑命令 *\/\r\n{\r\n\t#[Keywords]int #i;\r\n\t#FILE *fp;\r\n\t#i=sscanf(chpt,#[Fields]\"%s\"#,fname);\t#[Tags]\/* 读入文件名 *\/\r\n\t#[Keywords]if#(i!=1)\r\n\t#{\r\n\t\t#printf(#[Fields]\"Enter file name.\\n\"#);\r\n\t\t#scanf(#[Fields]\"%s\"#,fname);\r\n\t#}\r\n\t#[Keywords]if#((fp=fopen(fname,#[Fields]\"r\"#))==NULL) #[Tags]\/* 读打开 *\/\r\n\t#{\r\n\t\t#fp=fopen(fname,#[Fields]\"w\"#);\t#[Tags]\/* 如不存在，则创建文件 *\/\r\n\t\t#fclose(fp);\r\n\t\t#fp=fopen(fname,#[Fields]\"r\"#);\t#[Tags]\/* 重新读打开 *\/\r\n\t#}\r\n\t#i=0;\r\n\t#[Keywords]while#(fgets(buffer,MAXLEN,fp)==buffer)\r\n\t#{\r\n\t\t#lineptr[i]=(#[Keywords]char #*)malloc(strlen(buffer)+1);\r\n\t\t#strcpy(lineptr[i++],buffer);\r\n\t#}\r\n\t#fclose(fp);\r\n\t#last=i;\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        40,
        "文件的字数统计程序",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/*\r\n#[Tags]该程序实现统计一个或多个文件的行数、字数和字符数。\r\n#[Tags]一个行由一个换行符限定，一个字由空格分隔（包括空白符、制表符和换行符），\r\n#[Tags]字符是指文件中的所有字符。要求程序另设三个任选的参数，\r\n#[Tags]让用户指定他所要的统计。它们是：\r\n#[Tags]1 统计文件行数\r\n#[Tags]w 统计文件字数\r\n#[Tags]c 统计文件字符数\r\n#[Tags]若用户未指定任选的参数，则表示三个统计都要。\r\n#[Tags]运行本程序时的参数按一下格式给出：\r\n#[Tags]-l -w -c 文件 文件 ... 文件\r\n#[Tags]其中，前三个任选参数l、w、c的出现与否和出现顺序任意，\r\n#[Tags]或任意组合在一起出现，如：-lwc，-cwl，-lw，-wl，-lc，-cl，－cw等。\r\n#[Tags]*\/\r\n#include <stdio.h>\r\nmain(#[Keywords]int #argc, #[Keywords]char #**argv )\r\n{\r\n\t#FILE *fp;\r\n\t#[Keywords]int #lflg,wflg,cflg; #[Tags]\/* l, w, c三个标志 *\/\r\n\t#[Keywords]int #inline,inword; #[Tags]\/* 行内和字内标志 *\/\r\n\t#[Keywords]int #ccount,wcount,lcount; #[Tags]\/* 字符，字，行 计数器 *\/\r\n\t#[Keywords]int #c;\r\n\t#[Keywords]char #*s;\r\n\t#lflg=wflg=cflg=0;\r\n\t#[Keywords]if#(argc<2)\r\n\t#{\r\n\t\t#printf(#[Fields]\"To run #[Keywords]this# program, usage: program -l -w -c file1 file2 ... filen \\n\"#);\r\n\t\t#exit(0);\r\n\t#}\r\n\t#[Keywords]while#(--argc>=1&&(*++argv)[0]==#[Fields]'-'#)\r\n\t#{\r\n\t\t#[Keywords]for#(s=argv[0]+1;*s!=#[Fields]'\\0'#;s++)\r\n\t\t#{\r\n\t\t\t#switch(*s)\r\n\t\t\t#{\r\n\t\t\t\t#[Keywords]case ##[Fields]'l'#: \r\n\t\t\t\t\t#lflg=1;\r\n\t\t\t\t\t#[Keywords]break#;\r\n\t\t\t\t#[Keywords]case ##[Fields]'w'#:\r\n\t\t\t\t\t#wflg=1;\r\n\t\t\t\t\t#[Keywords]break#;\r\n\t\t\t\t#[Keywords]case ##[Fields]'c'#:\r\n\t\t\t\t\t#cflg=1;\r\n\t\t\t\t\t#[Keywords]break#;\r\n\t\t\t\t#[Keywords]default#:\r\n\t\t\t\t\t#puts(#[Fields]\"To run #[Keywords]this# program, usage: program -l -w -c file1 file2 ... filen\"#);\r\n\t\t\t\t\t#exit(0);\r\n\t\t\t#}\r\n\t\t#}\r\n\t#}\r\n\t#[Keywords]if#(lflg==0&&wflg==0&&cflg==0)\r\n\t\t#lflg=wflg=cflg=1;\r\n\t#lcount=wcount=ccount=0;\r\n\t#[Keywords]while#(--argc>=0)\r\n\t#{\r\n\t\t#[Keywords]if#((fp=fopen(*argv++,#[Fields]\"r\"#))==NULL)\t#[Tags]\/* 以只读方式打开文件 *\/\r\n\t\t#{\r\n\t\t\t#fprintf(stderr,#[Fields]\"Can#[Fields]'t open %s.\\n\"#,*argv);\r\n\t\t\t#[Keywords]continue#;\r\n\t\t#}\r\n\t\t#inword=inline=0;\r\n\t\t#[Keywords]while#((c=fgetc(fp))!=EOF)\r\n\t\t#{\r\n\t\t\t#[Keywords]if#(cflg)\r\n\t\t\t\t#ccount++;\r\n\t\t\t#[Keywords]if#(wflg)\r\n\t\t\t\t#[Keywords]if#(c==#[Fields]'\\n'#||c==#[Fields]' '#||c==#[Fields]'\\t'#)\r\n\t\t\t\t\t#inword=0;\r\n\t\t\t\t#[Keywords]else #[Keywords]if#(inword==0)\r\n\t\t\t\t#{\r\n\t\t\t\t\t#wcount++;\r\n\t\t\t\t\t#inword=1;\r\n\t\t\t\t#}\r\n\t\t\t#[Keywords]if#(lflg)\r\n\t\t\t\t#[Keywords]if#(c==#[Fields]'\\n'#)\r\n\t\t\t\t\t#inline=0;\r\n\t\t\t\t#[Keywords]else #[Keywords]if#(inline==0)\r\n\t\t\t\t#{\r\n\t\t\t\t\t#lcount++;\r\n\t\t\t\t\t#inline=1;\r\n\t\t\t\t#}\r\n\t\t#}\r\n\t\t#fclose(fp);\t#[Tags]\/* 关闭文件 *\/\r\n\t#}\r\n\t#[Keywords]if#(lflg)\r\n\t\t#printf(#[Fields]\" Lines =         %d\\n\"#,lcount);\r\n\t#[Keywords]if#(wflg)\r\n\t\t#printf(#[Fields]\" Words =         %d\\n\"#,wcount);\r\n\t#[Keywords]if#(cflg)\r\n\t\t#printf(#[Fields]\" Characters =    %d\\n\"#,ccount);\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        41,
        "学生成绩管理程序",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/*\r\n#[Tags]学生成绩管理程序\r\n#[Tags]编制一个统计学生考试分数的管理程序。\r\n#[Tags]设学生成绩已以一个学生一个记录的形式存储在文件中，\r\n#[Tags]每位学生记录包含的信息有：姓名，学号和各门功课的成绩。\r\n#[Tags]程序具有以下几项功能：求出各门课程的总分，平均分，按姓名，\r\n#[Tags]按学号寻找其记录并显示，浏览全部学生成绩和按总分由高到低显示学生信息等。\r\n#[Tags]*\/\r\n#include <stdio.h>\r\n#define\tSWN\t\t3\t#[Tags]\/* 课程数 *\/\r\n#define NAMELEN\t\t20\t#[Tags]\/* 姓名最大字符数 *\/\r\n#define CODELEN\t\t10\t#[Tags]\/* 学号最大字符数 *\/\r\n#define FNAMELEN\t80\t#[Tags]\/* 文件名最大字符数 *\/\r\n#define BUFLEN\t\t80\t#[Tags]\/* 缓冲区最大字符数 *\/\r\n#[Tags]\/* 课程名称表 *\/\r\n#[Keywords]char #schoolwork[SWN][NAMELEN+1] = {#[Fields]\"Chinese\"#,#[Fields]\"Mathematic\"#,#[Fields]\"English\"##};\r\nstruct record\r\n{\r\n\t#char\tname[NAMELEN+1];\t#[Tags]\/* 姓名 *\/\r\n\t#[Keywords]char #\tcode[CODELEN+1];\t#[Tags]\/* 学号 *\/\r\n\t#[Keywords]int #\tmarks[SWN];\t\t#[Tags]\/* 各课程成绩 *\/\r\n\t#[Keywords]int #total;\t\t\t#[Tags]\/* 总分 *\/\r\n#}stu;\r\nstruct node\r\n{\r\n\t#char\tname[NAMELEN+1];\t#[Tags]\/* 姓名 *\/\r\n\t#[Keywords]char #\tcode[CODELEN+1];\t#[Tags]\/* 学号 *\/\r\n\t#[Keywords]int #\tmarks[SWN];\t\t#[Tags]\/* 各课程成绩 *\/\r\n\t#[Keywords]int #\ttotal;\t\t\t#[Tags]\/* 总分 *\/\r\n\t#struct\tnode *next;\t\t#[Tags]\/* 后续表元指针 *\/\r\n#}*head;\t#[Tags]\/* 链表首指针 *\/\r\n#[Keywords]int #total[SWN];\t\t#[Tags]\/* 各课程总分 *\/\r\nFILE *stfpt;\t\t#[Tags]\/* 文件指针 *\/\r\n#[Keywords]char #stuf[FNAMELEN];\t#[Tags]\/* 文件名 *\/\r\n#[Tags]\/* 从指定文件读入一个记录 *\/\r\n#[Keywords]int #readrecord(FILE *fpt,struct record *rpt)\r\n{\r\n\t#[Keywords]char #buf[BUFLEN];\r\n\t#[Keywords]int #i;\r\n\t#[Keywords]if#(fscanf(fpt,#[Fields]\"%s\"#,buf)!=1)\r\n\t\t#[Keywords]return #0;\t#[Tags]\/* 文件结束 *\/\r\n\t#strncpy(rpt->name,buf,NAMELEN);\r\n\t#fscanf(fpt,#[Fields]\"%s\"#,buf);\r\n\t#strncpy(rpt->code,buf,CODELEN);\r\n\t#[Keywords]for#(i=0;i<SWN;i++)\r\n\t\t#fscanf(fpt,#[Fields]\"%d\"#,&rpt->marks[i]);\r\n\t#[Keywords]for#(rpt->total=0,i=0;i<SWN;i++)\r\n\t\t#rpt->total+=rpt->marks[i];\r\n\t#[Keywords]return #1;\r\n#}\r\n#[Tags]\/* 对指定文件写入一个记录 *\/\r\nwriterecord(FILE *fpt,struct record *rpt)\r\n{\r\n\t#[Keywords]int #i;\r\n\t#fprintf(fpt,#[Fields]\"%s\\n\"#,rpt->name);\r\n\t#fprintf(fpt,#[Fields]\"%s\\n\"#,rpt->code);\r\n\t#[Keywords]for#(i=0;i<SWN;i++)\r\n\t\t#fprintf(fpt,#[Fields]\"%d\\n\"#,rpt->marks[i]);\r\n\t#[Keywords]return #;\r\n#}\r\n#[Tags]\/* 显示学生记录 *\/\r\ndisplaystu(struct record *rpt)\r\n{\r\n\t#[Keywords]int #i;\r\n\t#printf(#[Fields]\"\\nName   : %s\\n\"#,rpt->name);\r\n\t#printf(#[Fields]\"Code   : %s\\n\"#,rpt->code);\r\n\t#printf(#[Fields]\"Marks  :\\n\"#);\r\n\t#[Keywords]for#(i=0;i<SWN;i++)\r\n\t\t#printf(#[Fields]\"       %-15s : %4d\\n\"#,schoolwork[i],rpt->marks[i]);\r\n\t#printf(#[Fields]\"Total  : %4d\\n\"#,rpt->total);\r\n#}\r\n#[Tags]\/* 计算各单科总分 *\/\r\n#[Keywords]int #totalmark(#[Keywords]char #*fname)\r\n{\r\n\t#FILE *fp;\r\n\t#struct record s;\r\n\t#[Keywords]int #count,i;\r\n\t#[Keywords]if#((fp=fopen(fname,#[Fields]\"r\"#))==NULL)\r\n\t#{\r\n\t\t#printf(#[Fields]\"Can#[Fields]'t open file %s.\\n\"#,fname);\r\n\t\t#[Keywords]return #0;\r\n\t#}\r\n\t#[Keywords]for#(i=0;i<SWN;i++)\r\n\t\t#total[i]=0;\r\n\t#count=0;\r\n\t#[Keywords]while#(readrecord(fp,&s)!=0)\r\n\t#{\r\n\t\t#[Keywords]for#(i=0;i<SWN;i++)\r\n\t\t\t#total[i]+=s.marks[i];\r\n\t\t#count++;\r\n\t#}\r\n\t#fclose(fp);\r\n\t#[Keywords]return #count;\t#[Tags]\/* 返回记录数 *\/\r\n#}\r\n#[Tags]\/* 列表显示学生信息 *\/\r\n#[Keywords]void #liststu(#[Keywords]char #*fname)\r\n{\r\n\t#FILE *fp;\r\n\t#struct record s;\r\n\t#[Keywords]if#((fp=fopen(fname,#[Fields]\"r\"#))==NULL)\r\n\t#{\r\n\t\t#printf(#[Fields]\"Can#[Fields]'t open file %s.\\n\"#,fname);\r\n\t\t#[Keywords]return #;\r\n\t#}\r\n\t#[Keywords]while#(readrecord(fp,&s)!=0)\r\n\t#{\r\n\t\t#displaystu(&s);\r\n\t\t#printf(#[Fields]\"\\n      Press ENTER to #[Keywords]continue#...\\n\"#);\r\n\t\t#[Keywords]while#(getchar()!=#[Fields]'\\n'#);\r\n\t#}\r\n\t#fclose(fp);\r\n\t#[Keywords]return#;#\r\n#}\r\n#[Tags]\/* 构造链表 *\/\r\nstruct node *makelist(#[Keywords]char #*fname)\r\n{\r\n\t#FILE *fp;\r\n\t#struct record s;\r\n\t#struct node *p,*u,*v,*h;\r\n\t#[Keywords]int #i;\r\n\t#[Keywords]if#((fp=fopen(fname,#[Fields]\"r\"#))==NULL)\r\n\t#{\r\n\t\t#printf(#[Fields]\"Can#[Fields]'t open file %s.\\n\"#,fname);\r\n\t\t#[Keywords]return #NULL;\r\n\t#}\r\n\t#h=NULL;\r\n\t#p=(struct node *)malloc(sizeof(struct node));\r\n\t#[Keywords]while#(readrecord(fp,(struct record *)p)!=0)\r\n\t#{\r\n\t\t#v=h;\r\n\t\t#[Keywords]while#(v&&p->total<=v->total)\r\n\t\t#{\r\n\t\t\t#u=v;\r\n\t\t\t#v=v->next;\r\n\t\t#}\r\n\t\t#[Keywords]if#(v==h)\r\n\t\t\t#h=p;\r\n\t\t#else\r\n\t\t\t#u->next=p;\r\n\t\t#p->next=v;\r\n\t\t#p=(struct node *)malloc(sizeof(struct node));\r\n\t#}\r\n\t#free(p);\r\n\t#fclose(fp);\r\n\t#[Keywords]return #h;\r\n#}\r\n#[Tags]\/* 顺序显示链表各表元 *\/\r\n#[Keywords]void #displaylist(struct node *h)\r\n{\r\n\t#[Keywords]while#(h!=NULL)\r\n\t#{\r\n\t\t#displaystu((struct record *)h);\r\n\t\t#printf(#[Fields]\"\\n      Press ENTER to #[Keywords]continue#...\\n\"#);\r\n\t\t#[Keywords]while#(getchar()!=#[Fields]'\\n'#);\r\n\t\t#h=h->next;\r\n\t#}\r\n\t#[Keywords]return#;#\r\n#}\r\n#[Tags]\/* 按学生姓名查找学生记录 *\/\r\n#[Keywords]int #retrievebyn(#[Keywords]char #*fname, #[Keywords]char #*key)\r\n{\r\n\t#FILE *fp;\r\n\t#[Keywords]int #c;\r\n\t#struct record s;\r\n\t#[Keywords]if#((fp=fopen(fname,#[Fields]\"r\"#))==NULL)\r\n\t#{\r\n\t\t#printf(#[Fields]\"Can#[Fields]'t open file %s.\\n\"#,fname);\r\n\t\t#[Keywords]return #0;\r\n\t#}\r\n\t#c=0;\r\n\t#[Keywords]while#(readrecord(fp,&s)!=0)\r\n\t#{\r\n\t\t#[Keywords]if#(strcmp(s.name,key)==0)\r\n\t\t#{\r\n\t\t\t#displaystu(&s);\r\n\t\t\t#c++;\r\n\t\t#}\r\n\t#}\r\n\t#fclose(fp);\r\n\t#[Keywords]if#(c==0)\r\n\t\t#printf(#[Fields]\"The student %s is not in the file %s.\\n\"#,key,fname);\r\n\t#[Keywords]return #1;\r\n#}\r\n#[Tags]\/* 按学生学号查找学生记录 *\/\r\n#[Keywords]int #retrievebyc(#[Keywords]char #*fname, #[Keywords]char #*key)\r\n{\r\n\t#FILE *fp;\r\n\t#[Keywords]int #c;\r\n\t#struct record s;\r\n\t#[Keywords]if#((fp=fopen(fname,#[Fields]\"r\"#))==NULL)\r\n\t#{\r\n\t\t#printf(#[Fields]\"Can#[Fields]'t open file %s.\\n\"#,fname);\r\n\t\t#[Keywords]return #0;\r\n\t#}\r\n\t#c=0;\r\n\t#[Keywords]while#(readrecord(fp,&s)!=0)\r\n\t#{\r\n\t\t#[Keywords]if#(strcmp(s.code,key)==0)\r\n\t\t#{\r\n\t\t\t#displaystu(&s);\r\n\t\t\t#c++;\r\n\t\t\t#[Keywords]break#;\r\n\t\t#}\r\n\t#}\r\n\t#fclose(fp);\r\n\t#[Keywords]if#(c==0)\r\n\t\t#printf(#[Fields]\"The student %s is not in the file %s.\\n\"#,key,fname);\r\n\t#[Keywords]return #1;\r\n#}\r\nmain()\r\n{\r\n\t#[Keywords]int #i,j,n;\r\n\t#[Keywords]char #c;\r\n\t#[Keywords]char #buf[BUFLEN];\r\n\t#FILE *fp;\r\n\t#struct record s;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"Please input the students marks record file#[Fields]'s name: \"#);\r\n\t#scanf(#[Fields]\"%s\"#,stuf);\r\n\t#[Keywords]if#((fp=fopen(stuf,#[Fields]\"r\"#))==NULL)\r\n\t#{\r\n\t\t#printf(#[Fields]\"The file %s doesn#[Fields]'t exit, #[Keywords]do #you want to creat it? (Y\/N) \"#,stuf);\r\n\t\t#getchar();\r\n\t\t#c=getchar();\r\n\t\t#[Keywords]if#(c==#[Fields]'Y'#||c==#[Fields]'y'#)\r\n\t\t#{\r\n\t\t\t#fp=fopen(stuf,#[Fields]\"w\"#);\r\n\t\t\t#printf(#[Fields]\"Please input the record number you want to write to the file: \"#);\r\n\t\t\t#scanf(#[Fields]\"%d\"#,&n);\r\n\t\t\t#[Keywords]for#(i=0;i<n;i++)\r\n\t\t\t#{\r\n\t\t\t\t#printf(#[Fields]\"Input the student#[Fields]'s name: \"#);\r\n\t\t\t\t#scanf(#[Fields]\"%s\"#,&s.name);\r\n\t\t\t\t#printf(#[Fields]\"Input the student#[Fields]'s code: \"#);\r\n\t\t\t\t#scanf(#[Fields]\"%s\"#,&s.code);\r\n\t\t\t\t#[Keywords]for#(j=0;j<SWN;j++)\r\n\t\t\t\t#{\r\n\t\t\t\t\t#printf(#[Fields]\"Input the %s mark: \"#,schoolwork[j]);\r\n\t\t\t\t\t#scanf(#[Fields]\"%d\"#,&s.marks[j]);\r\n\t\t\t\t#}\r\n\t\t\t\t#writerecord(fp,&s);\r\n\t\t\t#}\r\n\t\t\t#fclose(fp);\r\n\t\t#}\r\n\t#}\r\n\t#fclose(fp);\r\n\t#getchar();\r\n\t#\/*clrscr();*\/\r\n\t#puts(#[Fields]\"Now you can input a command to manage the records.\"#);\r\n\t#puts(#[Fields]\"m : mean of the marks.\"#);\r\n\t#puts(#[Fields]\"t : total of the marks.\"#);\r\n\t#puts(#[Fields]\"n : search record by student#[Fields]'s name.\"#);\r\n\t#puts(#[Fields]\"c : search record by student#[Fields]'s code.\"#);\r\n\t#puts(#[Fields]\"l : list all the records.\"#);\r\n\t#puts(#[Fields]\"s : sort and list the records by the total.\"#);\r\n\t#puts(#[Fields]\"q : quit!\"#);\r\n\t#[Keywords]while#(1)\r\n\t#{\r\n\t\t#puts(#[Fields]\"Please input command:\"#);\r\n\t\t#scanf(#[Fields]\" %c\"#,&c);\t\t#[Tags]\/* 输入选择命令 *\/\r\n\t\t#[Keywords]if#(c==#[Fields]'q'#||c==#[Fields]'Q'#)\r\n\t\t#{\r\n\t\t\t#puts(#[Fields]\"\\n Thank you #[Keywords]for #your using.\"#);\r\n\t\t\t#[Keywords]break#;\t\t#[Tags]\/* q，结束程序运行 *\/\r\n\t\t#}\r\n\t\t#switch(c)\r\n\t\t#{\r\n\t\t\t#[Keywords]case ##[Fields]'m'#: #[Tags]\/* 计算平均分 *\/\r\n\t\t\t#[Keywords]case ##[Fields]'M'#:\r\n\t\t\t\t#[Keywords]if#((n=totalmark(stuf))==0)\r\n\t\t\t\t#{\r\n\t\t\t\t\t#puts(#[Fields]\"Error!\"#);\r\n\t\t\t\t\t#[Keywords]break#;\r\n\t\t\t\t#}\r\n\t\t\t\t#printf(#[Fields]\"\\n\"#);\r\n\t\t\t\t#[Keywords]for#(i=0;i<SWN;i++)\r\n\t\t\t\t\t#printf(#[Fields]\"%-15s#[Fields]'s average is: %.2f.\\n\"#,schoolwork[i],(#[Keywords]float#)total[i]\/n);\r\n\t\t\t\t#[Keywords]break#;\r\n\t\t\t#[Keywords]case ##[Fields]'t'#: #[Tags]\/* 计算总分 *\/\r\n\t\t\t#[Keywords]case ##[Fields]'T'#:\r\n\t\t\t\t#[Keywords]if#((n=totalmark(stuf))==0)\r\n\t\t\t\t#{\r\n\t\t\t\t\t#puts(#[Fields]\"Error!\"#);\r\n\t\t\t\t\t#[Keywords]break#;\r\n\t\t\t\t#}\r\n\t\t\t\t#printf(#[Fields]\"\\n\"#);\r\n\t\t\t\t#[Keywords]for#(i=0;i<SWN;i++)\r\n\t\t\t\t\t#printf(#[Fields]\"%-15s#[Fields]'s total mark is: %d.\\n\"#,schoolwork[i],total[i]);\r\n\t\t\t\t#[Keywords]break#;\r\n\t\t\t#[Keywords]case ##[Fields]'n'#: #[Tags]\/* 按学生的姓名寻找记录 *\/\r\n\t\t\t#[Keywords]case ##[Fields]'N'#:\r\n\t\t\t\t#printf(#[Fields]\"Please input the student#[Fields]'s name you want to search: \"#);\r\n\t\t\t\t#scanf(#[Fields]\"%s\"#,buf);\r\n\t\t\t\t#retrievebyn(stuf,buf);\r\n\t\t\t\t#[Keywords]break#;\r\n\t\t\t#[Keywords]case ##[Fields]'c'#: #[Tags]\/* 按学生的学号寻找记录 *\/\r\n\t\t\t#[Keywords]case ##[Fields]'C'#:\r\n\t\t\t\t#printf(#[Fields]\"Please input the student#[Fields]'s code you want to search: \"#);\r\n\t\t\t\t#scanf(#[Fields]\"%s\"#,buf);\r\n\t\t\t\t#retrievebyc(stuf,buf);\r\n\t\t\t\t#[Keywords]break#;\r\n\t\t\t#[Keywords]case ##[Fields]'l'#: #[Tags]\/* 列出所有学生记录 *\/\r\n\t\t\t#[Keywords]case ##[Fields]'L'#:\r\n\t\t\t\t#liststu(stuf);\r\n\t\t\t\t#[Keywords]break#;\r\n\t\t\t#[Keywords]case ##[Fields]'s'#: #[Tags]\/* 按总分从高到低排列显示 *\/\r\n\t\t\t#[Keywords]case ##[Fields]'S'#:\r\n\t\t\t\t#[Keywords]if#((head=makelist(stuf))!=NULL)\r\n\t\t\t\t\t#displaylist(head);\r\n\t\t\t\t#[Keywords]break#;\r\n\t\t\t#[Keywords]default#: #[Keywords]break#;\r\n\t\t#}\r\n\t#}\r\n#}\r\n[\/code]",
        8,
        118,
        1
      ],
      [
        100,
        "数据结构篇",
        "",
        9,
        119,
        1
      ],
      [
        101,
        "插入排序",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define MAX 255\r\n#[Keywords]int #R[MAX];\r\n#[Keywords]void #Insert_Sort(#[Keywords]int #n)\r\n{\r\n    #[Tags]\/* 对数组R中的记录R[1..n]按递增序进行插入排序  *\/\r\n    #[Keywords]int #i,j ;\r\n    #[Tags]\/* 依次插入R[2]，…，R[n] *\/\r\n    #[Keywords]for#(i=2;i<=n;i++)#[Keywords]if#(R[i]<R[i-1])\r\n    #{\r\n        #[Tags]\/* 若R[i]大于等于有序区中所有的R，则R[i] *\/\r\n        #[Tags]\/* 应在原有位置上 *\/\r\n        #R[0]=R[i];\r\n        #j=i-1 ;\r\n        #[Tags]\/* R[0]是哨兵，且是R[i]的副本 *\/\r\n        #[Keywords]do #\r\n        #{\r\n            #[Tags]\/* 从右向左在有序区R[1．．i-1]中查找R[i]的插入位置 *\/\r\n            #R[j+1]=R[j];\r\n            #[Tags]\/* 将关键字大于R[i]的记录后移 *\/\r\n            #j--;\r\n        #}\r\n       #[Keywords] while#(R[0]<R[j]);\r\n        #[Tags]\/* 当R[i]≥R[j]时终止 *\/\r\n        #R[j+1]=R[0];\r\n        #[Tags]\/* R[i]插入到正确的位置上 *\/\r\n    #}\r\n#}\r\nmain()\r\n{\r\n    #[Keywords]int #i,n ;\r\n    #clrscr();\r\n    #puts(#[Fields]\"Please input total element number of the sequence:\"#);\r\n    #scanf(#[Fields]\"%d\"#,&n);\r\n    #[Keywords]if#(n<=0||n>MAX)\r\n    #{\r\n        #printf(#[Fields]\"n must more than 0 and less than %d.\\n\"#,MAX);\r\n        #exit(0);\r\n    #}\r\n    #puts(#[Fields]\"Please input the elements one by one:\"#);\r\n    #[Keywords]for#(i=1;i<=n;i++)\r\n    #scanf(#[Fields]\"%d\"#,&R[i]);\r\n    #puts(#[Fields]\"The sequence you input is:\"#);\r\n    #[Keywords]for#(i=1;i<=n;i++)\r\n    #printf(#[Fields]\"%4d\"#,R[i]);\r\n    #Insert_Sort(n);\r\n    #puts(#[Fields]\"\\nThe sequence after insert_sort is:\"#);\r\n    #[Keywords]for#(i=1;i<=n;i++)\r\n    #printf(#[Fields]\"%4d\"#,R[i]);\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getchar();\r\n    #getchar();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        102,
        "希尔排序",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define MAX 255\r\n#[Keywords]int #R[MAX];\r\n#[Keywords]void #Bubble_Sort(#[Keywords]int #n)\r\n{ #[Tags]\/* R（l..n)是待排序的文件，采用自下向上扫描，对R做冒泡排序 *\/\r\n     #[Keywords]int #i,j;\r\n     #[Keywords]int #exchange; #[Tags]\/* 交换标志 *\/\r\n     #[Keywords]for#(i=1;i<n;i++){ #[Tags]\/* 最多做n-1趟排序 *\/\r\n       #exchange=0; #[Tags]\/* 本趟排序开始前，交换标志应为假 *\/\r\n       #[Keywords]for#(j=n-1;j>=i;j--) #[Tags]\/* 对当前无序区R[i..n]自下向上扫描 *\/\r\n        #[Keywords]if#(R[j+1]<R[j]){#[Tags]\/* 交换记录 *\/\r\n          #R[0]=R[j+1]; #[Tags]\/* R[0]不是哨兵，仅做暂存单元 *\/\r\n          #R[j+1]=R[j];\r\n          #R[j]=R[0];\r\n          #exchange=1; #[Tags]\/* 发生了交换，故将交换标志置为真 *\/\r\n         #}\r\n       #[Keywords]if#(!exchange) #[Tags]\/* 本趟排序未发生交换，提前终止算法 *\/\r\n\t     #[Keywords]return#;#\r\n     #}\r\n#}\r\n#[Keywords]void #main()\r\n{\r\n\t#[Keywords]int #i,n;\r\n\t#clrscr();\r\n\t#puts(#[Fields]\"Please input total element number of the sequence:\"#);\r\n\t#scanf(#[Fields]\"%d\"#,&n);\r\n\t#[Keywords]if#(n<=0||n>MAX)\r\n\t#{\r\n\t\t#printf(#[Fields]\"n must more than 0 and less than %d.\\n\"#,MAX);\r\n\t\t#exit(0);\r\n\t#}\r\n\t#puts(#[Fields]\"Please input the elements one by one:\"#);\r\n\t#[Keywords]for#(i=1;i<=n;i++)\r\n\t\t#scanf(#[Fields]\"%d\"#,&R[i]);\r\n\t#puts(#[Fields]\"The sequence you input is:\"#);\r\n\t#[Keywords]for#(i=1;i<=n;i++)\r\n\t\t#printf(#[Fields]\"%4d\"#,R[i]);\r\n\t#Bubble_Sort(n);\r\n\t#puts(#[Fields]\"\\nThe sequence after bubble_sort is:\"#);\r\n\t#[Keywords]for#(i=1;i<=n;i++)\r\n\t\t#printf(#[Fields]\"%4d\"#,R[i]);\r\n\t#puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n\t#getchar();\r\n\t#getchar();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        103,
        "冒泡排序",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define MAX 255\r\n#[Keywords]int #R[MAX];\r\n#[Keywords]int #Partition(#[Keywords]int #i,#[Keywords]int #j)\r\n{\r\n    #[Tags]\/* 调用Partition(R，low，high)时，对R[low..high]做划分，*\/\r\n    #[Tags]\/* 并返回基准记录的位置 *\/\r\n    #[Keywords]int #pivot=R[i];\r\n    #[Tags]\/* 用区间的第1个记录作为基准 *\/\r\n   #[Keywords] while#(i<j)\r\n    #{\r\n        #[Tags]\/* 从区间两端交替向中间扫描，直至i=j为止 *\/\r\n        #[Tags]\/* pivot相当于在位置i上 *\/\r\n       #[Keywords] while#(i<j&&R[j]>=pivot)j--;\r\n        #[Tags]\/* 从右向左扫描，查找第1个关键字小于pivot.key的记录R[j] *\/\r\n        #[Tags]\/* 表示找到的R[j]的关键字<pivot.key  *\/\r\n        #[Keywords]if#(i<j)R[i++]=R[j];\r\n        #[Tags]\/* 相当于交换R[i]和R[j]，交换后i指针加1 *\/\r\n        #[Tags]\/* pivot相当于在位置j上*\/\r\n       #[Keywords] while#(i<j&&R[i]<=pivot)i++;\r\n        #[Tags]\/* 从左向右扫描，查找第1个关键字大于pivot.key的记录R[i] *\/\r\n        #[Tags]\/* 表示找到了R[i]，使R[i].key>pivot.key *\/\r\n        #[Keywords]if#(i<j)R[j--]=R[i];\r\n        #[Tags]\/* 相当于交换R[i]和R[j]，交换后j指针减1 *\/\r\n    #}\r\n    #\/* end#[Keywords]while #*\/\r\n    #R[i]=pivot ;\r\n    #\/* 基准记录已被最后定位*\/\r\n    #[Keywords]return #i ;\r\n#}\r\n#[Tags]\/* end of partition  *\/\r\n#[Keywords]void #Quick_Sort(#[Keywords]int #low,#[Keywords]int #high)\r\n{\r\n    #[Tags]\/* 对R[low..high]快速排序 *\/\r\n    #[Keywords]int #pivotpos ;\r\n    #\/* 划分后的基准记录的位置 *\/\r\n    #[Keywords]if#(low<high)\r\n    #{\r\n        #[Tags]\/* 仅当区间长度大于1时才须排序 *\/\r\n        #pivotpos=Partition(low,high);\r\n        #[Tags]\/* 对R[low..high]做划分 *\/\r\n        #Quick_Sort(low,pivotpos-1);\r\n        #[Tags]\/* 对左区间递归排序 *\/\r\n        #Quick_Sort(pivotpos+1,high);\r\n        #[Tags]\/* 对右区间递归排序 *\/\r\n    #}\r\n#}\r\n#[Tags]\/* end of Quick_Sort *\/\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #i,n ;\r\n    #clrscr();\r\n    #puts(#[Fields]\"Please input total element number of the sequence:\"#);\r\n    #scanf(#[Fields]\"%d\"#,&n);\r\n    #[Keywords]if#(n<=0||n>MAX)\r\n    #{\r\n        #printf(#[Fields]\"n must more than 0 and less than %d.\\n\"#,MAX);\r\n        #exit(0);\r\n    #}\r\n    #puts(#[Fields]\"Please input the elements one by one:\"#);\r\n    #[Keywords]for#(i=1;i<=n;i++)\r\n    #scanf(#[Fields]\"%d\"#,&R[i]);\r\n    #puts(#[Fields]\"The sequence you input is:\"#);\r\n    #[Keywords]for#(i=1;i<=n;i++)\r\n    #printf(#[Fields]\"%4d\"#,R[i]);\r\n    #Quick_Sort(1,n);\r\n    #puts(#[Fields]\"\\nThe sequence after quick_sort is:\"#);\r\n    #[Keywords]for#(i=1;i<=n;i++)\r\n    #printf(#[Fields]\"%4d\"#,R[i]);\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        104,
        "快速排序",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define MAX 255\r\n#[Keywords]int #R[MAX];\r\n#[Keywords]void #ShellPass(#[Keywords]int #d,#[Keywords]int #n)\r\n{\r\n    #[Tags]\/* 希尔排序中的一趟排序，d为当前增量 *\/\r\n    #[Keywords]int #i,j ;\r\n    #[Tags]\/* 将R[d+1．．n]分别插入各组当前的有序区 *\/\r\n    #[Keywords]for#(i=d+1;i<=n;i++)#[Keywords]if#(R[i]<R[i-d])\r\n    #{\r\n        #R[0]=R[i];\r\n        #j=i-d ;\r\n        #[Tags]\/* R[0]只是暂存单元，不是哨兵 *\/\r\n        #[Keywords]do #\r\n        #{\r\n            #[Tags]\/* 查找R[i]的插入位置 *\/\r\n            #R[j+d]=R[j];\r\n            #[Tags]\/* 后移记录 *\/\r\n            #j=j-d ;\r\n            #[Tags]\/* 查找前一记录 *\/\r\n        #}\r\n       #[Keywords] while#(j>0&&R[0]<R[j]);\r\n        #R[j+d]=R[0];\r\n        #[Tags]\/* 插入R[i]到正确的位置上 *\/\r\n    #}\r\n    #[Tags]\/* end#[Keywords]if #*\/\r\n#}\r\n#[Tags]\/* end of ShellPass *\/\r\n#[Keywords]void #Shell_Sort(#[Keywords]int #n)\r\n{\r\n    #[Keywords]int #increment=n ;\r\n    #[Tags]\/* 增量初值，不妨设n>0 *\/\r\n    #[Keywords]do #\r\n    #{\r\n        #increment=increment\/3+1 ;\r\n        #[Tags]\/* 求下一增量 *\/\r\n        #ShellPass(increment,n);\r\n        #[Tags]\/* 一趟增量为increment的Shell插入排序 *\/\r\n    #}\r\n   #[Keywords] while#(increment>1);\r\n#}\r\n#[Tags]\/* ShellSort *\/\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #i,n ;\r\n    #clrscr();\r\n    #puts(#[Fields]\"Please input total element number of the sequence:\"#);\r\n    #scanf(#[Fields]\"%d\"#,&n);\r\n    #[Keywords]if#(n<=0||n>MAX)\r\n    #{\r\n        #printf(#[Fields]\"n must more than 0 and less than %d.\\n\"#,MAX);\r\n        #exit(0);\r\n    #}\r\n    #puts(#[Fields]\"Please input the elements one by one:\"#);\r\n    #[Keywords]for#(i=1;i<=n;i++)\r\n    #scanf(#[Fields]\"%d\"#,&R[i]);\r\n    #puts(#[Fields]\"The sequence you input is:\"#);\r\n    #[Keywords]for#(i=1;i<=n;i++)\r\n    #printf(#[Fields]\"%4d\"#,R[i]);\r\n    #Shell_Sort(n);\r\n    #puts(#[Fields]\"\\nThe sequence after shell_sort is:\"#);\r\n    #[Keywords]for#(i=1;i<=n;i++)\r\n    #printf(#[Fields]\"%4d\"#,R[i]);\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        105,
        "选择排序",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define MAX 255\r\n#[Keywords]int #R[MAX];\r\n#[Keywords]void #Select_Sort(#[Keywords]int #n)\r\n{\r\n   #[Keywords]int #i,j,k;\r\n   #[Keywords]for#(i=1;i<n;i++)\r\n   #{#[Tags]\/* 做第i趟排序(1≤i≤n-1) *\/\r\n     #k=i;\r\n     #[Keywords]for#(j=i+1;j<=n;j++) #[Tags]\/* 在当前无序区R[i..n]中选key最小的记录R[k] *\/\r\n       #[Keywords]if#(R[j]<R[k])\r\n         #k=j; #[Tags]\/* k记下目前找到的最小关键字所在的位置 *\/\r\n       #[Keywords]if#(k!=i)\r\n       #{ #[Tags]\/* 交换R[i]和R[k] *\/\r\n         #R[0]=R[i]; R[i]=R[k]; R[k]=R[0]; #[Tags]\/* R[0]作暂存单元 *\/\r\n       #} #[Tags]\/* end#[Keywords]if #*\/\r\n     #} #[Tags]\/* end#[Keywords]for #*\/\r\n#} #[Tags]\/* end of Select_Sort *\/\r\n#[Keywords]void #main()\r\n{\r\n\t#[Keywords]int #i,n;\r\n\t#clrscr();\r\n\t#puts(#[Fields]\"Please input total element number of the sequence:\"#);\r\n\t#scanf(#[Fields]\"%d\"#,&n);\r\n\t#[Keywords]if#(n<=0||n>MAX)\r\n\t#{\r\n\t\t#printf(#[Fields]\"n must more than 0 and less than %d.\\n\"#,MAX);\r\n\t\t#exit(0);\r\n\t#}\r\n\t#puts(#[Fields]\"Please input the elements one by one:\"#);\r\n\t#[Keywords]for#(i=1;i<=n;i++)\r\n\t\t#scanf(#[Fields]\"%d\"#,&R[i]);\r\n\t#puts(#[Fields]\"The sequence you input is:\"#);\r\n\t#[Keywords]for#(i=1;i<=n;i++)\r\n\t\t#printf(#[Fields]\"%4d\"#,R[i]);\r\n\t#Select_Sort(n);\r\n\t#puts(#[Fields]\"\\nThe sequence after select_sort is:\"#);\r\n\t#[Keywords]for#(i=1;i<=n;i++)\r\n\t\t#printf(#[Fields]\"%4d\"#,R[i]);\r\n\t#puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        106,
        "堆排序",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define MAX 255\r\n#[Keywords]int #R[MAX];\r\n#[Keywords]void #Heapify(#[Keywords]int #s,#[Keywords]int #m)\r\n{ #[Tags]\/*对R[1..n]进行堆调整，用temp做暂存单元 *\/\r\n     #[Keywords]int #j,temp;\r\n     #temp=R[s];\r\n     #j=2*s;\r\n     #[Keywords]while #(j<=m)\r\n     #{\r\n\t  #[Keywords]if #(R[j]>R[j+1]&&j<m) j++;\r\n\t  #[Keywords]if #(temp<R[j]) #[Keywords]break#;\r\n\t  #R[s]=R[j];\r\n          #s=j;\r\n          #j=j*2;\r\n     #}#[Tags]\/* end of #[Keywords]while #*\/\r\n     #R[s]=temp;\r\n#} #[Tags]\/* end of Heapify *\/\r\n#[Keywords]void #BuildHeap(#[Keywords]int #n)\r\n{ #[Tags]\/* 由一个无序的序列建成一个堆 *\/\r\n   #[Keywords]int #i;\r\n   #[Keywords]for#(i=n\/2;i>0;i--)\r\n      #Heapify(i,n);\r\n#}\r\n#[Keywords]void #Heap_Sort(#[Keywords]int #n)\r\n{ #[Tags]\/* 对R[1..n]进行堆排序，不妨用R[0]做暂存单元 *\/\r\n    #[Keywords]int #i;\r\n    #BuildHeap(n); #[Tags]\/* 将R[1-n]建成初始堆 *\/\r\n    #[Keywords]for#(i=n;i>1;i--)\r\n    #{ #[Tags]\/* 对当前无序区R[1..i]进行堆排序，共做n-1趟。 *\/\r\n    \t#R[0]=R[1]; R[1]=R[i];R[i]=R[0]; #[Tags]\/* 将堆顶和堆中最后一个记录交换 *\/\r\n    \t#Heapify(1,i-1); #[Tags]\/* 将R[1..i-1]重新调整为堆，仅有R[1]可能违反堆性质 *\/\r\n    #} #[Tags]\/* end of #[Keywords]for #*\/\r\n#} #[Tags]\/* end of Heap_Sort *\/\r\n#[Keywords]void #main()\r\n{\r\n\t#[Keywords]int #i,n;\r\n\t#clrscr();\r\n\t#puts(#[Fields]\"Please input total element number of the sequence:\"#);\r\n\t#scanf(#[Fields]\"%d\"#,&n);\r\n\t#[Keywords]if#(n<=0||n>MAX)\r\n\t#{\r\n\t\t#printf(#[Fields]\"n must more than 0 and less than %d.\\n\"#,MAX);\r\n\t\t#exit(0);\r\n\t#}\r\n\t#puts(#[Fields]\"Please input the elements one by one:\"#);\r\n\t#[Keywords]for#(i=1;i<=n;i++)\r\n\t\t#scanf(#[Fields]\"%d\"#,&R[i]);\r\n\t#puts(#[Fields]\"The sequence you input is:\"#);\r\n\t#[Keywords]for#(i=1;i<=n;i++)\r\n\t\t#printf(#[Fields]\"%4d\"#,R[i]);\r\n\t#Heap_Sort(n);\r\n\t#puts(#[Fields]\"\\nThe sequence after Big heap_sort is:\"#);\r\n\t#[Keywords]for#(i=1;i<=n;i++)\r\n\t\t#printf(#[Fields]\"%4d\"#,R[i]);\r\n\t#puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        107,
        "归并排序",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define MAX 255\r\n#[Keywords]int #R[MAX];\r\n#[Keywords]void #Merge(#[Keywords]int #low,#[Keywords]int #m,#[Keywords]int #high)\r\n{#[Tags]\/* 将两个有序的子文件R[low..m)和R[m+1..high]归并成一个有序的 *\/\r\n     #\/* 子文件R[low..high] *\/\r\n     #[Keywords]int #i=low,j=m+1,p=0; #[Tags]\/* 置初始值 *\/\r\n     #[Keywords]int #*R1; #[Tags]\/* R1是局部向量，若p定义为此类型指针速度更快 *\/\r\n     #R1=(#[Keywords]int #*)malloc((high-low+1)*sizeof(#[Keywords]int#));\r\n     #[Keywords]if#(!R1) #[Tags]\/* 申请空间失败 *\/\r\n     #{\r\n       #puts(#[Fields]\"Insufficient memory available!\"#);\r\n       #[Keywords]return#;#\r\n     #}\r\n    #[Keywords] while#(i<=m&&j<=high) #[Tags]\/* 两子文件非空时取其小者输出到R1[p]上 *\/\r\n       #R1[p++]=(R[i]<=R[j])?R[i++]:R[j++];\r\n    #[Keywords] while#(i<=m) #[Tags]\/* 若第1个子文件非空，则复制剩余记录到R1中 *\/\r\n       #R1[p++]=R[i++];\r\n    #[Keywords] while#(j<=high) #[Tags]\/* 若第2个子文件非空，则复制剩余记录到R1中 *\/\r\n       #R1[p++]=R[j++];\r\n     #[Keywords]for#(p=0,i=low;i<=high;p++,i++)\r\n       #R[i]=R1[p];#[Tags]\/* 归并完成后将结果复制回R[low..high] *\/\r\n#} #[Tags]\/* end of Merge *\/\r\n#[Keywords]void #Merge_SortDC(#[Keywords]int #low,#[Keywords]int #high)\r\n{#[Tags]\/* 用分治法对R[low..high]进行二路归并排序 *\/\r\n       #[Keywords]int #mid;\r\n       #[Keywords]if#(low<high)\r\n       #{#[Tags]\/* 区间长度大于1 *\/\r\n          #mid=(low+high)\/2; #[Tags]\/* 分解 *\/\r\n\t  #Merge_SortDC(low,mid); #[Tags]\/* 递归地对R[low..mid]排序 *\/\r\n\t  #Merge_SortDC(mid+1,high); #[Tags]\/* 递归地对R[mid+1..high]排序 *\/\r\n          #Merge(low,mid,high); #[Tags]\/* 组合，将两个有序区归并为一个有序区 *\/\r\n        #}\r\n#}#[Tags]\/* end of Merge_SortDC *\/\r\n#[Keywords]void #main()\r\n{\r\n\t#[Keywords]int #i,n;\r\n\t#clrscr();\r\n\t#puts(#[Fields]\"Please input total element number of the sequence:\"#);\r\n\t#scanf(#[Fields]\"%d\"#,&n);\r\n\t#[Keywords]if#(n<=0||n>MAX)\r\n\t#{\r\n\t\t#printf(#[Fields]\"n must more than 0 and less than %d.\\n\"#,MAX);\r\n\t\t#exit(0);\r\n\t#}\r\n\t#puts(#[Fields]\"Please input the elements one by one:\"#);\r\n\t#[Keywords]for#(i=1;i<=n;i++)\r\n\t\t#scanf(#[Fields]\"%d\"#,&R[i]);\r\n\t#puts(#[Fields]\"The sequence you input is:\"#);\r\n\t#[Keywords]for#(i=1;i<=n;i++)\r\n\t\t#printf(#[Fields]\"%4d\"#,R[i]);\r\n\t#Merge_SortDC(1,n);\r\n\t#puts(#[Fields]\"\\nThe sequence after merge_sortDC is:\"#);\r\n\t#[Keywords]for#(i=1;i<=n;i++)\r\n\t\t#printf(#[Fields]\"%4d\"#,R[i]);\r\n\t#puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        108,
        "基数排序",
        "代码如下：\r\n[code=java]\r\n#include #[Fields]\"stdio.h\r\n#include #[Fields]\"conio.h\r\n#include #[Fields]\"stdlib.h\r\n#define MAX 5\r\ntypedef struct node\r\n{ #[Keywords]int #k;\r\n  #struct node *next;\r\n#} *lnode;\r\nlnode my_input(#[Keywords]int #*d)\r\n{ lnode head,temp,terminal;\r\n #[Keywords]char #s[MAX+1];\r\n  #printf(#[Fields]\"Input the records (#[Fields]'0'# to end input):\\n\"#);\r\n  #scanf(#[Fields]\"%s\"#,s);\r\n  #head=NULL;\r\n  #[Tags]*d=0;\r\n  #terminal=NULL;\r\n #[Keywords] while#(s[0]!=#[Fields]'0'#)\r\n   #{\r\n   #temp=(lnode)malloc(sizeof(struct node));\r\n    #[Keywords]if #(strlen(s)>*d)\r\n    #[Tags]*d=strlen(s);\r\n    #temp->k=atoi(s);\r\n     #[Keywords]if #(head==NULL)\r\n      #{ head=temp;\r\n      #terminal=temp;\r\n      #}\r\n     #[Keywords] else#\r\n      #{\r\n       #terminal->next=temp;\r\n        #terminal=temp;\r\n        #}\r\n         #scanf(#[Fields]\"%s\"#,s);\r\n         #}\r\n\t  #terminal->next=NULL;\r\n\r\n    #[Keywords]return #head;\r\n#}\r\n#[Keywords]void #my_output(lnode h)\r\n{\r\n\t#lnode t=h;\r\n\t#printf(#[Fields]\"\\n\"#);\r\n\t#[Keywords]while #(h!=NULL)\r\n\t#{\r\n\t\t#printf(#[Fields]\"%d \"#,h->k);\r\n\t\t#h=h->next;\r\n\t#}\r\n\t#h=t;\r\n\t#[Tags]\/* getch(); *\/\r\n#}\r\nlnode Radix_Sort(lnode head,#[Keywords]int #d)\r\n{\r\nlnode p,q,h,t;\r\n#[Keywords]int #i,j,x,radix=1;\r\n #h=(lnode)malloc(10*sizeof(struct node));\r\n  #t=(lnode)malloc(10*sizeof(struct node));\r\n   #[Keywords]for #(i=d;i>=1;i--)\r\n   #{\r\n   #[Keywords]for #(j=0;j<=9;j++)\r\n   #{ \th[j].next=NULL;\r\n   \t#t[j].next=NULL;\r\n   #}\r\n   #p=head;\r\n   #[Keywords]while #(p!=NULL)\r\n   #{\r\n   \t#x=((p->k)\/radix)%10;\r\n   \t#[Keywords]if #(h[x].next==NULL)\r\n   \t#{\r\n   \t\t#h[x].next=p;\r\n   \t\t#t[x].next=p;\r\n   \t#}\r\n   \t#else\r\n   \t#{\r\n   \t\t#q=t[x].next;\r\n   \t\t#q->next=p;\r\n   \t\t#t[x].next=p;\r\n   \t#}\r\n   \t#p=p->next;\r\n   #}\r\n\r\n   #j=0;\r\n   #[Keywords]while #(h[j].next==NULL)\r\n    #j++;\r\n    #head=h[j].next;\r\n    #q=t[j].next;\r\n    #[Keywords]for #(x=j+1;x<=9;x++)\r\n    #[Keywords]if #(h[x].next!=NULL)\r\n    #{\r\n    \t#q->next=h[x].next;\r\n    \t#q=t[x].next;\r\n    #}\r\n    #q->next=NULL;\r\n    #radix*=10;\r\n    #printf(#[Fields]\"\\n---------------------\\n\"#);\r\n    #}\r\n    #[Keywords]return #head;\r\n#}\r\n#[Keywords]void #my_free(lnode h)\r\n{\r\n\t#lnode temp=h;\r\n\t#[Keywords]while #(temp)\r\n\t#{\r\n\t\t#h=temp->next;\r\n\t\t#free(temp);\r\n\t\t#temp=h;\r\n\t#}\r\n#}\r\n#[Keywords]void #main()\r\n{\r\n\t#lnode h;\r\n\t#[Keywords]int #d;\r\n\t#clrscr();\r\n\t#h=my_input(&d);\r\n\t#puts(#[Fields]\"The sequence you input is:\"#);\r\n\t#my_output(h);\r\n\t#h=Radix_Sort(h,d);\r\n\t#puts(#[Fields]\"\\nThe sequence after radix_sort is:\"#);\r\n\t#my_output(h);\r\n\t#my_free(h);\r\n\t#puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        109,
        "二叉搜索树操作",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\nstruct node {\r\n\t#int\t\t\t\tvalue;\r\n\t#struct node* \tleft;\r\n\t#struct node* \tright;\r\n#};\r\ntypedef struct node  NODE;\r\ntypedef struct node* PNODE;\r\n#[Keywords]void #new_node (PNODE* n, #[Keywords]int #value) {\r\n\r\n\t#[Tags]*n = (PNODE)malloc (sizeof(NODE));\r\n\t#[Keywords]if #(*n != NULL) {\r\n\t    #(*n)->value\t= value;\r\n\t\t#(*n)->left \t= NULL;\r\n\t\t#(*n)->right = NULL;\r\n \t#}\r\n#}\r\n#[Keywords]void #free_node (PNODE* n) {\r\n\t#[Keywords]if #((*n) != NULL) {\r\n\t\t#free (*n);\r\n\t\t#[Tags]*n = NULL;\r\n \t#}\r\n#}\r\n#[Keywords]void #free_tree (PNODE* n) {\r\n    #[Keywords]if #(*n == NULL) #[Keywords]return#;#\r\n\t#[Keywords]if #((*n)->left != NULL) {\r\n\t    #free_tree (&((*n)->left));\r\n \t#}\r\n\t#[Keywords]if #((*n)->right != NULL) {\r\n\t    #free_tree (&((*n)->right));\r\n\t#}\r\n\t#free_node (n);\r\n#}\r\n#[Comments]\/\/查找结点\r\nPNODE find_node (PNODE n, #[Keywords]int #value) {\r\n\t#[Keywords]if #(n == NULL) {\r\n\t\t#[Keywords]return #NULL;\r\n\t#} #[Keywords]else #[Keywords]if #(n->value == value) {\r\n\t    #[Keywords]return #n;\r\n \t#} #[Keywords]else #[Keywords]if #(value <= n->value) {\r\n \t    #[Keywords]return #find_node (n->left, value);\r\n  \t#} #[Keywords]else #{\r\n  \t    #[Keywords]return #find_node (n->right, value);\r\n\t#}\r\n#}\r\n#[Comments]\/\/插入结点\r\n#[Keywords]void #insert_node (PNODE* n, #[Keywords]int #value) {\r\n\t#[Keywords]if #(*n == NULL) {\r\n\t\t#new_node (n, value);\r\n    #} #[Keywords]else #[Keywords]if #(value == (*n)->value) {\r\n        #[Keywords]return#;#\r\n\t#} #[Keywords]else #[Keywords]if #(value < (*n)->value) {\r\n        #insert_node (&((*n)->left), value);\r\n\t#} #[Keywords]else #{\r\n\t\t#insert_node (&((*n)->right), value);\r\n\t#}\r\n#}\r\n#[Comments]\/\/最长路径\r\n#[Keywords]int #get_max_depth (PNODE n) {\r\n  #[Keywords]int #left = 0;\r\n  #[Keywords]int #right = 0;\r\n    \t#[Keywords]if #(n == NULL) {\r\n  \t    #[Keywords]return #0;\r\n\t#}\r\n\t\t#[Keywords]if #(n->left != NULL) {\r\n\t\t#left = 1 + get_max_depth (n->left);\r\n\t#}\r\n\t#[Keywords]if #(n->right != NULL) {\r\n\t\t#right = 1 + get_max_depth (n->right);\r\n\t#}\r\n \t#[Keywords]return #(left > right ? left : right );\r\n#}\r\n#[Comments]\/\/最短路径\r\n#[Keywords]int #get_min_depth (PNODE n) {\r\n  #[Keywords]int #left = 0;\r\n  #[Keywords]int #right = 0;\r\n  \t#[Keywords]if #(n == NULL) {\r\n  \t    #[Keywords]return #0;\r\n\t#}\r\n\t#[Keywords]if #(n->left != NULL) {\r\n\t\t#left = 1 + get_min_depth (n->left);\r\n\t#}\r\n\t#[Keywords]if #(n->right != NULL) {\r\n\t\t#right = 1 + get_min_depth (n->right);\r\n\t#}\r\n\t#[Keywords]return #(left < right ? left : right );\r\n#}\r\n#[Keywords]int #get_num_nodes (PNODE n) {\r\n  #[Keywords]int #left = 0;\r\n  #[Keywords]int #right = 0;\r\n  \t#[Keywords]if #(n == NULL) {\r\n  \t    #[Keywords]return #0;\r\n\t#}\r\n\t#[Keywords]if #(n->left != NULL) {\r\n\t\t#left = get_num_nodes (n->left);\r\n\t#}\r\n\t#[Keywords]if #(n->right != NULL) {\r\n\t\t#right = get_num_nodes (n->right);\r\n\t#}\r\n\t#[Keywords]return #(left + 1 + right);\r\n#}\r\n#[Comments]\/\/最短路径长度\r\n#[Keywords]int #get_min_value (PNODE n) {\r\n    #[Keywords]if #(n == NULL) #[Keywords]return #0;\r\n\t#[Keywords]if #(n->left == NULL) {\r\n\t    #[Keywords]return #n->value;\r\n \t#} #[Keywords]else #{\r\n \t    #[Keywords]return #get_min_value(n->left);\r\n  \t#}\r\n#}\r\n#[Comments]\/\/最长路径长度\r\n#[Keywords]int #get_max_value (PNODE n) {\r\n\t#[Keywords]if #(n == NULL) #[Keywords]return #0;\r\n\t#[Keywords]if #(n->right == NULL) {\r\n\t    #[Keywords]return #n->value;\r\n \t#} #[Keywords]else #{\r\n \t    #[Keywords]return #get_max_value(n->right);\r\n  \t#}\r\n#}\r\n#[Comments]\/\/删除结点\r\n#[Keywords]void #deletenode (PNODE *n) {\r\n\t#PNODE tmp = NULL;\r\n\t#[Keywords]if #(n == NULL) #[Keywords]return#;#\r\n\t#[Keywords]if #((*n)->right == NULL) {\r\n\t    #tmp = *n;\r\n\t    #[Tags]*n = (#[Tags]*n)->left;\r\n\t    #free_node (n);\r\n\t#} #[Keywords]else #[Keywords]if #((*n)->left == NULL) {\r\n\t    #tmp = *n;\r\n\t    #[Tags]*n = (#[Tags]*n)->right;\r\n\t    #free_node (n);\r\n\t#} #[Keywords]else #{\r\n        #[Keywords]for #(tmp = (*n)->right; tmp->left != NULL; tmp = tmp->left);\r\n        #tmp->left = (*n)->left;\r\n        #tmp = (*n);\r\n        #[Tags]*n = (#[Tags]*n)->right;\r\n        #free_node (&tmp);\r\n\t#}\r\n#}\r\n#[Keywords]void #delete_node (PNODE *n, #[Keywords]int #value) {\r\n\t#PNODE node;\r\n    #[Keywords]if #(n == NULL) #[Keywords]return#;#\r\n    #node = find_node (*n, value);\r\n\t#[Keywords]if #((*n)->value == value) {\r\n\t\t#deletenode (n);\r\n    #} #[Keywords]else #[Keywords]if #(value < (*n)->value) {\r\n\t\t#delete_node (&((*n)->left), value);\r\n    #} #[Keywords]else #{\r\n\t\t#delete_node(&((*n)->right), value);\r\n\t#}\r\n#}\r\n#[Keywords]void #pre_order_traversal(PNODE n)\r\n{\r\n    #[Keywords]if #(n != NULL) {\r\n\t\t#printf (#[Fields]\"%i \"#, n->value);\r\n        #pre_order_traversal (n->left);\r\n        #pre_order_traversal( n->right);\r\n    #}\r\n#}\r\n#[Keywords]void #in_order_traversal (PNODE n)\r\n{\r\n    #[Keywords]if #(n != NULL) {\r\n        #in_order_traversal (n->left);\r\n        #printf (#[Fields]\"%i \"#, n->value);\r\n        #in_order_traversal ( n->right);\r\n    #}\r\n#}\r\n#[Keywords]void #post_order_traversal (PNODE n)\r\n{\r\n    #[Keywords]if #(n != NULL) {\r\n        #post_order_traversal (n->left);\r\n        #post_order_traversal (n->right);\r\n        #printf (#[Fields]\"%i \"#, n->value);\r\n    #}\r\n#}\r\n#[Keywords]int #main() {\r\n\t#[Keywords]char #buf[50];\r\n\t#[Keywords]int # option;\r\n\t#PNODE tree = NULL;\r\n    #PNODE node = NULL;\r\n    \t#[Keywords]while #(1) {\r\n\t\t#printf (#[Fields]\"--------------------------\\n\"#);\r\n\t\t#printf (#[Fields]\"Options are:\\n\\n\"#);\r\n\t\t#printf (#[Fields]\" 0  Exit\\n\"#);\r\n\t\t#printf (#[Fields]\" 1  Insert node\\n\"#);\r\n\t\t#printf (#[Fields]\" 2  Delete node\\n\"#);\r\n\t\t#printf (#[Fields]\" 3  Find node\\n\"#);\r\n\t\t#printf (#[Fields]\" 4  Pre order traversal\\n\"#);\r\n\t\t#printf (#[Fields]\" 5  In order traversal\\n\"#);\r\n\t\t#printf (#[Fields]\" 6  Post order traversal\\n\"#);\r\n\t\t#printf (#[Fields]\" 7  Max depth\\n\"#);\r\n\t\t#printf (#[Fields]\" 8  Min depth\\n\"#);\r\n\t\t#printf (#[Fields]\" 9  Max value\\n\"#);\r\n\t\t#printf (#[Fields]\" 10 Min value\\n\"#);\r\n\t\t#printf (#[Fields]\" 11 Node Count\\n\\n\"#);\r\n\t\t#printf (#[Fields]\"--------------------------\\n\"#);\r\n\t\t#printf (#[Fields]\"Select an option: \"#);\r\n\t\t#fgets (buf, sizeof(buf), stdin);\r\n\t\t#sscanf (buf, #[Fields]\"%i\"#, &option);\r\n\t\t#printf (#[Fields]\"--------------------------\\n\"#);\r\n\t\t#[Keywords]if #(option < 0 || option > 11) {\r\n\t\t    #fprintf (stderr, #[Fields]\"Invalid option\"#);\r\n\t\t    #[Keywords]continue#;\r\n\t\t#}\r\n\t\t\t#[Keywords]switch #(option) {\r\n\t\t    #[Keywords]case #0:\r\n\t\t        #exit (0);\r\n\t\t    #[Keywords]case #1:\r\n\t\t        #printf (#[Fields]\"Enter number to insert: \"#);\r\n\t\t\t\t#fgets (buf, sizeof(buf), stdin);\r\n\t\t\t\t#sscanf (buf, #[Fields]\"%i\"#, &option);\r\n\t\t\t\t#printf (#[Fields]\"\\n\\n\"#);\r\n\t\t\t\t#insert_node (&tree, option);\r\n\t\t\t\t#[Keywords]break#;\r\n\t\t    #[Keywords]case #2:\r\n            \t#printf (#[Fields]\"Enter number to delete: \"#);\r\n\t\t\t\t#fgets (buf, sizeof(buf), stdin);\r\n\t\t\t\t#sscanf (buf, #[Fields]\"%i\"#, &option);\r\n\t\t\t\t#printf (#[Fields]\"\\n\\n\"#);\r\n\t\t\t\t#delete_node (&tree, option);\r\n\t\t\t\t#[Keywords]break#;\r\n\t\t    #[Keywords]case #3:\r\n            \t#printf (#[Fields]\"Enter number to find: \"#);\r\n\t\t\t\t#fgets (buf, sizeof(buf), stdin);\r\n\t\t\t\t#sscanf (buf, #[Fields]\"%i\"#, &option);\r\n\t\t\t\t#printf (#[Fields]\"\\n\\n\"#);\r\n\t\t\t\t#node = find_node (tree, option);\r\n\t\t\t\t#[Keywords]if #(node != NULL) {\r\n\t\t\t\t    #printf (#[Fields]\"Found node\\n\\n\"#);\r\n\t\t\t\t#} #[Keywords]else #{\r\n\t\t\t\t    #printf (#[Fields]\"Couldn#[Fields]'t find node\\n\\n\"#);\r\n\t\t\t\t#}\r\n\t\t\t\t#[Keywords]break#;\r\n\t\t    #[Keywords]case #4:\r\n\t\t\t\t#printf (#[Fields]\"Pre order traversal: \"#);\r\n\t\t\t\t#pre_order_traversal (tree);\r\n\t\t\t\t#printf (#[Fields]\"\\n\\n\"#);\r\n\t\t\t\t#[Keywords]break#;\r\n\t\t    #[Keywords]case #5:\r\n\t\t        #printf (#[Fields]\"In order traversal: \"#);\r\n\t\t    \t#in_order_traversal (tree);\r\n\t\t    \t#printf (#[Fields]\"\\n\\n\"#);\r\n\t\t    \t#[Keywords]break#;\r\n\t\t    #[Keywords]case #6:\r\n\t\t        #printf (#[Fields]\"Post order traversal: \"#);\r\n\t\t    \t#post_order_traversal (tree);\r\n       \t\t\t#printf (#[Fields]\"\\n\\n\"#);\r\n\t\t    \t#[Keywords]break#;\r\n\t\t    #[Keywords]case #7:\r\n\t\t        #printf (#[Fields]\"Max depth is %i\\n\\n\"#, get_max_depth (tree));\r\n\t\t        #[Keywords]break#;\r\n\t\t    #[Keywords]case #8:\r\n\t\t        #printf (#[Fields]\"Min depth is %i\\n\\n\"#, get_min_depth (tree));\r\n\t\t        #[Keywords]break#;\r\n\t\t    #[Keywords]case #9:\r\n\t\t        #printf (#[Fields]\"Max value is %i\\n\\n\"#, get_max_value (tree));\r\n\t\t        #[Keywords]break#;\r\n\t\t    #[Keywords]case #10:\r\n\t\t        #printf (#[Fields]\"Min value is %i\\n\\n\"#, get_min_value (tree));\r\n\t\t        #[Keywords]break#;\r\n      \t\t#[Keywords]case #11:\r\n\t\t        #printf (#[Fields]\"Node Count is %i\\n\\n\"#, get_num_nodes (tree));\r\n\t\t        #[Keywords]break#;\r\n\t\t#}\r\n \t#}\r\n\t#[Keywords]return #0;\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        110,
        "二项式系数递归",
        "代码如下：\r\n[code=java]\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <conio.h>\r\n#[Keywords]int #binom (#[Keywords]int #n, #[Keywords]int #i);\r\n#[Keywords]void #main (void)\r\n{\r\n    #[Keywords]int #int1;\r\n\t#[Keywords]int #int2;\r\n\t#[Comments]\/\/打印两项式\r\n    #printf (#[Fields]\"NOTE: Entering a figure other than a number will \\ncause the program to crash.\"#);\r\n    #printf (#[Fields]\"\\n\"#);\r\n    #printf (#[Fields]\"Formula computation is in B(n,i) N, 1st integer >= 2nd, I, Integer.\\n\\n\"#);\r\n    #printf (#[Fields]\" n!\\n\"#);\r\n    #printf (#[Fields]\" B(n,i)= ----------\\n\"#);\r\n    #printf (#[Fields]\"k!(n-i)!\\n\\n\"#);\r\n    #printf (#[Fields]\"Warning: Program has no error checking!\\n\\n\"#);\r\n    #printf (#[Fields]\"\\nEnter an integer :\"#);\r\n    #scanf (#[Fields]\"%d\"#, &int1);\r\n    #printf (#[Fields]\"\\n\"#);\r\n    #printf (#[Fields]\"Enter a second integer :\"#);\r\n    #scanf (#[Fields]\"%d\"#, &int2);\r\n    #printf (#[Fields]\"\\n\"#);\r\n    #printf (#[Fields]\"Binomial Coefficiant : %d\"#, binom (int1, int2));\r\n    #getch();\r\n#}\r\n#[Comments]\/\/算法计算\r\n#[Keywords]int #binom (#[Keywords]int #n, #[Keywords]int #i)\r\n{\r\n    #[Keywords]int #n1;\r\n    #[Keywords]int #n2;\r\n    #[Keywords]if #(( i ==0 ) || (n== i))\r\n        #{\r\n        #[Keywords]return #1;\r\n    #}\r\n   #[Keywords] else#\r\n        #{\r\n        #n1 = binom ( n - 1, i);\r\n        #n2 = binom ( n - 1, i -1);\r\n        #[Keywords]return #n1 + n2;\r\n    #}\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        111,
        "背包问题",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#define MAX 100\r\nstruct Bag \r\n{\r\n    #[Keywords]int #weight ;\r\n    #[Keywords]int #value ;\r\n#}\r\nBag[MAX];\r\n#[Keywords]int #a[MAX];\r\n#[Keywords]int #Value=0 ;\r\n#[Keywords]int #Weight ;\r\n#[Keywords]int #comb(#[Keywords]int #m,#[Keywords]int #k)\r\n{\r\n    #[Keywords]int #i,j ;\r\n    #[Keywords]int #wei,val ;\r\n    #[Keywords]for#(i=m;i>=k;i--)\r\n    #{\r\n        #a[k]=i ;\r\n        #[Keywords]if#(k>1)\r\n        #comb(i-1,k-1);\r\n        #[Keywords]else #\r\n        #{\r\n            #wei=0 ;\r\n            #\/* 预值0 *\/\r\n            #val=0 ;\r\n            #\/* 每一种组合求它们的重量和价值 *\/\r\n            #[Keywords]for#(j=a[0];j>0;j--)\r\n            #{\r\n                #wei=wei+Bag[a[j]].weight ;\r\n                #val=val+Bag[a[j]].value ;\r\n            #}\r\n            #\/* 判断是否满足条件进行附值 *\/\r\n            #[Keywords]if#(wei<=Weight&&val>Value)Value=val ;\r\n        #}\r\n    #}\r\n    #[Keywords]return #Value ;\r\n#}\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #num,subnum ;\r\n    #[Keywords]int #l,\r\n    #clrscr();\r\n    #printf(#[Fields]\"输入背包的总个数:\"#);\r\n    #\/* 输入背包的总个数 *\/\r\n    #scanf(#[Fields]\"%d\"#,&num);\r\n    #printf(#[Fields]\"输入背包的重量和价值\\n\"#,num);\r\n    #\/* 输入背包的重量和价值 *\/\r\n    #[Keywords]for#(l=1;l<=num;l++)\r\n    #scanf(#[Fields]\"%d,%d\"#,&Bag[l].weight,&Bag[l].value);\r\n    #printf(#[Fields]\"输入满足要求背包的个数:\\n\"#);\r\n    #\/* 输入要求背包的个数 *\/\r\n    #scanf(#[Fields]\"%d\"#,&subnum);\r\n    #printf(#[Fields]\"输入满足条件的重量:\\n\"#,subnum);\r\n    #\/* 输入满足条件的重量*\/\r\n    #scanf(#[Fields]\"%d\"#,&Weight);\r\n    #a[0]=subnum ;\r\n    #printf(#[Fields]\"the max value is:%d\"#,comb(num,subnum));\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        112,
        "顺序表插入和删除",
        "代码如下：\r\n[code=java]\r\n#define ListSize 100\r\n#[Tags]\/* 假定表空间大小为100 *\/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#[Keywords]void #Error(char*message)\r\n{\r\n    #printf(#[Fields]\"错误:%s\\n\"#,message);\r\n    #exit(1);\r\n#}\r\n#[Tags]\/* 从0开始计， 表空间大小应为101了 *\/\r\nstruct Seqlist \r\n{\r\n    #[Keywords]int #data[ListSize];\r\n    #\/* 向量data用于存放表结点 *\/\r\n    #[Keywords]int #length ;\r\n    #\/*  当前的表长度 *\/\r\n#}\r\n;\r\n#[Tags]\/* 以上为定义表结构 *\/\r\n#[Tags]\/* ------------以下为两个主要算法---------- *\/\r\n#[Keywords]void #InsertList(struct Seqlist*L,#[Keywords]int #x,#[Keywords]int #i)\r\n{\r\n    #\/* 将新结点x插入L所指的顺序表的第i个结点ai的位置上 *\/\r\n    #[Keywords]int #j ;\r\n    #[Keywords]if#(i<0||i>L->length)\r\n    #Error(#[Fields]\"position error\"#);\r\n    #\/* 非法位置，退出 *\/\r\n    #[Keywords]if#(L->length>=ListSize)\r\n    #Error(#[Fields]\"overflow\"#);\r\n    #[Keywords]for#(j=L->length-1;j>=i;j--)\r\n    #L->data[j+1]=L->data[j];\r\n    #L->data[i]=x ;\r\n    #L->length++;\r\n#}\r\n#[Keywords]void #DeleteList(struct Seqlist*L,#[Keywords]int #i)\r\n{\r\n    #\/* 从L所指的顺序表中删除第i个结点ai *\/\r\n    #[Keywords]int #j ;\r\n    #[Keywords]if#(i<0||i>L->length-1)\r\n    #Error(#[Fields]\" position error\"#);\r\n    #[Keywords]for#(j=i+1;j<L->length;j++)\r\n    #L->data[j-1]=L->data[j];\r\n    #\/* 结点前移 *\/\r\n    #L->length--;\r\n    #\/* 表长减小 *\/\r\n#}\r\n#[Tags]\/* ===========以下为验证算法而加======= *\/\r\n#[Keywords]void #Initlist(struct Seqlist*L)\r\n{\r\n    #L->length=0 ;\r\n#}\r\n#[Keywords]void #main()\r\n{\r\n    #struct Seqlist*SEQA ;\r\n    #[Keywords]int #i ;\r\n    #SEQA=(struct Seqlist*)malloc(sizeof(struct Seqlist));\r\n    #Initlist(SEQA);\r\n    \r\n    #[Keywords]for#(i=0;i<ListSize;i++)\r\n    #{\r\n        #InsertList(SEQA,i,i);\r\n        #printf(#[Fields]\"%d\\n\"#,SEQA->data[i]);\r\n    #}\r\n    #DeleteList(SEQA,99);\r\n    #[Keywords]for#(i=0;i<ListSize-1;i++)\r\n    #{\r\n        #printf(#[Fields]\"%d\\n\"#,SEQA->data[i]);\r\n    #}\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        113,
        "链表操作（1）",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#include <conio.h>\r\n#define N 10\r\ntypedef struct node\r\n{\r\n    #[Keywords]char #name[20];\r\n    #struct node *link;\r\n#}stud;\r\nstud * creat()\r\n{\r\n    #stud *p,*h,*s;\r\n    #[Keywords]int #i,n;\r\n    #puts(#[Fields]\"\\nPlease input the number of linklist:\"#);\r\n    #scanf(#[Fields]\"%d\"#,&n);\r\n    #[Keywords]if#((h=(stud *)malloc(sizeof(stud)))==NULL)\r\n    #{\r\n        #printf(#[Fields]\"cannot find space!\"#);\r\n        #exit(0);\r\n    #}\r\n    #h->name[0]=#[Fields]'\\0'#;\r\n    #h->link=NULL;\r\n    #p=h;\r\n    #[Keywords]for#(i=0;i<n;i++)\r\n    #{\r\n        #[Keywords]if#((s= (stud *) malloc(sizeof(stud)))==NULL)\r\n        #{\r\n            #printf(#[Fields]\"cannot find space!\"#);\r\n            #exit(0);\r\n        #}\r\n        #p->link=s;\r\n    #printf(#[Fields]\"please input %d student#[Fields]'s name: \"#,i+1);\r\n        #scanf(#[Fields]\"%s\"#,s->name);\r\n        #s->link=NULL;\r\n        #p=s;\r\n    #}\r\n    #return(h);\r\n#}\r\nstud * search(stud *h,#[Keywords]char #*x)\r\n{\r\n    #stud *p;\r\n    #[Keywords]char #*y;\r\n    #p=h->link;\r\n   #[Keywords] while#(p!=NULL)\r\n    #{\r\n        #y=p->name;\r\n        #[Keywords]if#(strcmp(y,x)==0)\r\n        #return(p);\r\n        #[Keywords]else #p=p->link;\r\n    #}\r\n    #[Keywords]if#(p==NULL)\r\n    #printf(#[Fields]\"data not find!\"#);\r\n\t#[Keywords]return #0;\r\n#}\r\nstud * search2(stud *h,#[Keywords]char #*x)\r\n{\r\n    #stud *p,*s;\r\n    #[Keywords]char #*y;\r\n    #p=h->link;\r\n    #s=h;\r\n   #[Keywords] while#(p!=NULL)\r\n    #{\r\n        #y=p->name;\r\n        #[Keywords]if#(strcmp(y,x)==0)\r\n            #return(s);\r\n       #[Keywords] else#\r\n        #{\r\n            #p=p->link;\r\n            #s=s->link;\r\n        #}\r\n    #}\r\n    #[Keywords]if#(p==NULL)\r\n    #printf(#[Fields]\"data not find!\"#);\r\n\t#[Keywords]return #0;\r\n#}\r\n#[Keywords]void #insert(stud *p)\r\n{\r\n    #[Keywords]char #stuname[20];\r\n    #stud *s;\r\n    #[Keywords]if#((s= (stud *) malloc(sizeof(stud)))==NULL)\r\n    #{\r\n        #printf(#[Fields]\"cannot find space!\"#);\r\n        #exit(0);\r\n    #}\r\nprintf(#[Fields]\"\\nplease input the student#[Fields]'s name: \"#);\r\n    #scanf(#[Fields]\"%s\"#,stuname);\r\n    #strcpy(s->name,stuname);\r\n    #s->link=p->link;\r\n    #p->link=s;\r\n#}\r\n#[Keywords]void #del(stud *x,stud *y)\r\n{\r\n    #stud *s;\r\n    #s=y;\r\nx->link=y->link;\r\n    #free(s);\r\n#}\r\n#[Keywords]void #print(stud *h)\r\n{\r\n    #stud *p;\r\n    #p=h->link;\r\nprintf(#[Fields]\"Now the link list is:\\n\"#);\r\n   #[Keywords] while#(p!=NULL)\r\n    #{\r\n        #printf(#[Fields]\"%s \"#,&*(p->name));\r\n        #p=p->link;\r\n#}\r\nprintf(#[Fields]\"\\n\"#);\r\n#}\r\n#[Keywords]void #quit()\r\n{\r\n\t#clrscr();\r\n\t#puts(#[Fields]\"\\n Thank you #[Keywords]for #your using!\\n Press any key to quit...\"#);\r\n\t#getch();\r\n\t#exit(0);\r\n#}\r\n#[Keywords]void #menu(void)\r\n{\r\n    #clrscr();\r\n\t#printf(#[Fields]\"       simple linklise realization of c\\n\"#);\r\n\t#printf(#[Fields]\"    ||=====================================||\\n\"#);\r\n\t#printf(#[Fields]\"    ||                                     ||\\n\"#);\r\n\t#printf(#[Fields]\"    || [1]  create linklist                ||\\n\"#);\r\n\t#printf(#[Fields]\"    || [2]  seach                          ||\\n\"#);\r\n\t#printf(#[Fields]\"    || [3]  insert                         ||\\n\"#);\r\n\t#printf(#[Fields]\"    || [4]  delete                         ||\\n\"#);\r\n\t#printf(#[Fields]\"    || [5]  pr#[Keywords]int #                         ||\\n\"#);\r\n\t#printf(#[Fields]\"    || [6]  exit                           ||\\n\"#);\r\n\t#printf(#[Fields]\"    ||                                     ||\\n\"#);\r\n\t#printf(#[Fields]\"    || #[Keywords]if #no list exist,create first       ||\\n\"#);\r\n\t#printf(#[Fields]\"    ||                                     ||\\n\"#);\r\n\t#printf(#[Fields]\"    ||=====================================||\\n\"#);\r\n\t#printf(#[Fields]\"      Please input your choose(1-6): \"#);\r\n#}\r\nmain()\r\n{\r\n    #[Keywords]int #choose;\r\n    #stud *head,*searchpoint,*forepoint;\r\n    #[Keywords]char #fullname[20];\r\n   #[Keywords] while#(1)\r\n    #{\r\n        #menu();\r\n        #scanf(#[Fields]\"%d\"#,&choose);\r\n        #switch(choose)\r\n        #{\r\n            #[Keywords]case #1:\r\n            \t#clrscr();\r\n            \t#head=creat();\r\n            \t#puts(#[Fields]\"Linklist created successfully! \\nPress any key to return...\"#);\r\n            \t#getch();\r\n            #[Keywords]break#;\r\n            #[Keywords]case #2:\r\n            \t#clrscr();\r\n                #printf(#[Fields]\"Input the student#[Fields]'s name which you want to find:\\n\"#);\r\n                #scanf(#[Fields]\"%s\"#,fullname);\r\n                #searchpoint=search(head,fullname);\r\n                #printf(#[Fields]\"The stud name you want to find is:%s\"#,*&searchpoint->name);\r\n                #printf(#[Fields]\"\\nPress any key to returen...\"#);\r\n\t    \t\t#getchar();\r\n\t    \t\t#getchar();\r\n                #[Keywords]break#;\r\n            #[Keywords]case #3:\r\n                #clrscr();\r\n                #insert(head);\r\n                #print(head);\r\n                #printf(#[Fields]\"\\nPress any key to returen...\"#);\r\n                #getchar();getchar();\r\n                #[Keywords]break#;\r\n            #[Keywords]case #4:\r\n                #clrscr();\r\n                #print(head);\r\n                #printf(#[Fields]\"\\nInput the student#[Fields]'s name which you want to delete:\\n\"#);\r\n                #scanf(#[Fields]\"%s\"#,fullname);\r\n                #searchpoint=search(head,fullname);\r\n                #forepoint=search2(head,fullname);\r\n                #del(forepoint,searchpo#[Keywords]int#);\r\n                #print(head);\r\n\t    #puts(#[Fields]\"\\nDelete successfully! Press any key to return...\"#);\r\n\t    #getchar();\r\n\t    #getchar();\r\n                #[Keywords]break#;\r\n            #[Keywords]case #5:print(head);\r\n                #printf(#[Fields]\"\\nPress any key to return...\"#);\r\n                #getchar();getchar();\r\n                #[Keywords]break#;\r\n            #[Keywords]case #6:quit();\r\n                #[Keywords]break#;\r\n            #[Keywords]default#:\r\n                #clrscr();\r\n                #printf(#[Fields]\"Illegal letter! Press any key to return...\"#);\r\n                #menu();\r\n                #getchar();\r\n        #}\r\n    #}\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        114,
        "链表操作（2）",
        "代码如下：\r\n[code=java]\r\n#include #[Fields]\"stdafx.h\r\n#include #[Fields]\"stdio.h\r\n#ifndef SQLIST_H\r\n#define SQLIST_H\r\n#include <stdlib.h>\r\n#define List_INIT_SIZE  100   #[Comments]\/\/线性表的存储空间初始大小\r\n#define LIST_INCREMENT  10    #[Comments]\/\/分配增量\r\n#define OVERFLOW   -2\r\n#define OK     1\r\n#define ERROR    -1\r\n#define TRUE    1\r\n#define FALSE    0\r\ntypedef #[Keywords]int # ElemType;\r\ntypedef struct{\r\n\t#ElemType *elem;  #[Comments]\/\/存储空间基址\r\n\t#[Keywords]int #  length;  #[Comments]\/\/当前长度\r\n\t#[Keywords]int #  size;    #[Comments]\/\/当前存储容量(sizeof(ElemType)为单位)\r\n#}SqList;\r\n#[Keywords]int #InitList(SqList &L)\r\n{\r\n\t#[Comments]\/\/构建一个线性表L\r\n\t#L.elem = (ElemType*)malloc(List_INIT_SIZE*sizeof(ElemType));\r\n\t#[Keywords]if#(!L.elem)\r\n\t#{\r\n\t\t#exit(OVERFLOW);\r\n\t#}\r\n\t#L.length = 0;\r\n\t#L.size = List_INIT_SIZE;\r\n\t#[Keywords]return #OK;\r\n#}#[Comments]\/\/InitList\r\n\r\n#[Keywords]void #DestoryList(SqList &L)\r\n{\r\n\t#[Keywords]if#(!L.elem)\r\n\t#{\r\n\t\t#delete L.elem;\r\n\t\t#L.elem = NULL;\r\n\t#}\r\n\t#L.length = 0;\r\n\t#L.size = 0;\r\n#}#[Comments]\/\/DestoryList\r\n\r\n#[Keywords]void #ClearList(SqList &L)\r\n{\r\n\t#L.elem = NULL;\r\n\t#L.length = 0;\r\n\t#L.size = List_INIT_SIZE;\r\n#}#[Comments]\/\/ClearList\r\n\r\n#[Keywords]int #ListEmpty(SqList L)\r\n{\r\n\t#[Keywords]if#(L.length > 0)\r\n\t#{\r\n\t\t#[Keywords]return #TRUE;\r\n\t#}\r\n\t#else\r\n\t#{\r\n\t\t#[Keywords]return #FALSE;\r\n\t#}\r\n#}#[Comments]\/\/ListEmpty\r\n\r\n#[Keywords]int #ListLength(SqList L)\r\n{\r\n\t#[Keywords]return #L.length;\r\n#}#[Comments]\/\/ListLength\r\n\r\n#[Keywords]int #ListInsert(SqList &L, #[Keywords]int #i, ElemType e)\r\n{\r\n\t#[Keywords]if#(i<1 || i>ListLength(L)+1) #[Comments]\/\/需满足条件1<i<ListLength(L)+1\r\n\t#{\r\n\t\t#[Keywords]return #ERROR;\r\n\t#}\r\n\t#ElemType * NewBase;  #[Comments]\/\/新的基址\r\n\t#[Keywords]if#(L.length > L.size) #[Comments]\/\/空间已满\r\n\t#{\r\n\t\t#NewBase = (ElemType*)malloc((L.size+LIST_INCREMENT)*sizeof(ElemType));  #[Comments]\/\/申请新的空间\r\n\t\t#[Keywords]if#(!NewBase)\r\n\t\t#{\r\n\t\t\t#exit(OVERFLOW);\r\n\t\t#}\r\n\t\t#L.elem = NewBase;\r\n\t\t#L.size +=LIST_INCREMENT;\r\n\t\t#delete NewBase;\r\n\t\t#NewBase = NULL;\r\n\t#}\r\n\t#ElemType *p;\r\n\t#ElemType *temp;\r\n\t#p = &(L.elem[i-1]);  #[Comments]\/\/取得i的位置，即插入位置\r\n\t#[Keywords]for#(temp = &(L.elem[L.length-1]);temp>p;--temp)  #[Comments]\/\/将插入点后的所有元素向后移动一位\r\n\t#{\r\n\t\t#[Tags]*(temp+1) = #[Tags]*temp;\r\n\t#}\r\n\t#[Tags]*p = e;\r\n\t#++L.length;\r\n\t#[Keywords]return #OK;\r\n#}#[Comments]\/\/ListInsert\r\n\r\n#[Keywords]int #ListDelete(SqList &L, #[Keywords]int #i, ElemType &e)\r\n{\r\n\t#[Keywords]if #(i<0 || i>ListLength(L)) {\r\n\t\t#[Keywords]return #ERROR;\r\n\t#}\r\n\t#ElemType *p;\r\n\t#p = &(L.elem[i-1]);\r\n\t#e = *p;\r\n\t#ElemType *pos;\r\n\t#pos =&(L.elem[L.length-1]);\r\n\t#[Keywords]for#(++p; p<=pos; ++p){\r\n\t\t#[Tags]*(p-1) = #[Tags]*p;\r\n\t#}\r\n\t#--L.length;\r\n\t#[Keywords]return #OK;\r\n#}\r\n#end#[Keywords]if #[Comments]\/\/SQLIST_H\r\n#[Keywords]int #main(){\r\n\t#SqList list;\r\n\t#ElemType e;\r\n\t#InitList(list);\r\n\t#ListInsert(list, 1, 1);\r\n\t#ListInsert(list, 2, 2);\r\n\t#ListInsert(list, 3, 3);\r\n\t#ListInsert(list, 4, 4);\r\n\t#ListInsert(list, 5, 5);\r\n\t#[Keywords]for#(#[Keywords]int #i =0; i<list.length; i++){\r\n\t\t#printf(#[Fields]\"%d\\n\"#,list.elem[i]);\r\n\t#}\r\n\t#ListDelete(list, 2, e);\r\n\t#[Keywords]for#(i =0; i<list.length; i++){\r\n\t\t#printf(#[Fields]\"%d\\n\"#,list.elem[i]);\r\n\t#}\tprintf(#[Fields]\"%d\\n\"#, list.length);\r\n\t\r\n\t#[Keywords]return #1;\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        115,
        "单链表就地逆置",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#define NULL 0 #[Tags]\/*宏定义*\/\r\ntypedef struct node #[Tags]\/*定义结点类型的数据结构*\/\r\n{\r\n\t#[Keywords]char #c; #[Tags]\/*数据域，类型为字符型*\/\r\n\t#struct node *next; #[Tags]\/*指针域，类型为本结构体类型*\/\r\n#}Node,*L; #[Tags]\/*类型重定义，即Node和*L和struct node等价*\/\r\nmain()\r\n{\r\n\t#L l,p,q,r; #[Tags]\/*用指针类型定义三个结点类型的指针*\/\r\n\t#[Keywords]char #ch;\r\n\t#l=(L)malloc(sizeof(Node)); #[Tags]\/*分配内存空间*\/\r\n\t#l->c=#[Fields]'\\0'#; #[Tags]\/*为头结点的数据域赋值，值为空*\/\r\n\t#l->next=NULL; #[Tags]\/*指明下一个结点目前不存在*\/\r\n\t#q=l; #[Tags]\/*q为游动指针，链表结点的连结要用*\/\r\n\t#printf(#[Fields]\"Input a character:\\n\"#);\r\n\t#scanf(#[Fields]\"%c\"#,&ch);\r\n\t#getchar();\r\n\t#[Keywords]while#(ch!=#[Fields]'0'#) #[Tags]\/*输入0表示输入结束*\/\r\n\t#{\r\n\t\t#p=(L)malloc(sizeof(Node)); #[Tags]\/*为新输入的数据分配内存空间*\/\r\n\t\t#p->c=ch;\r\n\t\t#p->next=NULL; #[Tags]\/*新输入的结点在链表的最后，即它的后面没有其它元素*\/\r\n\t\t#q->next=p; #[Tags]\/*q用于将上一个元素链接至当前新元素*\/\r\n\t\t#q=p; #[Tags]\/*q自己移到当前最后一个元素，以备继续链接所用*\/\r\n\t\t#scanf(#[Fields]\"%c\"#,&ch);\r\n\t\t#getchar();\r\n\t#}\t\r\n\t#\/*以上完成了单链表的创建*\/\r\n\t#q=l->next;\r\n\t#p=q->next;\r\n\t#r=p->next;\r\n\t#q->next=NULL;\r\n\t#[Keywords]while#(r!=NULL)\r\n\t#{\r\n\t\t#p->next=q;\r\n\t\t#q=p;\r\n\t\t#p=r;\r\n\t\t#[Keywords]if#(r->next!=NULL) #[Tags]\/*r后面还有结点，则逆置继续*\/\r\n\t\t\t#r=r->next;\r\n\t\t#else\r\n\t\t\t#[Keywords]break#;\r\n\t#}\r\n\t#r->next=q;\r\n\t#l->next=r; #[Comments]\/\/头结点指向最后一个结点\r\n\t\r\n\t#q=l; #[Tags]\/*输入整个链表前，先将q移到链表头，l一般不动*\/\r\n\t#[Keywords]while#(q->next!=NULL) #[Tags]\/*若q所指向的元素后面还有其它元素，则将该元素的数据输出*\/\r\n\t#{\r\n\t\t#printf(#[Fields]\"%c-->\"#,q->next->c); #[Tags]\/*q->next->c表示q所指向的下一个元素的数据*\/\r\n\t\t#q=q->next; #[Tags]\/*完成该元素的输出后，q移至下一个元素重复输出操作*\/\r\n\t#}\r\n\t#printf(#[Fields]\"\\n\"#);\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        116,
        "运动会分数统计",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <malloc.h>\r\n#define n 4\r\n#define m 3\r\n#define w 2\r\nstruct achievement  #[Comments]\/\/定义表示成绩的结构体\r\n{#[Keywords]int #schoolnumber;#[Comments]\/\/学校编号\r\n#[Keywords]char #name[20];\t#[Comments]\/\/姓名\r\n#[Keywords]int #mark;\t#[Comments]\/\/分数\r\n#[Keywords]int #result;#};\r\nstruct pro     #[Comments]\/\/表示项目的结构体\r\n{#[Keywords]int #tag;#[Comments]\/\/项目编号\r\nstruct achievement ach[5];\r\n#[Keywords]int #number;#};\r\nstruct Node         \r\n{struct pro date;\r\nstruct Node *next;#};\r\n#[Keywords]void #ListInitiate(struct Node * *head)    #[Comments]\/\/初始化单链表\r\n{\r\n    #[Keywords]if#((*head=(struct Node*)malloc(sizeof(struct Node)))==NULL) exit(1);\r\n    #(*head)->next=NULL;\r\n#}\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #i,j,t;\r\n    #[Keywords]int #x[n]={0#};#[Keywords]int #y[n]={0#};\r\n    #struct Node *head;\r\n    #struct Node *p;\r\n    #struct Node *q;\r\n    #ListInitiate(&head);\r\n    #p=head;\r\n\t#[Keywords]for#(i=0;i<m+w;i++)      #[Comments]\/\/输入成绩\r\n    #{\r\n        #j=i+1;\r\n        #printf(#[Fields]\"请输入第%d个项目的信息\\n\"#,j);\r\n        #p->date.number=j;\r\n        #printf(#[Fields]\"所取的名次数为:\"#);\r\n        #scanf(#[Fields]\"%d\"#,&p->date.tag);\r\n       #[Keywords] while#(p->date.tag!=3&&p->date.tag!=5)\r\n        #{printf(#[Fields]\"输入有误，请重新输入!\"#);\r\n\t\t#printf(#[Fields]\"所取的名次数为:\"#);\r\n\t\t#scanf(#[Fields]\"%d\"#,&p->date.tag);#}\r\n        #t=1;\r\n       #[Keywords] while#(t<=p->date.tag)\r\n        #{\r\n            #printf(#[Fields]\"第%d名的名字:\"#,t);\r\n            #scanf(#[Fields]\"%s\"#,&p->date.ach[t-1].name);\r\n            #printf(#[Fields]\"第%d名的学校:\"#,t);\r\n            #scanf(#[Fields]\"%d\"#,&p->date.ach[t-1].schoolnumber);\r\n            #printf(#[Fields]\"第%d名的分数:\"#,t);\r\n            #scanf(#[Fields]\"%d\"#,&p->date.ach[t-1].mark);\r\n            #p->date.ach[t-1].result=t;\r\n            #t++;\r\n        #}\r\n        #q=(struct Node*)malloc(sizeof(struct Node));  #[Comments]\/\/生成新结点\r\n        #p->next=q;\r\n        #p=q;\r\n        #p->next=NULL;\r\n    #}\r\n\t#[Keywords]for#(i=0;i<n;i++)     #[Comments]\/\/产生成绩单\r\n\t#{\r\n\t\t#j=i+1;\r\n\t\t#printf(#[Fields]\"学校%d成绩单\\n\"#,j);\r\n\t\t#[Comments]\/\/t=1;\r\n\t\t#p=head;\r\n\t\t#do\r\n\t\t#{\r\n\t\t\t#t=1;\r\n\t\t\t#[Keywords]while#(t<=p->date.tag)\r\n\t\t\t#{\r\n\t\t\t\t#[Keywords]if#(p->date.ach[t-1].schoolnumber==j)\r\n\t\t\t\t#{\r\n\t\t\t\t\t#printf(#[Fields]\"获奖项目:%d   \"#,p->date.number);\r\n\t\t\t\t\t#printf(#[Fields]\"名次:%d   \\n\"#,p->date.ach[t-1].result);\r\n\t\t\t\t\t#printf(#[Fields]\"获奖人姓名:%s   \"#,p->date.ach[t-1].name);\r\n\t\t\t\t\t#printf(#[Fields]\"所得分数:%d   \"#,p->date.ach[t-1].mark);\r\n\t\t\t\t\t#[Keywords]if#(p->date.number<=m)\r\n\t\t\t\t\t\t#x[i]=x[i]+p->date.ach[t-1].mark;\r\n\t\t\t\t\t#else\r\n\t\t\t\t\t\t#y[i]=y[i]+p->date.ach[t-1].mark;\r\n\t\t\t\t#}    \r\n\t\t\t\t#t++;\r\n\t\t\t#}\r\n\t\t\t#p=p->next;\r\n\t\t#}#[Keywords]while#(p!=NULL);\r\n\t\t#printf(#[Fields]\"\\n男子团体总分:%d   \"#,x[i]);\r\n\t\t#printf(#[Fields]\"女子团体总分:%d   \\n\"#,y[i]);\r\n\t\t#printf(#[Fields]\"\\n团体总分:%d\\n\"#,x[i]+y[i]);\r\n\t#}\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        117,
        "双链表",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define N 10\r\ntypedef struct node\r\n{\r\n    #[Keywords]char #name[20];\r\n    #struct node *llink,*rlink;\r\n#}stud;#[Tags]\/*双链表的结构定义*\/\r\n#[Tags]\/*双链表的创建*\/\r\nstud * creat(#[Keywords]int #n)\r\n{\r\n    #stud *p,*h,*s;\r\n    #[Keywords]int #i;\r\n    #[Keywords]if#((h=(stud *)malloc(sizeof(stud)))==NULL)\r\n    #{\r\n        #printf(#[Fields]\"cannot find space!\\n\"#);\r\n        #exit(0);\r\n    #}\r\n    #h->name[0]=#[Fields]'\\0'#;\r\n    #h->llink=NULL;\r\n    #h->rlink=NULL;\r\n    #p=h;\r\n    #[Keywords]for#(i=0;i<n;i++)\r\n    #{\r\n        #[Keywords]if#((s= (stud *) malloc(sizeof(stud)))==NULL)\r\n        #{\r\n            #printf(#[Fields]\"cannot find space!\\n\"#);\r\n            #exit(0);\r\n        #}\r\n        #p->rlink=s;\r\n\t#printf(#[Fields]\"Please input the %d man#[Fields]'s name: \"#,i+1);\r\n        #scanf(#[Fields]\"%s\"#,s->name);\r\n        #s->llink=p;\r\n        #s->rlink=NULL;\r\n        #p=s;\r\n    #}\r\n    #h->llink=s;\r\n    #p->rlink=h;\r\n    #return(h);\r\n#}\r\n#[Tags]\/*查找*\/\r\nstud * search(stud *h,#[Keywords]char #*x)\r\n{\r\n    #stud *p;\r\n    #[Keywords]char #*y;\r\n    #p=h->rlink;\r\n   #[Keywords] while#(p!=h)\r\n    #{\r\n        #y=p->name;\r\n        #[Keywords]if#(strcmp(y,x)==0)\r\n            #return(p);\r\n        #[Keywords]else #p=p->rlink;\r\n    #}\r\n    #printf(#[Fields]\"cannot find data!\\n\"#);\r\n#}\r\n#[Tags]\/*打印输出*\/\r\n#[Keywords]void #print(stud *h)\r\n{\r\n    #stud *p;\r\n    #p=h->rlink;\r\n    #printf(#[Fields]\"\\nNow the #[Keywords]double #list is:\\n\"#);\r\n   #[Keywords] while#(p!=h)\r\n    #{\r\n        #printf(#[Fields]\"%s \"#,&*(p->name));\r\n        #p=p->rlink;\r\n    #}\r\n    #printf(#[Fields]\"\\n\"#);\r\n#}\r\n#[Tags]\/*删除*\/\r\n#[Keywords]void #del(stud *p)\r\n{\r\n    #(p->rlink)->llink=p->llink;\r\n    #(p->llink)->rlink=p->rlink;\r\n    #free (p);\r\n#}\r\n#[Tags]\/*主函数*\/\r\nmain()\r\n{\r\n    #[Keywords]int #number;\r\n    #[Keywords]char #studname[20];\r\n    #stud *head,*searchpoint;\r\n    #number=N;\r\n    #clrscr();\r\n    #puts(#[Fields]\"Please input the size of the list:\"#);\r\n    #scanf(#[Fields]\"%d\"#,&number);\r\n    #head=creat(number);\r\n    #print(head);\r\n    #printf(#[Fields]\"\\nPlease input the name which you want to find:\\n\"#);\r\n    #scanf(#[Fields]\"%s\"#,studname);\r\n    #searchpoint=search(head,studname);\r\n    #printf(#[Fields]\"the name you want to find is:%s\\n\"#,*&searchpoint->name);\r\n    #del(searchpo#[Keywords]int#);\r\n    #print(head);\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        118,
        "约瑟夫环",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#include <malloc.h>\r\n#define  N 7                                         \r\n#[Comments]\/\/定义N=7，表示有7个链表单元\r\n#define  OVERFLOW  0\r\n#define  OK  1\r\ntypedef struct LNode \r\n{\r\n    #[Comments]\/\/定义链表结构\r\n    #[Keywords]int #password ;\r\n    #[Keywords]int #order ;\r\n    #struct LNode*next ;\r\n#}\r\nLNode,*LinkList ;\r\n#[Keywords]int #PassW[N]=\r\n{\r\n    #3,1,7,2,4,8,4\r\n#}\r\n;\r\n#[Keywords]void #Joseph(LinkList p,#[Keywords]int #m,#[Keywords]int #x);\r\n#[Comments]\/\/声明函数\r\n#[Keywords]int #main()\r\n{\r\n    #[Keywords]int #i,m ;\r\n    #LinkList Lhead,p,q ;\r\n    #[Comments]\/\/定义三个指向链表结构的指针\r\n    #Lhead=(LinkList)malloc(sizeof(LNode));\r\n    #[Comments]\/\/初始化头节点\r\n    #[Keywords]if#(!Lhead)#[Keywords]return #OVERFLOW ;\r\n    #[Comments]\/\/分配空间失败返回\r\n    #Lhead->password=PassW[0];\r\n    #Lhead->order=1 ;\r\n    #Lhead->next=NULL ;\r\n    #p=Lhead ;\r\n    #[Keywords]for#(i=1;i<7;i++)\r\n    #{\r\n        #[Keywords]if#(!(q=(LinkList)malloc(sizeof(LNode))))#[Keywords]return #OVERFLOW ;\r\n        #q->password=PassW[i];\r\n        #[Comments]\/\/初始化循环列表中的密码值\r\n        #q->order=i+1 ;\r\n        #p->next=q ;\r\n        #p=q ;\r\n        #[Comments]\/\/新创建一个指针节点并使p->next指向它,再使p=q\r\n    #}\r\n    #p->next=Lhead ;\r\n    #[Comments]\/\/使p->next指向头节点,从而形成循环链表\r\n    #printf(#[Fields]\"请输入第一次计数值m:  \\n\"#);\r\n    #scanf(#[Fields]\"%d\"#,&m);\r\n    #[Comments]\/\/用户输入第一次计数值m\r\n    #printf(#[Fields]\"第一次计数值m= %d \\n\"#,m);\r\n    #Joseph(p,m,N);\r\n    #[Keywords]return #OK ;\r\n#}\r\n#[Keywords]void #Joseph(LinkList p,#[Keywords]int #m,#[Keywords]int #x)\r\n{\r\n    #LinkList q ;\r\n    #[Keywords]int #i ;\r\n    #[Keywords]if#(x==0)#[Keywords]return #;\r\n    #[Comments]\/\/链表中没有节点的话,立即返回上一层函数\r\n    #q=p ;\r\n    #m%=x ;\r\n    #[Comments]\/\/m对x求余,从而求出链表中的第几个单元是所求节点\r\n    #[Keywords]if#(m==0)m=x ;\r\n    #[Comments]\/\/若m刚好可以整除x,则令m=x,因为如果m=0,则不进行下一个\r\n    #[Comments]\/\/for循环,那样就无法使q指向要删除节点,p指向他的的前一节点,那样则无法进行删除操作\r\n    #[Keywords]for#(i=1;i<=m;i++)\r\n    #{\r\n        #p=q ;\r\n        #q=p->next ;\r\n        #[Comments]\/\/使q指向要删除的节点,p指向q的前一个节点\r\n    #}\r\n    #p->next=q->next ;\r\n    #[Comments]\/\/从循环链表中删除q指向的节点\r\n    #i=q->password ;\r\n    #printf(#[Fields]\"%d  \"#,q->order);\r\n    #free(q);\r\n    #[Comments]\/\/释放q指向的空间\r\n    #Joseph(p,i,x-1);\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        119,
        "记录个人资料",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\nstruct Family*get_person(void);\r\n#[Tags]\/* Prototype #[Keywords]for #input function *\/\r\n#[Keywords]char #related(struct Family*pmember1,struct Family*pmember2);\r\n#[Keywords]char #set_ancestry(struct Family*pmember1,struct Family*pmember2);\r\nstruct Date \r\n{\r\n    #[Keywords]int #day ;\r\n    #[Keywords]int #month ;\r\n    #[Keywords]int #year ;\r\n#}\r\n;\r\n#[Tags]\/* Family structure declaration   *\/\r\nstruct Family \r\n{\r\n    #struct Date dob ;\r\n    #[Keywords]char #name[20];\r\n    #[Keywords]char #father[20];\r\n    #[Keywords]char #mother[20];\r\n    #struct Family*next ;\r\n    #[Tags]\/* Pointer to next structure      *\/\r\n    #struct Family*previous ;\r\n    #[Tags]\/* Pointer to previous structure  *\/\r\n    #struct Family*p_to_pa ;\r\n    #[Tags]\/* Pointer to father structure   *\/\r\n    #struct Family*p_to_ma ;\r\n    #[Tags]\/* Pointer to mother structure   *\/\r\n#}\r\n;\r\n#[Keywords]void #main()\r\n{\r\n    #struct Family*first=NULL ;\r\n    #[Tags]\/* Pointer to first person        *\/\r\n    #struct Family*current=NULL ;\r\n    #[Tags]\/* Pointer to current person      *\/\r\n    #struct Family*last=NULL ;\r\n    #[Tags]\/* Pointer to previous person     *\/\r\n   \r\n    #[Keywords]char #more=#[Fields]'\\0'# ;\r\n    #[Tags]\/* Test value #[Keywords]for #ending input    *\/\r\n    #[Keywords]for#(;;)\r\n    #{\r\n        #printf(#[Fields]\"\\nDo you want to enter details of a%s person (Y or N)? \"#,\r\n        #first!=NULL?#[Fields]\"nother \"#:#[Fields]\"\"#);\r\n        #scanf(#[Fields]\" %c\"#,&more);\r\n        #[Keywords]if#(tolower(more)==#[Fields]'n'#)\r\n        #[Keywords]break# ;\r\n        #current=get_person();\r\n        #[Keywords]if#(first==NULL)\r\n        #{\r\n            #first=current ;\r\n            #[Tags]\/* Set pointer to first Family    *\/\r\n            #last=current ;\r\n            #[Tags]\/* Remember #[Keywords]for #next iteration    *\/\r\n        #}\r\n        #[Keywords]else #\r\n        #{\r\n            #last->next=current ;\r\n            #[Tags]\/* Set next address #[Keywords]for #previous Family *\/\r\n            #current->previous=last ;\r\n            #[Tags]\/* Set previous address #[Keywords]for #current *\/\r\n            #last=current ;\r\n            #[Tags]\/* Remember #[Keywords]for #next iteration *\/\r\n        #}\r\n    #}\r\n    #current=first ;\r\n    #\/* Check #[Keywords]for #relation #[Keywords]for #each person in    *\/\r\n   #[Keywords] while#(current->next!=NULL)\r\n    #{\r\n        #[Tags]\/* the list up to second to last            *\/\r\n        #[Keywords]int #parents=0 ;\r\n        #[Tags]\/* Declare parent count local to #[Keywords]this# block *\/\r\n        #last=current->next ;\r\n        #[Tags]\/* Get the pointer to the next              *\/\r\n        #[Tags]\/* This loop tests current person           *\/\r\n       #[Keywords] while#(last!=NULL)\r\n        #{\r\n            #[Tags]\/* against all the remainder in the list    *\/\r\n            #[Tags]\/* Found a parent ?          *\/\r\n            #[Tags]\/* Yes, update count and check it        *\/\r\n            #[Keywords]if#(related(current,last))#[Keywords]if#(++parents==2)#[Keywords]break# ;\r\n            #[Tags]\/* Exit inner loop #[Keywords]if #both parents found *\/\r\n            #last=last->next ;\r\n            #[Tags]\/* Get the address of the next           *\/\r\n        #}\r\n        #current=current->next ;\r\n        #[Tags]\/* Next in the list to check             *\/\r\n    #}\r\n    #[Tags]\/* Now tell them what we know *\/\r\n    #[Tags]\/* Output Family data in correct order *\/\r\n    #current=first ;\r\n    #[Tags]\/* Output Family data in correct order  *\/\r\n   #[Keywords] while#(current!=NULL)\r\n    #{\r\n        #printf(#[Fields]\"\\n%s was born %d\/%d\/%d, and has %s and %s as parents.\"#,\r\n        #current->name,current->dob.day,current->dob.month,\r\n        #current->dob.year,current->father,current->mother);\r\n        #[Keywords]if#(current->p_to_pa!=NULL)\r\n        #printf(#[Fields]\"\\n\\t%s#[Fields]'s birth date is %d\/%d\/%d  \"#,\r\n        #current->father,current->p_to_pa->dob.day,\r\n        #current->p_to_pa->dob.month,\r\n        #current->p_to_pa->dob.year);\r\n        #[Keywords]if#(current->p_to_ma!=NULL)\r\n        #printf(#[Fields]\"and %s#[Fields]'s birth date is %d\/%d\/%d.\\n  \"#,\r\n        #current->mother,current->p_to_ma->dob.day,\r\n        #current->p_to_ma->dob.month,\r\n        #current->p_to_ma->dob.year);\r\n        #current=current->next ;\r\n        #[Tags]\/* current points to next in list       *\/\r\n    #}\r\n    #[Tags]\/* Now free the memory *\/\r\n    #current=first ;\r\n   #[Keywords] while#(current->next!=NULL)\r\n    #{\r\n        #last=current ;\r\n        #[Tags]\/* Save pointer to enable memory to be freed *\/\r\n        #current=current->next ;\r\n        #[Tags]\/* current points to next in list       *\/\r\n        #free(last);\r\n        #[Tags]\/* Free memory #[Keywords]for #last                      *\/\r\n    #}\r\n#}\r\n#[Tags]\/*   Function to input data on Family members   *\/\r\nstruct Family*get_person(void)\r\n{\r\n    #struct Family*temp ;\r\n    #[Tags]\/* Define temporary structure pointer *\/\r\n    #[Tags]\/* Allocate memory #[Keywords]for #a structure *\/\r\n    #temp=(struct Family*)malloc(sizeof(struct Family));\r\n    #printf(#[Fields]\"\\nEnter the name of the person: \"#);\r\n    #scanf(#[Fields]\"%s\"#,temp->name);\r\n    #[Tags]\/* Read the Family#[Fields]'s name *\/\r\n    #printf(#[Fields]\"\\nEnter %s#[Fields]'s date of birth (day month year); \"#,temp->name);\r\n    #scanf(#[Fields]\"%d %d %d\"#,&temp->dob.day,&temp->dob.month,&temp->dob.year);\r\n    #printf(#[Fields]\"\\nWho is %s#[Fields]'s father? \"#,temp->name);\r\n    #scanf(#[Fields]\"%s\"#,temp->father);\r\n    #[Tags]\/* Get the father#[Fields]'s name *\/\r\n    #printf(#[Fields]\"\\nWho is %s#[Fields]'s mother? \"#,temp->name);\r\n    #scanf(#[Fields]\"%s\"#,temp->mother);\r\n    #[Tags]\/* Get the mother#[Fields]'s name *\/\r\n    #temp->next=temp->previous=NULL ;\r\n    #[Tags]\/* Set pointers to NULL *\/\r\n    #temp->p_to_pa=temp->p_to_ma=NULL ;\r\n    #[Tags]\/* Set pointers to NULL  *\/\r\n    #[Keywords]return #temp ;\r\n    #[Tags]\/* Return address of Family structure *\/\r\n#}\r\n#[Keywords]char #set_ancestry(struct Family*pmember1,struct Family*pmember2)\r\n{\r\n    #[Keywords]if#(strcmp(pmember1->father,pmember2->name)==0)\r\n    #{\r\n        #pmember1->p_to_pa=pmember2 ;\r\n        #[Keywords]return #1 ;\r\n    #}\r\n    #[Keywords]if#(strcmp(pmember1->mother,pmember2->name)==0)\r\n    #{\r\n        #pmember1->p_to_ma=pmember2 ;\r\n        #[Keywords]return #1 ;\r\n    #}\r\n    #[Keywords]else #\r\n    #[Keywords]return #0 ;\r\n#}\r\n#[Tags]\/* Fill in pointers #[Keywords]for #mother or father relationships *\/\r\n#[Keywords]char #related(struct Family*pmember1,struct Family*pmember2)\r\n{\r\n    #[Keywords]return #set_ancestry(pmember1,pmember2)||\r\n    #set_ancestry(pmember2,pmember1);\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        120,
        "二叉树遍利",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\ntypedef struct bitnode\r\n{\r\n\t#[Keywords]char #data;\r\n\t#struct bitnode *lchild, *rchild;\r\n#}bitnode, *bitree;\r\n#[Keywords]void #createbitree(t,n)\r\nbitnode ** t;\r\n#[Keywords]int #*n;\r\n{\r\n\t#[Keywords]char #x;\r\n\t#bitnode *q;\r\n\t#[Tags]*n=#[Tags]*n+1;\r\n\t#printf(#[Fields]\" Input  %d  DATA: \"#,*n);\r\n\t#x=getchar();\r\n\t#[Keywords]if#(x!=#[Fields]'\\n'#) getchar();\r\n\t#[Keywords]if #(x==#[Fields]'^'#)\r\n\t#[Keywords]return#;#\r\n\t#q=(bitnode*)malloc(sizeof(bitnode));\r\n\t#q->data=x;\r\n\t#q->lchild=NULL;\r\n\t#q->rchild=NULL;\r\n\t#[Tags]*t=q;\r\n\t#printf(#[Fields]\"This Address is:%o,Data is:%c, Left Pointer is:%o,Right Pointer is:  %o\\n\"#,q,q->data,q->lchild,q->rchild);\r\n\t#createbitree(&q->lchild,n);\r\n\t#createbitree(&q->rchild,n);\r\n\t#[Keywords]return#;#\r\n#}\r\n#[Keywords]void #visit(e)\r\nbitnode *e;\r\n{\r\n\t#printf(#[Fields]\"  Address:  %o,  Data:  %c,  Left Pointer:  %o,  Right Pointer:  %o\\n\"#,e,e->data,e->lchild,e->rchild);\r\n#}\r\n#[Keywords]void #preordertraverse(t)\r\nbitnode *t;\r\n{\r\n\t#[Keywords]if#(t)\r\n\t#{\r\n\t\t#visit(t);\r\n\t\t#preordertraverse(t->lchild);\r\n\t\t#preordertraverse(t->rchild);\r\n\t\t#[Keywords]return #;\r\n\t#}#[Keywords]else #[Keywords]return #;\r\n#}\r\n#[Keywords]void #countleaf(t,c)\r\nbitnode *t;\r\n#[Keywords]int #*c;\r\n{\r\n\t#[Keywords]if#(t!=NULL)\r\n  \t#{\r\n\t\t  #[Keywords]if #(t->lchild==NULL && t->rchild==NULL)\r\n\t\t  #{\r\n\t\t  \t#[Tags]*c=#[Tags]*c+1;\r\n\t\t  #}\r\n   \t\t#countleaf(t->lchild,c);\r\n   \t\t#countleaf(t->rchild,c);\r\n  \t#}\r\n \t#[Keywords]return#;#\r\n#}\r\n#[Keywords]int #treehigh(t)\r\nbitnode *t;\r\n{\r\n\t #[Keywords]int #lh,rh,h;\r\n \t #[Keywords]if#(t==NULL)\r\n\t \t#h=0;\r\n\t#[Keywords] else#\r\n\t #{\r\n\t \t#lh=treehigh(t->lchild);\r\n\t \t#rh=treehigh(t->rchild);\r\n\t \t#h=(lh>rh ? lh:rh)+1;\r\n\t #}\r\n\r\n\t #[Keywords]return #h;\r\n#}\r\nmain()\r\n{\r\n\t#bitnode *t; #[Keywords]int #count=0;\r\n\t#[Keywords]int #n=0;\r\n\t#clrscr();\r\n\t#printf(#[Fields]\"Please initialize the TREE!\\n\"#);\r\n\t#createbitree(&t,&n);\r\n\t#printf(#[Fields]\"\\n This is TREE Struct:\\n\"#);\r\n\t#preordertraverse(t);\r\n\t#countleaf(t,&count);\r\n\t#printf(#[Fields]\" This TREE has %d leaves.\"#,count);\r\n\t#printf(#[Fields]\"\\n High of The TREE is: %d\\n\"#,treehigh(t));\r\n\t#puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        121,
        "浮点数转换为字符串",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#include <string.h>\r\n#[Keywords]char #c_je[51];  #[Tags]\/*大写金额字符变量*\/\r\nchar* zh( x )   #[Tags]\/*数字金额转换为大写金额子程序*\/\r\n#[Keywords]double #x;       #[Tags]\/*要转换的金额数*\/\r\n{\r\n\t#[Keywords]int #i, n, bz;\r\n\t#[Keywords]char #je[14];        #[Tags]\/*数字金额的字符变量*\/\r\n\t#[Keywords]char #temp[13];\r\n\t#[Keywords]char #f1[10][3] = {#[Fields]\"零\"#,#[Fields]\"壹\"#,#[Fields]\"贰\"#,#[Fields]\"叁\"#,#[Fields]\"肆\"#,#[Fields]\"伍\"#,\r\n\t                  #[Fields]\"陆\"#,#[Fields]\"柒\"#,#[Fields]\"捌\"#,#[Fields]\"玖\"##}; #[Tags]\/*数字对应的大写数组变量*\/\r\n\t#[Keywords]char #f2[11][3] = {#[Fields]\"亿\"#,#[Fields]\"仟\"#,#[Fields]\"佰\"#,#[Fields]\"拾\"#,#[Fields]\"万\"#,\r\n\t                  #[Fields]\"仟\"#,#[Fields]\"佰\"#,#[Fields]\"拾\"#,#[Fields]\"元\"#,#[Fields]\"角\"#,#[Fields]\"分\"##}; #[Tags]\/*每位数字对应单位数组变量*\/\r\n\t#sprintf( je, #[Fields]\"%.01f\"#, 100*x); #[Tags]\/*转换成字符*\/\r\n\t#n = strlen( je );\r\n\t#c_je[0] = #[Fields]'\\0'#;\r\n\t#bz  = 1;\r\n\t#[Keywords]for#( i = 0; i < n; i++ )\r\n\t#{\r\n\t\t#strcpy( temp, &je[i] );  #[Tags]\/*复制到临时数组*\/\r\n\t\t#[Keywords]if#( atoi(temp)==0)    #[Tags]\/*判断第i位后是否全为0*\/\r\n\t\t#{\r\n\t\t\t#bz = 2;\r\n\t\t\t#[Keywords]break#;\r\n\t\t#}\r\n\t\t#[Keywords]if#( je[i] != #[Fields]'0'# )\r\n\t\t#{\r\n\t\t\t#[Keywords]if#( bz == 0 )\r\n\t\t\t\t#strcat( c_je, f1[0] );\r\n\t\t\t#strcat( c_je, f1[je[i] - #[Fields]'0'#] ); #[Tags]\/*数字串转化字符串*\/\r\n\t\t\t#bz = 1;\r\n\t\t\t#strcat( c_je, f2[13-n+i]);\r\n\t\t#}\r\n\t\t#else\r\n\t\t#{\r\n\t\t\t#[Keywords]if#( n-i == 7 && (je[i-1]!=#[Fields]'0'#||je[i-2]!=#[Fields]'0'# || je[i-3]!=#[Fields]'0'#)) #[Tags]\/*判断万位位置*\/\r\n\t\t\t\t#strcat( c_je, #[Fields]\"万\"# );\r\n\t\t\t#[Keywords]if#( n-i == 3 ) #[Tags]\/*判断个位数的元位置*\/\r\n\t\t\t\t#strcat( c_je, #[Fields]\"元\"#);\r\n\t\t\t#bz = 0;\r\n\t\t#}\r\n\t#}\r\n\t#[Keywords]if#( bz == 2 )\r\n\t#{\r\n\t\t#[Keywords]if#( n-i >= 7 && n-i < 10 )\r\n\t\t\t#strcat( c_je, #[Fields]\"万\"#) ; #[Tags]\/*万位数字为0，加‘万’*\/\r\n\t\t#[Keywords]if#( n-i >= 3 )\r\n\t\t\t#strcat( c_je, #[Fields]\"元\"#);\r\n\t\t#strcat( c_je, #[Fields]\"正\"# ); #[Tags]\/*最后不是分位，加“正”*\/\r\n\t#}\r\n\t#[Keywords]return #c_je; #[Tags]\/*返回大写金额*\/\r\n#}\r\nmain()\r\n{\r\n\t#[Keywords]double #count;\r\n\t#[Comments]\/\/clrscr();\r\n\t#printf(#[Fields]\"*********************************************************\\n\"#);\r\n\t#printf(#[Fields]\"*                                                       *\\n\"#);\r\n\t#printf(#[Fields]\"*           数字金额转换为大写金额程序 Ver.1.0          *\\n\"#);\r\n\t#printf(#[Fields]\"*                                                       *\\n\"#);\r\n\t#printf(#[Fields]\"*                                By RZLIN               *\\n\"#);\r\n\t#printf(#[Fields]\"*                                                       *\\n\"#);\r\n\t#printf(#[Fields]\"*               请输入要转换的金额：                    *\\n\"#);\r\n\t#printf(#[Fields]\"*                     \"#);\r\n\t#scanf(#[Fields]\"%lf\"#, &count );\r\n\t#printf(#[Fields]\"*           您输入的金额为：%10.2lf 。               *\\n\"#,count);\r\n\t#printf(#[Fields]\"*                                                       *\\n\"#);\r\n\t#printf(#[Fields]\"*转换为大写金额是：%s\\n\"#, zh( count ) );\r\n\t#printf(#[Fields]\"*                                                       *\\n\"#);\r\n\t#puts(#[Fields]\"*                请按任意键退出...                      *\"#);\r\n\t#printf(#[Fields]\"*********************************************************\\n\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        122,
        "汉诺塔问题",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/*\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/*\/\r\n#[Tags]\/*                          汉诺塔问题                          *\/\r\n#[Tags]\/*\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/*\/\r\n#include <stdio.h>\r\n#[Tags]\/* hanoil 子程序，实现将n个盘子从a移动到c *\/\r\n#[Keywords]void #hanoil(#[Keywords]int #n,#[Keywords]char #a,#[Keywords]char #b, #[Keywords]char #c)\r\n{\r\n   \t#[Keywords]if#(n==1) #[Tags]\/* 递归调用的出口，n=1 *\/\r\n\t\t#printf(#[Fields]\"  >>  Move Plate No.%d from Stick %c to Stick %c.\\n\"#,n,a,c);\r\n   \t#else\r\n   \t#{\r\n   \t\t#hanoil(n-1,a,c,b);  #[Tags]\/* 递归调用 *\/\r\n\t\t#printf(#[Fields]\"  >>  Move Plate No.%d from Stick %c to Stick %c.\\n\"#,n,a,c);\r\n   \t\t#hanoil(n-1,b,a,c);\r\n   \t#}\r\n#}\r\n#[Tags]\/****************************** 主程序******************************\/\r\n#[Keywords]void #main()\r\n{\r\n   \t#[Keywords]int #n;\r\n   \t#[Keywords]char #a=#[Fields]'A'#;\r\n   \t#[Keywords]char #b=#[Fields]'B'#;\r\n\t#[Keywords]char #c=#[Fields]'C'#;\r\n\t#clrscr();\r\n   \t#printf(#[Fields]\"This is a hanoil program.\\nPlease input number of the plates:\\n\"#);\r\n   \t#scanf(#[Fields]\"%d\"#,&n);\r\n   \t#[Keywords]if#(n<=0)\r\n   \t#{\r\n   \t\t#puts(#[Fields]\"n must no less than 1!\"#);\r\n   \t\t#exit(1);\r\n\t#}\r\n\t#puts(#[Fields]\"The steps of moving plates are:\"#);\r\n   \t#hanoil(n,a,b,c);\r\n   \t#puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n   \t#getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        123,
        "哈夫曼编码",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#define MAX  1000\r\n#define MAXSYMBS 30\r\n#define MAXNODE 59\r\ntypedef struct\r\n{\r\n  #[Keywords]int #weight;\r\n  #[Keywords]int #flag;\r\n  #[Keywords]int #parent;\r\n  #[Keywords]int #lchild;\r\n  #[Keywords]int #rchild;\r\n#}huffnode;\r\ntypedef struct\r\n{\r\n  #[Keywords]int #bits[MAXSYMBS];\r\n  #[Keywords]int #start;\r\n#}huffcode;\r\nmain()\r\n{\r\n\t#huffnode huff_node[MAXNODE];\r\n    #huffcode huff_code[MAXSYMBS],cd;\r\n    #[Keywords]int #i,j,m1,m2,x1,x2,n,c,p;\r\n\t#[Tags]\/* #[Keywords]char #symbs[MAXSYMBS],symb; *\/\r\n    #[Tags]\/*数组huff_node初始化*\/\r\n    #clrscr();\r\n\t#printf(#[Fields]\"please input the leaf num of tree:\\n\"#);\r\n    #scanf(#[Fields]\"%d\"#,&n);\r\n    #[Keywords]for#(i=0;i<2*n-1;i++)\r\n\t#{\r\n\t\t#huff_node[i].weight=0;\r\n        #huff_node[i].parent=0;\r\n\t\t#huff_node[i].flag=0;\r\n\t\t#huff_node[i].lchild=-1;\r\n        #huff_node[i].rchild=-1;\r\n\t#}\r\n\t#printf(#[Fields]\"please input the weight of every leaf\\n\"#);\r\n    #[Keywords]for#(i=0;i<n;i++)\r\n        #scanf(#[Fields]\"%d\"#,&huff_node[i].weight);\r\n\t#[Tags]\/*构造哈夫曼树*\/\r\n    #[Keywords]for#(i=0;i<n-1;i++)\r\n\t#{\r\n        #m1=m2=MAX;\r\n        #x1=x2=0;\r\n        #[Keywords]for#(j=0;j<n+i;j++)\r\n\t\t#{\r\n            #[Keywords]if #(huff_node[j].weight<m1&&huff_node[j].flag==0)\r\n\t\t\t#{\r\n\t\t\t    #m2=m1;\r\n                #x2=x1;\r\n                #m1=huff_node[j].weight;\r\n                #x1=j;\r\n\t\t\t#}\r\n            #[Keywords]else #[Keywords]if #(huff_node[j].weight<m2&&huff_node[j].flag==0)\r\n\t\t\t#{\r\n\t\t\t    #m2=huff_node[j].weight;\r\n                #x2=j;\r\n\t\t\t#}\r\n\t\t#}\r\n        #huff_node[x1].parent=n+i;    #[Tags]\/*将找出的两棵子树合并为一棵子树*\/\r\n        #huff_node[x2].parent=n+i;\r\n        #huff_node[x1].flag=1;\r\n        #huff_node[x2].flag=1;\r\n        #huff_node[n+i].weight=huff_node[x1].weight+huff_node[x2].weight;\r\n        #huff_node[n+i].lchild=x1;\r\n        #huff_node[n+i].rchild=x2;\r\n\t#}\r\n\t#[Tags]\/*求字符的哈夫曼编码*\/\r\n    #[Keywords]for#(i=0;i<n;i++)\r\n\t#{\r\n\t\t#cd.start=n;\r\n        #c=i;\r\n        #p=huff_node[c].parent;\r\n       #[Keywords] while#(p!=0)\r\n\t\t#{\r\n\t\t\t#[Keywords]if#(huff_node[p].lchild==c)\r\n            \r\n\t\t\t\t#cd.bits[cd.start]=0;\r\n           #[Keywords] else#\r\n\t\t\t\t#cd.bits[cd.start]=1;\r\n            #cd.start=cd.start-1;\r\n            #c=p;\r\n            #p=huff_node[p].parent;\r\n\t\t#}\r\n\t\t#cd.start++;\r\n        #[Keywords]for#(j=cd.start;j<=n;j++)\r\n\t\t\t#huff_code[i].bits[j]=cd.bits[j];\r\n        #huff_code[i].start=cd.start;\r\n\t#}\r\n    #[Tags]\/*输出字符的哈夫曼编码*\/\r\n    #puts(#[Fields]\"The Hafman code are:\"#);\r\n    #[Keywords]for#(i=0;i<n;i++)\r\n\t#{\r\n\t\t#[Keywords]for#(j=huff_code[i].start;j<=n;j++)\r\n\t\t\t#printf(#[Fields]\"%10d\"#,huff_code[i].bits[j]);\r\n        #printf(#[Fields]\"\\n\"#);\r\n\t#}\r\n\t#puts(#[Fields]\"Press any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        124,
        "图的深度优先遍利",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/*\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/#[Tags]\/*\/\r\n#[Tags]\/*                           图的深度优先遍历                  *\/\r\n#[Tags]\/*\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/*\/\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\nstruct node                       #[Tags]\/* 图顶点结构定义  *\/\r\n{\r\n   #[Keywords]int #vertex;        #[Tags]\/* 顶点数据信息   *\/\r\n   #struct node *nextnode;        #[Tags]\/* 指下一顶点的指标  *\/\r\n#};\r\ntypedef struct node *graph;       #[Tags]\/* 图形的结构新型态 *\/\r\nstruct node head[9];              #[Tags]\/* 图形顶点数组   *\/\r\n#[Keywords]int #visited[9];       #[Tags]\/* 遍历标记数组   *\/\r\n#[Tags]\/********************根据已有的信息建立邻接表********************\/\r\n#[Keywords]void #creategraph(#[Keywords]int #node[20][2],#[Keywords]int #num)#[Tags]\/*num指的是图的边数*\/\r\n{\r\n   #graph newnode;          #[Tags]\/*指向新节点的指针定义*\/\r\n   #graph ptr;\r\n   #[Keywords]int #from;    #[Tags]\/* 边的起点   *\/\r\n   #[Keywords]int #to;      #[Tags]\/* 边的终点   *\/\r\n   #[Keywords]int #i;\r\n   #[Keywords]for #( i = 0; i < num; i++ )    #[Tags]\/* 读取边线信息，插入邻接表*\/\r\n   #{\r\n      #from = node[i][0];         #[Tags]\/*   边线的起点  *\/\r\n      #to = node[i][1];           #[Tags]\/*   边线的终点   *\/\r\n\t  #[Tags]\/* 建立新顶点 *\/\r\n      #newnode = ( graph ) malloc(sizeof(struct node));\r\n      #newnode->vertex = to;        #[Tags]\/* 建立顶点内容  *\/\r\n      #newnode->nextnode = NULL;    #[Tags]\/* 设定指标初值  *\/\r\n      #ptr = &(head[from]);         #[Tags]\/* 顶点位置      *\/\r\n      #[Keywords]while #( ptr->nextnode != NULL ) #[Tags]\/* 遍历至链表尾   *\/\r\n         #ptr = ptr->nextnode;     #[Tags]\/* 下一个顶点  *\/\r\n      #ptr->nextnode = newnode;    #[Tags]\/* 插入节点    *\/\r\n   #}\r\n#}\r\n#[Tags]\/**********************  图的深度优先搜寻法********************\/\r\n#[Keywords]void #dfs(#[Keywords]int #current)\r\n{\r\n   #graph ptr;\r\n   #visited[current] = 1;          #[Tags]\/* 记录已遍历过  *\/\r\n   #printf(#[Fields]\"vertex[%d]\\n\"#,current);   #[Tags]\/* 输出遍历顶点值 *\/\r\n   #ptr = head[current].nextnode;  #[Tags]\/* 顶点位置  *\/\r\n   #[Keywords]while #( ptr != NULL )        #[Tags]\/* 遍历至链表尾 *\/\r\n   #{\r\n      #[Keywords]if #( visited[ptr->vertex] == 0 )  #[Tags]\/* 如过没遍历过 *\/\r\n         #dfs(ptr->vertex);       #[Tags]\/* 递回遍历呼叫 *\/\r\n      #ptr = ptr->nextnode;       #[Tags]\/* 下一个顶点   *\/\r\n   #}\r\n#}\r\n#[Tags]\/***************************** 主程序******************************\/\r\n#[Keywords]void #main()\r\n{\r\n   #graph ptr;\r\n   #[Keywords]int #node[20][2] = { {1, 2#}, {2, 1#},  #[Tags]\/* 边线数组     *\/\r\n                       #{1, 3#}, {3, 1#},\r\n                       #{1, 4#}, {4, 1#},\r\n                       #{2, 5#}, {5, 2#},\r\n                       #{2, 6#}, {6, 2#},\r\n                       #{3, 7#}, {7, 3#},\r\n                       #{4, 7#}, {4, 4#},\r\n                       #{5, 8#}, {8, 5#},\r\n                       #{6, 7#}, {7, 6#},\r\n                       #{7, 8#}, {8, 7#} #};\r\n   #[Keywords]int #i;\r\n   #clrscr();\r\n   #[Keywords]for #( i = 1; i <= 8; i++ )      #[Tags]\/*   顶点数组初始化  *\/\r\n   #{\r\n      #head[i].vertex = i;         #[Tags]\/*  设定顶点值 *\/\r\n      #head[i].nextnode = NULL;    #[Tags]\/*  指针为空 *\/\r\n      #visited[i] = 0;             #[Tags]\/* 设定遍历初始标志 *\/\r\n   #}\r\n   #creategraph(node,20);          #[Tags]\/* 建立邻接表 *\/\r\n   #printf(#[Fields]\"Content of the gragh#[Fields]'s ADlist is:\\n\"#);\r\n   #[Keywords]for #( i = 1; i <= 8; i++ )\r\n   #{\r\n      #printf(#[Fields]\"vertex%d ->\"#,head[i].vertex); #[Tags]\/* 顶点值    *\/\r\n      #ptr = head[i].nextnode;             #[Tags]\/* 顶点位置   *\/\r\n      #[Keywords]while #( ptr != NULL )    #[Tags]\/* 遍历至链表尾  *\/\r\n      #{\r\n         #printf(#[Fields]\" %d \"#,ptr->vertex);  #[Tags]\/* 印出顶点内容  *\/\r\n         #ptr = ptr->nextnode;         #[Tags]\/* 下一个顶点  *\/\r\n      #}\r\n      #printf(#[Fields]\"\\n\"#);         #[Tags]\/*   换行   *\/\r\n   #}\r\n   #printf(#[Fields]\"\\nThe end of the dfs are:\\n\"#);\r\n   #dfs(1);         #[Tags]\/* 打印输出遍历过程   *\/\r\n   #printf(#[Fields]\"\\n\"#);       #[Tags]\/* 换行 *\/\r\n   #puts(#[Fields]\" Press any key to quit...\"#);\r\n   #getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        125,
        "图的广度优先遍利",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/*\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/*\/\r\n#[Tags]\/*    图形的广度优先搜寻法                 *\/\r\n#[Tags]\/* \/* \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/*\/\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#define MAXQUEUE 10               #[Tags]\/* 队列的最大容量       *\/\r\nstruct node                       #[Tags]\/* 图的顶点结构定义     *\/\r\n{\r\n   #[Keywords]int #vertex;\r\n   #struct node *nextnode;\r\n#};\r\ntypedef struct node *graph;       #[Tags]\/*  图的结构指针        *\/\r\nstruct node head[9];              #[Tags]\/* 图的顶点数组         *\/\r\n#[Keywords]int #visited[9];                   #[Tags]\/* 遍历标记数组         *\/\r\n\r\n#[Keywords]int #queue[MAXQUEUE];              #[Tags]\/* 定义序列数组         *\/\r\n#[Keywords]int #front = -1;                   #[Tags]\/* 序列前端            *\/\r\n#[Keywords]int #rear = -1;                    #[Tags]\/* 序列后端            *\/\r\n#[Tags]\/***********************二维数组向邻接表的转化****************************\/\r\n#[Keywords]void #creategraph(#[Keywords]int #node[20][2],#[Keywords]int #num)\r\n{\r\n   #graph newnode;         #[Tags]\/*  顶点指针           *\/\r\n   #graph ptr;\r\n   #[Keywords]int #from;     #[Tags]\/* 边起点             *\/\r\n   #[Keywords]int #to;       #[Tags]\/* 边终点             *\/\r\n   #[Keywords]int #i;\r\n   #[Keywords]for #( i = 0; i < num; i++ )    #[Tags]\/* 第i条边的信息处理    *\/\r\n   #{\r\n      #from = node[i][0];  #[Tags]\/* 边的起点           *\/\r\n      #to = node[i][1];    #[Tags]\/* 边的终点             *\/\r\n\r\n\t  #\/*              建立新顶点                         *\/\r\n      #newnode = ( graph ) malloc(sizeof(struct node));\r\n      #newnode->vertex = to;       #[Tags]\/*    顶点内容         *\/\r\n      #newnode->nextnode = NULL;   #[Tags]\/* 设定指针初值         *\/\r\n      #ptr = &(head[from]);        #[Tags]\/* 顶点位置             *\/\r\n      #[Keywords]while #( ptr->nextnode != NULL ) #[Tags]\/* 遍历至链表尾     *\/\r\n         #ptr = ptr->nextnode;     #[Tags]\/* 下一个顶点       *\/\r\n      #ptr->nextnode = newnode;    #[Tags]\/* 插入第i个节点的链表尾部 *\/\r\n   #}\r\n#}\r\n#[Tags]\/************************ 数值入队列************************************\/\r\n#[Keywords]int #enqueue(#[Keywords]int #value)\r\n{\r\n   #[Keywords]if #( rear >= MAXQUEUE )   #[Tags]\/* 检查伫列是否全满     *\/\r\n      #[Keywords]return #-1;      #[Tags]\/* 无法存入             *\/\r\n   #rear++;              #[Tags]\/* 后端指标往前移       *\/\r\n   #queue[rear] = value;    #[Tags]\/* 存入伫列             *\/\r\n#}\r\n#[Tags]\/************************* 数值出队列*********************************\/\r\n#[Keywords]int #dequeue()\r\n{\r\n   #[Keywords]if #( front  == rear )  #[Tags]\/* 队列是否为空  *\/\r\n      #[Keywords]return #-1;    #[Tags]\/* 为空，无法取出  *\/\r\n   #front++;          #[Tags]\/* 前端指标往前移  *\/\r\n   #[Keywords]return #queue[front];     #[Tags]\/* 从队列中取出信息 *\/\r\n#}\r\n#[Tags]\/***********************  图形的广度优先遍历************************\/\r\n#[Keywords]void #bfs(#[Keywords]int #current)\r\n{\r\n   #graph ptr;\r\n   #\/* 处理第一个顶点 *\/\r\n   #enqueue(current);         #[Tags]\/* 将顶点存入队列       *\/\r\n   #visited[current] = 1;     #[Tags]\/* 已遍历过记录标志置疑1*\/\r\n   #printf(#[Fields]\" Vertex[%d]\\n\"#,current);   #[Tags]\/* 打印输出遍历顶点值 *\/\r\n   #[Keywords]while #( front != rear )    #[Tags]\/* 队列是否为空         *\/\r\n   #{\r\n      #current = dequeue();     #[Tags]\/* 将顶点从队列列取出   *\/\r\n      #ptr = head[current].nextnode;   #[Tags]\/* 顶点位置         *\/\r\n      #[Keywords]while #( ptr != NULL )     #[Tags]\/* 遍历至链表尾     *\/\r\n      #{\r\n         #[Keywords]if #( visited[ptr->vertex] == 0 ) #[Tags]\/*顶点没有遍历过*\/\r\n         #{\r\n            #enqueue(ptr->vertex);     #[Tags]\/* 奖定点放入队列   *\/\r\n            #visited[ptr->vertex] = 1; #[Tags]\/* 置遍历标记为1    *\/\r\n\r\n\t    #printf(#[Fields]\" Vertex[%d]\\n\"#,ptr->vertex);#[Tags]\/* 印出遍历顶点值 *\/\r\n         #}\r\n         #ptr = ptr->nextnode;     #[Tags]\/* 下一个顶点 *\/\r\n      #}\r\n   #}\r\n#}\r\n#[Tags]\/***********************  主程序  ************************************\/\r\n#[Tags]\/*********************************************************************\/\r\n#[Keywords]void #main()\r\n{\r\n   #graph ptr;\r\n   #[Keywords]int #node[20][2] = { {1, 2#}, {2, 1#},  #[Tags]\/* 边信息数组       *\/\r\n                       #{6, 3#}, {3, 6#},\r\n                       #{2, 4#}, {4, 2#},\r\n                       #{1, 5#}, {5, 1#},\r\n                       #{3, 7#}, {7, 3#},\r\n                       #{1, 7#}, {7, 1#},\r\n                       #{4, 8#}, {8, 4#},\r\n                       #{5, 8#}, {8, 5#},\r\n                       #{2, 8#}, {8, 2#},\r\n                       #{7, 8#}, {8, 7#} #};\r\n   #[Keywords]int #i;\r\n   #clrscr();\r\n   #puts(#[Fields]\"This is an example of Width Preferred Traverse of Gragh.\\n\"#);\r\n   #[Keywords]for #( i = 1; i <= 8; i++ )        #[Tags]\/*顶点结构数组初始化*\/\r\n   #{\r\n      #head[i].vertex = i;\r\n      #head[i].nextnode = NULL;\r\n      #visited[i] = 0;\r\n   #}\r\n   #creategraph(node,20);       #[Tags]\/* 图信息转换，邻接表的建立 *\/\r\n   #printf(#[Fields]\"The content of the graph#[Fields]'s allist is:\\n\"#);\r\n   #[Keywords]for #( i = 1; i <= 8; i++ )\r\n   #{\r\n      #printf(#[Fields]\" vertex%d =>\"#,head[i].vertex); #[Tags]\/* 顶点值 *\/\r\n      #ptr = head[i].nextnode;             #[Tags]\/* 顶点位置 *\/\r\n      #[Keywords]while #( ptr != NULL )       #[Tags]\/* 遍历至链表尾 *\/\r\n      #{\r\n         #printf(#[Fields]\" %d \"#,ptr->vertex);  #[Tags]\/* 打印输出顶点内容  *\/\r\n         #ptr = ptr->nextnode;      #[Tags]\/* 下一个顶点 *\/\r\n      #}\r\n      #printf(#[Fields]\"\\n\"#);      #[Tags]\/* 换行 *\/\r\n   #}\r\n   #printf(#[Fields]\"The contents of BFS are:\\n\"#);\r\n   #bfs(1);           #[Tags] \/* 打印输出遍历过程 *\/\r\n   #printf(#[Fields]\"\\n\"#);       #[Tags]\/* 换行  *\/\r\n   #puts(#[Fields]\" Press any key to quit...\"#);\r\n   #getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        126,
        "求解最优交通路径",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/*交通图最短路径程序*\/\r\n#include #[Fields]\"string.h\"# \r\n#include #[Fields]\"stdio.h\"# \r\ntypedef struct ArcCell \r\n{\r\n    #[Keywords]int #adj ;\r\n    #[Tags]\/*相邻接的城市序号*\/\r\n#}\r\nArcCell ;\r\n#[Tags]\/*定义边的类型*\/\r\ntypedef struct VertexType \r\n{\r\n    #[Keywords]int #number ;\r\n    #[Tags]\/*城市序号*\/\r\n    #char*city ;\r\n    #[Tags]\/*城市名称*\/\r\n#}\r\nVertexType ;\r\n#[Tags]\/*定义顶点的类型*\/\r\ntypedef struct \r\n{\r\n    #VertexType vex[25];\r\n    #[Tags]\/*图中的顶点，即为城市*\/\r\n    #ArcCell arcs[25][25];\r\n    #[Tags]\/*图中的边，即为城市间的距离*\/\r\n    #[Keywords]int #vexnum,arcnum ;\r\n    #[Tags]\/*顶点数，边数*\/\r\n#}\r\nMGraph ;\r\n#[Tags]\/*定义图的类型*\/\r\nMGraph G ;\r\n#[Tags]\/*把图定义为全局变量*\/\r\n#[Keywords]int #P[25][25];\r\n#[Keywords]long #[Keywords]int #D[25];\r\n#[Tags]\/*造图函数*\/\r\n#[Keywords]void #CreateUDN(v,a)#[Keywords]int #v,a ;\r\n{\r\n    #[Keywords]int #i,j ;\r\n    #G.vexnum=v ;\r\n    #G.arcnum=a ;\r\n    #[Keywords]for#(i=0;i<G.vexnum;++i)G.vex[i].number=i ;\r\n    #[Tags]\/*下边是城市名*\/\r\n    #G.vex[0].city=#[Fields]\"乌鲁木齐\"# ;\r\n    #G.vex[1].city=#[Fields]\"西宁\"# ;\r\n    #G.vex[2].city=#[Fields]\"兰州\"# ;\r\n    #G.vex[3].city=#[Fields]\"呼和浩特\"# ;\r\n    #G.vex[4].city=#[Fields]\"北京\"# ;\r\n    #G.vex[5].city=#[Fields]\"天津\"# ;\r\n    #G.vex[6].city=#[Fields]\"沈阳\"# ;\r\n    #G.vex[7].city=#[Fields]\"长春\"# ;\r\n    #G.vex[8].city=#[Fields]\"哈尔滨\"# ;\r\n    #G.vex[9].city=#[Fields]\"大连\"# ;\r\n    #G.vex[10].city=#[Fields]\"西安\"# ;\r\n    #G.vex[11].city=#[Fields]\"郑州\"# ;\r\n    #G.vex[12].city=#[Fields]\"徐州\"# ;\r\n    #G.vex[13].city=#[Fields]\"成都\"# ;\r\n    #G.vex[14].city=#[Fields]\"武汉\"# ;\r\n    #G.vex[15].city=#[Fields]\"上海\"# ;\r\n    #G.vex[16].city=#[Fields]\"昆明\"# ;\r\n    #G.vex[17].city=#[Fields]\"贵州\"# ;\r\n    #G.vex[18].city=#[Fields]\"株洲\"# ;\r\n    #G.vex[19].city=#[Fields]\"南昌\"# ;\r\n    #G.vex[20].city=#[Fields]\"福州\"# ;\r\n    #G.vex[21].city=#[Fields]\"柳州\"# ;\r\n    #G.vex[22].city=#[Fields]\"南宁\"# ;\r\n    #G.vex[23].city=#[Fields]\"广州\"# ;\r\n    #G.vex[24].city=#[Fields]\"深圳\"# ;\r\n    #[Tags]\/*这里把所有的边假定为20000，含义是城市间不可到达*\/\r\n    #[Keywords]for#(i=0;i<G.vexnum;++i)\r\n    #[Keywords]for#(j=0;j<G.vexnum;++j)\r\n    #G.arcs[i][j].adj=20000 ;\r\n    #[Tags]\/*下边是可直接到达的城市间的距离，由于两个城市间距离是互相的，\r\n    #[Tags]所以要对图中对称的边同时赋值。*\/\r\n    #G.arcs[0][2].adj=G.arcs[2][0].adj=1892 ;\r\n    #G.arcs[1][2].adj=G.arcs[2][1].adj=216 ;\r\n    #G.arcs[2][3].adj=G.arcs[3][2].adj=1145 ;\r\n    #G.arcs[2][10].adj=G.arcs[10][2].adj=676 ;\r\n    #G.arcs[3][4].adj=G.arcs[4][3].adj=668 ;\r\n    #G.arcs[4][5].adj=G.arcs[5][4].adj=137 ;\r\n    #G.arcs[5][6].adj=G.arcs[6][5].adj=704 ;\r\n    #G.arcs[6][7].adj=G.arcs[7][6].adj=305 ;\r\n    #G.arcs[7][8].adj=G.arcs[8][7].adj=242 ;\r\n    #G.arcs[6][9].adj=G.arcs[9][6].adj=397 ;\r\n    #G.arcs[4][11].adj=G.arcs[11][4].adj=695 ;\r\n    #G.arcs[5][12].adj=G.arcs[12][5].adj=674 ;\r\n    #G.arcs[10][13].adj=G.arcs[13][10].adj=842 ;\r\n    #G.arcs[11][14].adj=G.arcs[14][11].adj=534 ;\r\n    #G.arcs[12][15].adj=G.arcs[15][12].adj=651 ;\r\n    #G.arcs[13][16].adj=G.arcs[16][13].adj=1100 ;\r\n    #G.arcs[13][17].adj=G.arcs[17][13].adj=967 ;\r\n    #G.arcs[14][18].adj=G.arcs[18][14].adj=409 ;\r\n    #G.arcs[17][18].adj=G.arcs[18][17].adj=902 ;\r\n    #G.arcs[15][19].adj=G.arcs[19][15].adj=825 ;\r\n    #G.arcs[18][19].adj=G.arcs[19][18].adj=367 ;\r\n    #G.arcs[19][20].adj=G.arcs[20][19].adj=622 ;\r\n    #G.arcs[17][21].adj=G.arcs[21][17].adj=607 ;\r\n    #G.arcs[18][21].adj=G.arcs[21][18].adj=672 ;\r\n    #G.arcs[21][22].adj=G.arcs[22][21].adj=255 ;\r\n    #G.arcs[18][23].adj=G.arcs[23][18].adj=675 ;\r\n    #G.arcs[23][24].adj=G.arcs[24][23].adj=140 ;\r\n    #G.arcs[16][17].adj=G.arcs[17][16].adj=639 ;\r\n    #G.arcs[10][11].adj=G.arcs[11][10].adj=511 ;\r\n    #G.arcs[11][12].adj=G.arcs[12][11].adj=349 ;\r\n#}\r\n#[Tags]\/*说明函数*\/\r\n#[Keywords]void #narrate()\r\n{\r\n    #[Keywords]int #i,k=0 ;\r\n    #printf(#[Fields]\"\\n*****************欢迎使用最优交通路径程序!***************\\n\"#);\r\n    #printf(#[Fields]\"\\n城市列表如下:\\n\\n\"#);\r\n    #[Keywords]for#(i=0;i<25;i++)\r\n    #{\r\n        #printf(#[Fields]\"(%2d)%-10s\"#,i,G.vex[i].city);\r\n        #[Tags]\/*输出城市列表*\/\r\n        #k=k+1 ;\r\n        #[Keywords]if#(k%4==0)printf(#[Fields]\"\\n\"#);\r\n    #}\r\n#}\r\n#[Tags]\/*最短路径函数*\/\r\n#[Keywords]void #ShortestPath(num)#[Keywords]int #num ;\r\n{\r\n    #[Keywords]int #v,w,i,t ;\r\n    #[Keywords]int #final[25];\r\n    #[Keywords]int #min ;\r\n    #[Keywords]for#(v=0;v<25;++v)\r\n    #{\r\n        #final[v]=0 ;\r\n        #D[v]=G.arcs[num][v].adj ;\r\n        #[Keywords]for#(w=0;w<25;++w)P[v][w]=0 ;\r\n        #[Keywords]if#(D[v]<20000)\r\n        #{\r\n            #P[v][num]=1 ;\r\n            #P[v][v]=1 ;\r\n        #}\r\n    #}\r\n    #D[num]=0 ;\r\n    #final[num]=1 ;\r\n    #[Keywords]for#(i=0;i<25;++i)\r\n    #{\r\n        #min=20000 ;\r\n        #[Keywords]for#(w=0;w<25;++w)\r\n        #[Keywords]if#(!final[w])\r\n        #[Keywords]if#(D[w]<min)\r\n        #{\r\n            #v=w ;\r\n            #min=D[w];\r\n        #}\r\n        #final[v]=1 ;\r\n        #[Keywords]for#(w=0;w<25;++w)\r\n        #[Keywords]if#(!final[w]&&((min+G.arcs[v][w].adj)<D[w]))\r\n        #{\r\n            #D[w]=min+G.arcs[v][w].adj ;\r\n            #[Keywords]for#(t=0;t<25;t++)P[w][t]=P[v][t];\r\n            #P[w][w]=1 ;\r\n        #}\r\n    #}\r\n#}\r\n#[Tags]\/*输出函数*\/\r\n#[Keywords]void #output(city1,city2)#[Keywords]int #city1 ;\r\n#[Keywords]int #city2 ;\r\n{\r\n    #[Keywords]int #a,b,c,d,q=0 ;\r\n    #a=city2 ;\r\n    #[Keywords]if#(a!=city1)\r\n    #{\r\n        #printf(#[Fields]\"\\n从%s到%s的最短路径是\"#,G.vex[city1].city,G.vex[city2].city);\r\n        #printf(#[Fields]\"(最短距离为 %dkm.)\\n\\t\"#,D[a]);\r\n        #printf(#[Fields]\"%s\"#,G.vex[city1].city);\r\n        #d=city1 ;\r\n        #[Keywords]for#(c=0;c<25;++c)\r\n        #{\r\n            #gate :\r\n            #;\r\n            #[Tags]\/*标号，可以作为goto语句跳转的位置*\/\r\n            #P[a][city1]=0 ;\r\n            #[Keywords]for#(b=0;b<25;b++)\r\n            #{\r\n                #[Keywords]if#(G.arcs[d][b].adj<20000&&P[a][b])\r\n                #{\r\n                    #printf(#[Fields]\"-->%s\"#,G.vex[b].city);\r\n                    #q=q+1 ;\r\n                    #P[a][b]=0 ;\r\n                    #d=b ;\r\n                    #[Keywords]if#(q%8==0)printf(#[Fields]\"\\n\"#);\r\n                    #goto gate ;\r\n                #}\r\n            #}\r\n        #}\r\n    #}\r\n    \r\n#}\r\n#[Tags]\/*主函数*\/\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #v0,v1 ;\r\n    #CreateUDN(25,30);\r\n    \r\n    #narrate();\r\n    #printf(#[Fields]\"\\n\\n请选择起点城市（0～24）：\\n\"#);\r\n    #scanf(#[Fields]\"%d\"#,&v0);\r\n    #printf(#[Fields]\"请选择终点城市（0～24）：\\n\"#);\r\n    #scanf(#[Fields]\"%d\"#,&v1);\r\n    #ShortestPath(v0);\r\n    #[Tags]\/*计算两个城市之间的最短路径*\/\r\n    #output(v0,v1);\r\n    #[Tags]\/*输出结果*\/\r\n    #printf(#[Fields]\"\\n\"#);\r\n    #printf(#[Fields]\"\\n 请按任意键退出...\\n\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        127,
        "八皇后问题",
        "代码如下：\r\n[code=java]\r\n#include <math.h>\r\n#include <stdio.h>\r\n#define MAX 8 #[Tags]\/* 棋子数及棋盘大小MAXxMAX *\/\r\n#[Keywords]int #board[MAX];\r\n#[Tags]\/* 印出結果 *\/\r\n#[Keywords]void #show_result()\r\n{\r\n    #[Keywords]int #i;\r\n    #[Keywords]for#(i=0;i<MAX;i++)\r\n\t#printf(#[Fields]\"(%d,%d)\"#,i,board[i]);\r\n    #printf(#[Fields]\"\\n\"#);\r\n#}\r\n#[Tags]\/* 检查是否在同一直橫斜线上有其它棋子 *\/\r\n#[Keywords]int #check_cross(#[Keywords]int #n)\r\n{\r\n    #[Keywords]int #i;\r\n    #[Keywords]for#(i=0;i<n;i++){\r\n\t#[Keywords]if#(board[i]==board[n] || (n-i)==abs(board[i]-board[n]))#[Keywords]return #1;\r\n    #}\r\n    #[Keywords]return #0;\r\n#}\r\n#[Tags]\/* 放棋子到棋盘上 *\/\r\n#[Keywords]void #put_chess(#[Keywords]int #n)\r\n{\r\n    #[Keywords]int #i;\r\n    #[Keywords]for#(i=0;i<MAX;i++){\r\n\t#board[n]=i;\r\n\t#[Keywords]if#(!check_cross(n)){\r\n\t    #[Keywords]if#(n==MAX-1) show_result();#[Tags]\/* 找到其中一种放法了...印出結果 *\/\r\n\t    #[Keywords]else #put_chess(n+1);\r\n\t#}\r\n    #}\r\n#}\r\n#[Keywords]void #main()\r\n{\r\n\t#clrscr();\r\n\t#puts(#[Fields]\"The possible placements are:\"#);\r\n    #put_chess(0);\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n\t#getch();\r\n    #[Keywords]return#;#\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        128,
        "骑士巡游",
        "代码如下：\r\n[code=java]\r\n#[Comments]\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n#[Tags]\/*                       骑士巡游问题                                   *\/\r\n#[Comments]\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n#include<stdio.h>\r\n#[Keywords]int #f[11][11];\r\n#[Tags]\/*定义一个矩阵来模拟棋盘*\/\r\n#[Keywords]int #adjm[121][121];\r\n#[Tags]\/*标志矩阵，即对于上述棋盘，依次进行编号\r\n#[Tags]\t\t    #1--121(行优先）可以从一个棋盘格i跳到棋盘格j时，adjm[i][j]=1*\/\r\n#[Keywords]void #creatadjm(void);\r\n#[Tags]\/*创建标志矩阵函数声明*\/\r\n#[Keywords]void #mark(int,int,int,#[Keywords]int#);\r\n#[Tags]\/*将标志矩阵相应位置置1*\/\r\n#[Keywords]void #travel(int,#[Keywords]int#);\r\n#[Tags]\/*巡游函数声明*\/\r\n#[Keywords]int #n,m ;\r\n#[Tags]\/*定义矩阵大小及标志矩阵的大小*\/\r\n#[Tags]\/******************************主函数***********************************\/\r\n#[Keywords]int #main()\r\n{\r\n    #[Keywords]int #i,j,k,l ;\r\n    #printf(#[Fields]\"Please input size of the chessboard: \"#);\r\n    #\/*输入矩阵的大小值*\/\r\n    #scanf(#[Fields]\"%d\"#,&n);\r\n    #m=n*n ;\r\n    #creatadjm();\r\n    #\/*创建标志矩阵*\/\r\n    #puts(#[Fields]\"The sign matrix is:\"#);\r\n    #\/*打印输出标志矩阵*\/\r\n    #[Keywords]for#(i=1;i<=m;i++)\r\n    #{\r\n        #[Keywords]for#(j=1;j<=m;j++)\r\n        #printf(#[Fields]\"%2d\"#,adjm[i][j]);\r\n        #printf(#[Fields]\"\\n\"#);\r\n    #}\r\n    \r\n    #printf(#[Fields]\"Please input the knight#[Fields]'s position (i,j): \"#);\r\n    #\/*输入骑士的初始位置*\/\r\n    #scanf(#[Fields]\"%d %d\"#,&i,&j);\r\n    #l=(i-1)*n+j ;\r\n    #\/*骑士当前位置对应的标志矩阵的横坐标*\/\r\n    #\/*对骑士位置的判断*\/\r\n   #[Keywords] while#((i>0)||(j>0))\r\n    #{\r\n        #\/*棋盘矩阵初始化*\/\r\n        #[Keywords]for#(i=1;i<=n;i++)#[Keywords]for#(j=1;j<=n;j++)\r\n        #f[i][j]=0 ;\r\n        #k=0 ;\r\n        #\/*所跳步数计数*\/\r\n        #travel(l,k);\r\n        #\/*从i,j出发开始巡游*\/\r\n        #puts(#[Fields]\"The travel steps are:\"#);\r\n        #\/*巡游完成后输出巡游过程*\/\r\n        #[Keywords]for#(i=1;i<=n;i++)\r\n        #{\r\n            #[Keywords]for#(j=1;j<=n;j++)\r\n            #printf(#[Fields]\"%4d\"#,f[i][j]);\r\n            #printf(#[Fields]\"\\n\"#);\r\n        #}\r\n        \r\n        #printf(#[Fields]\"Please input the knight#[Fields]'s position (i,j): \"#);\r\n        #\/*为再次巡游输入起始位置*\/\r\n        #scanf(#[Fields]\"%d %d\"#,&i,&j);\r\n        #l=(i-1)*n+j ;\r\n    #}\r\n    #puts(#[Fields]\"\\n Press any key to quit... \"#);\r\n    #getch();\r\n    #[Keywords]return #0 ;\r\n#}\r\n#[Tags]\/*****************************创建标志矩阵子函数*************************\/\r\n#[Keywords]void #creatadjm()\r\n{\r\n    #[Keywords]int #i,j ;\r\n    #\/*巡游矩阵初始化*\/\r\n    #[Keywords]for#(i=1;i<=n;i++)#[Keywords]for#(j=1;j<=n;j++)\r\n    #f[i][j]=0 ;\r\n    #\/*标志矩阵初始化*\/\r\n    #[Keywords]for#(i=1;i<=m;i++)#[Keywords]for#(j=1;j<=m;j++)\r\n    #adjm[i][j]=0 ;\r\n    #[Keywords]for#(i=1;i<=n;i++)\r\n    #[Keywords]for#(j=1;j<=n;j++)\r\n    #\/*对所有符合条件的标志矩阵种元素置1*\/\r\n    #[Keywords]if#(f[i][j]==0)\r\n    #{\r\n        #f[i][j]=1 ;\r\n        #[Keywords]if#((i+2<=n)&&(j+1<=n))mark(i,j,i+2,j+1);\r\n        #[Keywords]if#((i+2<=n)&&(j-1>=1))mark(i,j,i+2,j-1);\r\n        #[Keywords]if#((i-2>=1)&&(j+1<=n))mark(i,j,i-2,j+1);\r\n        #[Keywords]if#((i-2>=1)&&(j-1>=1))mark(i,j,i-2,j-1);\r\n        #[Keywords]if#((j+2<=n)&&(i+1<=n))mark(i,j,i+1,j+2);\r\n        #[Keywords]if#((j+2<=n)&&(i-1>=1))mark(i,j,i-1,j+2);\r\n        #[Keywords]if#((j-2>=1)&&(i+1<=n))mark(i,j,i+1,j-2);\r\n        #[Keywords]if#((j-2>=1)&&(i-1>=1))mark(i,j,i-1,j-2);\r\n    #}\r\n    #[Keywords]return #;\r\n#}\r\n#[Tags]\/*********************************巡游子函数*******************************\/\r\n#[Keywords]void #travel(#[Keywords]int #p,#[Keywords]int #r)\r\n{\r\n    #[Keywords]int #i,j,q ;\r\n    #[Keywords]for#(i=1;i<=n;i++)\r\n    #[Keywords]for#(j=1;j<=n;j++)\r\n    #[Keywords]if#(f[i][j]>r)f[i][j]=0 ;\r\n    #\/*棋盘矩阵的置〉r时，置0*\/\r\n    #r=r+1 ;\r\n    #\/*跳步计数加1*\/\r\n    #i=((p-1)\/n)+1 ;\r\n    #\/*还原棋盘矩阵的横坐标*\/\r\n    #j=((p-1)%n)+1 ;\r\n    #\/*还原棋盘矩阵的纵坐标*\/\r\n    #f[i][j]=r ;\r\n    #\/*将f[i][j]做为第r跳步的目的地*\/\r\n    #\/*从所有可能的情况出发，开始进行试探式巡游*\/\r\n    #[Keywords]for#(q=1;q<=m;q++)\r\n    #{\r\n        #i=((q-1)\/n)+1 ;\r\n        #j=((q-1)%n)+1 ;\r\n        #[Keywords]if#((adjm[p][q]==1)&&(f[i][j]==0))\r\n        #travel(q,r);\r\n        #\/*递归调用自身*\/\r\n    #}\r\n    #[Keywords]return #;\r\n#}\r\n#[Tags]\/*************************赋值子函数***************************************\/\r\n#[Keywords]void #mark(#[Keywords]int #i1,#[Keywords]int #j1,#[Keywords]int #i2,#[Keywords]int #j2)\r\n{\r\n    #adjm[(i1-1)*n+j1][(i2-1)*n+j2]=1 ;\r\n    #adjm[(i2-1)*n+j2][(i1-1)*n+j1]=1 ;\r\n    #[Keywords]return #;\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        129,
        "用栈设置密码",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#include<string.h>\r\n#include<conio.h>\r\n#include<stdlib.h>\r\n#define STACK_INIT_SIZE 10\r\n#define OK 1\r\n#define TRUE 1\r\n#define FALSE  0\r\n#define ERROR 0\r\n#[Keywords]char #PASSWORD[10]=#[Fields]\"123456\"# ;\r\n\/*密码，全局变量*\/\r\ntypedef #[Keywords]char #SElemType ;\r\n\/*定义栈类型*\/\r\ntypedef struct STACK \r\n{\r\n    #SElemType*base ;\r\n    #SElemType*top ;\r\n    #[Keywords]int #stacksize ;\r\n    #[Keywords]int #length ;\r\n#}\r\nSqStack,*Stack ;\r\ntypedef #[Keywords]int #Status ;\r\n\/*初始化栈*\/\r\n#[Keywords]void #InitStack(Stack*S)\r\n{\r\n    #[Tags]*S=(SqStack#[Tags]*)malloc(sizeof(SqStack));\r\n    #(*S)->base=(SElemType*)malloc(STACK_INIT_SIZE*sizeof(SElemType));\r\n    #[Keywords]if#(!(*S)->base)exit(-1);\r\n    #(*S)->top=(*S)->base ;\r\n    #(*S)->stacksize=STACK_INIT_SIZE ;\r\n    #(*S)->length=0 ;\r\n#}\r\n\/* 销毁栈*\/\r\nStatus DestroyStack(Stack*S)\r\n{\r\n    #free((*S)->base);\r\n    #free((*S));\r\n    #[Keywords]return #OK ;\r\n#}\r\n\/*把栈置为空*\/\r\n#[Keywords]void #ClearStack(Stack*S)\r\n{\r\n    #(*S)->top=(*S)->base ;\r\n    #(*S)->length=0 ;\r\n#}\r\n\/*判断栈空否*\/\r\nStatus StackEmpty(SqStack S)\r\n{\r\n    #[Keywords]if#(S.top==S.base)#[Keywords]return #TRUE ;\r\n    #[Keywords]else #\r\n    #[Keywords]return #FALSE ;\r\n#}\r\n\/*把数据压入栈*\/\r\n#[Keywords]void #Push(Stack*S,SElemType e)\r\n{\r\n    #[Keywords]if#((*S)->top-(*S)->base>=(*S)->stacksize)\r\n    #{\r\n        #(*S)->base=(SElemType*)realloc((*S)->base,\r\n        #((*S)->stacksize+2)*sizeof(SElemType));\r\n        #[Keywords]if#(!(*S)->base)exit(-1);\r\n        #(*S)->top=(*S)->base+(*S)->stacksize ;\r\n        #(*S)->stacksize+=2 ;\r\n    #}\r\n    #[Tags]*((#[Tags]*S)->top++)=e ;\r\n    #++(*S)->length ;\r\n#}\r\n\/*删除栈顶元素*\/\r\nStatus Pop(Stack*S)\r\n{\r\n    #[Keywords]if#((*S)->top==(*S)->base)#[Keywords]return #ERROR ;\r\n    #(*S)->top--;\r\n    #--(*S)->length ;\r\n    #[Keywords]return #OK ;\r\n#}\r\n\/*返回栈顶元素*\/\r\nStatus GetTop(Stack S,SElemType*e)\r\n{\r\n    #[Keywords]if#(S->top==S->base)#[Keywords]return #ERROR ;\r\n    #[Tags]*e=#[Tags]*(S->top-1);\r\n    #S->top--;\r\n#}\r\n\/*将栈中的元素按反序付给 a *\/\r\n#[Keywords]void #Change(SqStack S,char*a)\r\n{\r\n    #[Keywords]int #n=S.length-1 ;\r\n   #[Keywords] while#(!StackEmpty(S))\r\n    #GetTop(&S,&a[n--]);\r\n#}\r\n#[Keywords]void #Control(Stack*s)\r\n{\r\n    #[Keywords]int #i=0,k,j=0 ;\r\n    #SElemType ch,*a ;\r\n    #k=strlen(PASSWORD);\r\n    #printf(#[Fields]\"input password,you have three chances：\\n\"#,k);\r\n    #[Keywords]for#(;;)\r\n    #{\r\n        #[Keywords]if#(i>=3)\r\n        #{\r\n            #i++;\r\n            #clrscr();\r\n            #gotoxy(1,1);\r\n            #\/*定位黑屏光标位置*\/\r\n            #[Keywords]break# ;\r\n        #}\r\n        #[Keywords]else #[Keywords]if#(i>0&&i<3)\r\n        #{\r\n            #gotoxy(5,2);\r\n            #[Keywords]for#(j=1;j<=(*s)->length;j++)printf(#[Fields]\" \"#);\r\n            #gotoxy(5,2);\r\n            #ClearStack(s);\r\n        #}\r\n        #\/* 密码输入，可退格 *\/\r\n        #[Keywords]for#(;;)\r\n        #{\r\n            #ch=getch();\r\n            #\/* 退格 的ASCII 是8 *\/\r\n            #\/* 判断是否为回车，不是则把它付给下面*\/\r\n            #[Keywords]if#(ch!=13)\r\n            #{\r\n                #[Keywords]if#(ch==8)\r\n                #{\r\n                    #Pop(s);\r\n                    #gotoxy(4+j,2);\r\n                    #printf(#[Fields]\" \"#);\r\n                    #gotoxy(4+j,2);\r\n                #}\r\n                #[Keywords]else #\r\n                #{\r\n                    #printf(#[Fields]\"*\"#);\r\n                    #Push(s,ch);\r\n                #}\r\n                #j=(*s)->length ;\r\n            #}\r\n            #[Keywords]else #[Keywords]break# ;\r\n        #}\r\n        #i++;\r\n        #[Keywords]if#(k!=j)#[Keywords]continue# ;\r\n        #[Keywords]else #\r\n        #{\r\n            #a=(SElemType*)malloc((*s)->length*sizeof(SElemType));\r\n            #Change(**s,a);\r\n            #[Keywords]for#(j=1;j<=(*s)->length;)\r\n            #{\r\n                #[Keywords]if#(a[j-1]==PASSWORD[j-1])j++;\r\n                #[Keywords]else #\r\n                #{\r\n                    #j=(*s)->length+2 ;\r\n                    #[Keywords]break# ;\r\n                #}\r\n            #}\r\n            #[Keywords]if#(j==(*s)->length+2)#[Keywords]continue# ;\r\n            #[Keywords]else #[Keywords]break# ;\r\n        #}\r\n    #}\r\n    #[Keywords]if#(i==4)printf(#[Fields]\"\\n password wrong!\"#);\r\n    #[Keywords]else #printf(#[Fields]\"\\n password right!\\n\"#);\r\n    #free(a);\r\n#}\r\nmain()\r\n{\r\n    #Stack s ;\r\n    #clrscr();\r\n    #InitStack(&s);\r\n    #Control(&s);\r\n    #getch();\r\n    #DestroyStack(&s);\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        130,
        "魔王语言翻译",
        "代码如下：\r\n[code=java]\r\n#include   <stdio.h> \r\n#include   <string.h> \r\n#include   <stdlib.h> \r\n#include   <conio.h> \r\n#[Tags]\/*定义全局变量*\/ \r\n#define   TRUE   1 \r\n#define   FALSE   0 \r\n#define   OK   1 \r\n#define   ERROR   0 \r\n#define   NULL   0 \r\n#define   OVERFLOW   -2 \r\n#define   MAXSIZE   100 \r\n#define   stack_init_size   100 \r\n#define   stackincrement   10 \r\ntypedef   #[Keywords]char #  selemType; \r\ntypedef   #[Keywords]char #  qelemType; \r\ntypedef   #[Keywords]char #  elemType; \r\ntypedef   #[Keywords]int #  status; \r\n#[Keywords]char #  e;     \r\n#[Keywords]char #  demon[MAXSIZE];\r\n#[Tags]\/* 类型及其基本操作*\/   \r\ntypedef   struct   \r\n{   \r\n\t#selemType   *base;\r\n\t#selemType   *top;\r\n\t#[Keywords]int #  stacksize; \r\n#}sqstack;     \r\nstatus   initstack   (sqstack   *s) \r\n{     \r\n\t#s->base=(selemType   *)malloc(stack_init_size*sizeof(selemType));\r\n\t#[Keywords]if#(!s->base)   exit   (OVERFLOW); \r\n\t#s->top=s->base;\r\n\t#s->stacksize=stack_init_size;\r\n\t#[Keywords]return #  OK; \r\n#}#[Tags]\/*创建栈*\/ \r\nstatus   push   (sqstack   *s,selemType   e) \r\n{ \r\n\t#[Keywords]if#(s->top-s->base>=s->stacksize) \r\n\t#{\r\n\t\t#s->base=(elemType*)   realloc(s->base,(s->stacksize+stackincrement)*sizeof(elemType))\r\n\t\t#[Keywords]if#(!s->base)   exit(OVERFLOW); \r\n\t\t#s->top=s->base+s->stacksize;\r\n\t\t#s->stacksize+=stackincrement;\r\n\t#} \r\n\t#[Tags]*(s->top++)=e; \r\n\t#[Keywords]return #  OK; \r\n#}#[Tags]\/*入栈*\/ \r\nstatus   pop(sqstack   *s,selemType   *e) \r\n{     \r\n\t#[Keywords]if#(s->top==s->base)   #[Keywords]return #  ERROR; \r\n\t#[Tags]*e=#[Tags]*(--(s->top)); \r\n\t#[Keywords]return #  OK; \r\n#}#[Tags]\/*出栈*\/ \r\n#[Tags]\/*队列类型及其基本操作*\/ \r\ntypedef   struct   qnode \r\n{ \r\n\t#qelemType   data;\r\n\t#struct   qnode   *next;\r\n#}qnode,*queueptr; \r\ntypedef   struct \r\n{ \r\n\t#queueptr   front;\r\n\t#queueptr   rear;\r\n#}linkqueue; \r\nstatus   initqueue(linkqueue   *q) \r\n{ \r\n\t#q->front=q->rear=(queueptr)malloc(sizeof(qnode));\r\n\t#[Keywords]if#(!q->front)   exit(OVERFLOW); \r\n\t#q->front->next=NULL;\r\n\t#[Keywords]return #  OK; \r\n#}#[Tags]\/*创建队列*\/ \r\nstatus   enqueue(linkqueue   *q,qelemType   e) \r\n{ \r\n\t#queueptr   p;\r\n\t#p=(queueptr)malloc(sizeof(qnode));\r\n\t#[Keywords]if#(!p)   exit(OVERFLOW); \r\n\t#p->data=e;\r\n\t#p->next=NULL;\r\n\t#q->rear->next=p;\r\n\t#q->rear=p;\r\n\t#[Keywords]return #  OK; \r\n#}#[Tags]\/*入队*\/ \r\nstatus   dequeue(linkqueue   *q,qelemType   *e) \r\n{ \r\n\t#queueptr   p;\r\n\t#[Keywords]if#(q->front==q->rear)   #[Keywords]return #  ERROR; \r\n\t#p=q->front->next;\r\n\t#[Tags]*e=p->data; \r\n\t#q->front->next=p->next;\r\n\t#[Keywords]if#(q->rear==p) \r\n\t#{\r\n\t\t#q->rear=q->front;\r\n\t#} \r\n\t#free(p);\r\n\t#[Keywords]return #  OK;\r\n#}#[Tags]\/*出队*\/ \r\n #\/*括号内元素入栈处理函数*\/\r\n#[Keywords]void #  tempstack(sqstack   *temps) \r\n{ \r\n\t#[Keywords]int #  i=0; \r\n\t#[Keywords]char #  t; \r\n\t#[Keywords]char #  c;\r\n\t#c=demon[i];\r\n\t#[Keywords]for#(i=0;c!=#[Fields]'#'#;i++)\/*遍历数组*\/\r\n\t#{\r\n\t\t#c=demon[i];\r\n\t\t#[Keywords]if#(c==#[Fields]'('#)\/*遇到开括号*\/\r\n\t\t#{\r\n\t\t\t#t=demon[i+1];\/*取括号中的首字母*\/\r\n\t\t\t#push(temps,t);\/*入栈*\/\r\n\t\t\t#i++;\/*指向首字母*\/\r\n\t\t\t#[Keywords]do #\r\n\t\t\t#{\r\n\t\t\t\t#i++;\r\n\t\t\t\t#c=demon[i];\r\n\t\t\t\t#push(temps,c)#[Tags]\/*第一次循环将次字母入栈*\/;\r\n\t\t\t\t#push(temps,t);#[Tags]\/*再将首字母进栈*\/\r\n\t\t\t#}#[Keywords]while#(c!=#[Fields]')'#);#[Tags]\/*直到括号中元素全部进栈*\/ \r\n\t\t\t#pop(temps,&t);#[Tags]\/*将多余进栈的首字母t出栈*\/\r\n\t\t\t#pop(temps,&t);   #[Tags]\/*将多余进栈的#[Fields]')'#出栈*\/\r\n\t\t#} \r\n\t#} \r\n#}#[Tags]\/*临时栈*\/ \r\n#[Tags]\/*特殊入队函数*\/\r\n#[Keywords]void #  spenqueue(linkqueue   *q,#[Keywords]char #  key)     \r\n{     \r\n\t#[Keywords]int #  j=0;\r\n\t#[Keywords]char #  a[5]; \r\n\t#switch(key)   \/*判断大写字母对应的字符串*\/\r\n\t#{\r\n\t#case#[Fields]'A'#:strcpy(a,#[Fields]\"ase\"#);#[Keywords]break#;\r\n\t#case#[Fields]'B'#:strcpy(a,#[Fields]\"tAdA\"#);#[Keywords]break#;\r\n\t#case#[Fields]'C'#:strcpy(a,#[Fields]\"abc\"#);#[Keywords]break#;\r\n\t#case#[Fields]'D'#:strcpy(a,#[Fields]\"def\"#);#[Keywords]break#;\r\n\t#case#[Fields]'E'#:strcpy(a,#[Fields]\"ghi\"#);#[Keywords]break#;\r\n\t#case#[Fields]'F'#:strcpy(a,#[Fields]\"klm\"#);#[Keywords]break#;\r\n\t#case#[Fields]'H'#:strcpy(a,#[Fields]\"mop\"#);#[Keywords]break#;\r\n\t#[Keywords]default#:strcpy(a,#[Fields]\"???\"#);   \/*不能翻译的魔王语言以#[Fields]\"???\"#输出*\/ \r\n\t#} \r\n\t#[Keywords]while#(a[j]!=#[Fields]'\\0'#)   \/*如果数组还有字母*\/ \r\n\t#{\r\n\t\t#enqueue(q,a[j]);\/*进队*\/\r\n\t\t#j++;\r\n\t#} \r\n#}\/*特殊入队*\/ \r\n\/*排序入队处理函数*\/ \r\nstatus   sort(sqstack   *s,linkqueue   *q) \r\n{     \r\n\t#qnode   b;\r\n\t#[Keywords]int #  flag=0;\/*大写字母监视哨置零*\/ \r\n\t#[Keywords]int #  i; \r\n\t#[Keywords]for#(i=0;demon[   i]!=#[Fields]'#'#;i++)\/*遍历数组*\/ \r\n\t#{\r\n\t\t#b.data=demon[   i];\r\n\t\t#[Keywords]if#(   (#[Fields]'a'#<=b.data&&b.data<=#[Fields]'z'#)||b.data==#[Fields]'?'#)   \r\n\t\t#[Tags]\/*如果是小写字母或者#[Fields]'?'#　则直接进栈*\/     \r\n\t\t#{\r\n\t\t\t#enqueue(q,b.data);\r\n\t\t#} \r\n\t\t#[Keywords]else #\r\n\t\t#{\r\n\t\t\t#[Keywords]if#(#[Fields]'A'#<=b.data&&b.data<=#[Fields]'Z'#)   #[Tags]\/*如果是大写字母,则调用特殊进栈函数,*\/     \r\n\t\t\t#{\r\n\t\t\t\t#spenqueue(q,b.data);\r\n\t\t\t\t#flag=1;   #[Tags]\/*发现大写字母监视哨置1*\/\r\n\t\t\t#} \r\n\t\t\t#[Keywords]else #\r\n\t\t\t#{\r\n\t\t\t\t#[Keywords]if#(b.data==#[Fields]'('#)\/*如果是括号*\/ \r\n\t\t\t\t#{\r\n\t\t\t\t\t#[Keywords]do #\r\n\t\t\t\t\t#{\r\n\t\t\t\t\t\t#pop(s,&e);\r\n\t\t\t\t\t\t#enqueue(q,e);\r\n\t\t\t\t\t#}#[Keywords]while#(!(s->top==s->base));   #[Tags]\/*只要栈不为空,则出栈进队*\/     \r\n\t\t\t\t\t#[Keywords]while #  (b.data!=#[Fields]')'#)   \r\n\t\t\t\t\t#[Tags]\/*只要还指向括号内元素,就继续往后移,保证原括号内的元素不再进栈*\/ \r\n\t\t\t\t\t#{\r\n\t\t\t\t\t\t#i++;\r\n\t\t\t\t\t\t#b.data=demon[i];\r\n\t\t\t\t\t#} \r\n\t\t\t\t#} \r\n\t\t\t#} \r\n\t\t#} \r\n\t#}\r\n\t#[Keywords]return #  flag; \r\n#}#[Tags]\/*排序*\/\r\n#[Tags]\/*主函数*\/\r\nstatus   main() \r\n{ \r\n\t#sqstack   s1;\r\n\t#linkqueue   q1;\r\n\t#[Keywords]int #  k=0; \r\n\t#[Keywords]int #  flag=1; \r\n\t#clrscr();\r\n\t#printf(#[Fields]\"Please   Input   the   Demon#[Fields]'s   Words:\\n\"#);\r\n\t#printf(#[Fields]\"!:   Less   Than   30   Letters:   )\\n\"#);\r\n\t#printf(#[Fields]\"!:   End   with   #[Fields]'#'#:   )\\n\\t\"#);\r\n\t#scanf(#[Fields]\"%s\"#,demon);\r\n\t#printf(#[Fields]\"\\n***************************************\"#);\r\n\t#initstack(&s1);   #[Tags]\/*创建栈*\/\r\n\t#initqueue(&q1);   #[Tags]\/*创建队*\/\r\n\t#tempstack(&s1);   #[Tags]\/*调用函数*\/\r\n\t#[Keywords]while #  (flag==1)   #[Tags]\/*如果有大写字母*\/ \r\n\t#{\r\n\t\t#k=0;\r\n\t\t#flag=sort(&s1,&q1);\r\n\t\t#[Keywords]while#(q1.front!=q1.rear)   #[Tags]\/*重写demon[i   ]*\/ \r\n\t\t#{\r\n\t\t\t#dequeue(&q1,&e);\r\n\t\t\t#demon[k]=e;\r\n\t\t\t#k++;\r\n\t\t#}\r\n\t\t#demon[k]=#[Fields]'#'#;\r\n\t#}\r\n\t#demon[k]=#[Fields]'\\0'#;\r\n\t#printf(#[Fields]\"\\n***************************************\"#);\r\n\t#printf(#[Fields]\"\\nThe   Human   Words:\\n\\t%s\"#,demon);\r\n\t#printf(#[Fields]\"\\n***************************************\"#);\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        131,
        "火车车厢重排",
        "代码如下：\r\n[code=java]\r\n#include #[Fields]\"stdafx.h\r\n#include #[Fields]\"stdio.h\r\n#include #[Fields]\"iostream.h\r\n#include #[Fields]\"stdlib.h\r\n#include #[Fields]\"malloc.h\r\n#include #[Fields]\"string.h\r\n#define StackSize 100 \r\n#[Comments]\/\/假定预分配的栈空间最多为100个元素\r\n#define MaxLength  100\r\n#[Comments]\/\/ 最大的字符串长度\r\ntypedef #[Keywords]int #DataType ;\r\n#[Comments]\/\/假定栈元素的数据类型为整数\r\ntypedef struct \r\n{\r\n    #DataType data[StackSize];\r\n    #[Keywords]int #top ;\r\n#}\r\nSeqStack ;\r\n#[Comments]\/\/ 置栈空\r\n#[Keywords]void #Initial(SeqStack*S)\r\n{\r\n    #[Comments]\/\/将顺序栈置空\r\n    #S->top=-1 ;\r\n#}\r\n#[Comments]\/\/判栈空\r\n#[Keywords]int #IsEmpty(SeqStack*S)\r\n{\r\n    #[Keywords]return #S->top==-1 ;\r\n#}\r\n#[Comments]\/\/判栈满\r\n#[Keywords]int #IsFull(SeqStack*S)\r\n{\r\n    #[Keywords]return #S->top==StackSize-1 ;\r\n#}\r\n#[Comments]\/\/进栈\r\n#[Keywords]void #Push(SeqStack*S,DataType x)\r\n{\r\n    #[Keywords]if#(IsFull(S))\r\n    #{\r\n        #printf(#[Fields]\"栈上溢\"#);\r\n        #[Comments]\/\/上溢,退出运行\r\n        #exit(1);\r\n    #}\r\n    #S->data[++S->top]=x ;\r\n    #[Comments]\/\/栈顶指针加1后将x入栈\r\n#}\r\n#[Comments]\/\/出栈\r\nDataType Pop(SeqStack*S)\r\n{\r\n    #[Keywords]if#(IsEmpty(S))\r\n    #{\r\n        #printf(#[Fields]\"栈为空\"#);\r\n        #[Comments]\/\/下溢,退出运行\r\n        #return-1 ;\r\n    #}\r\n    #[Keywords]return #S->data[S->top--];\r\n    #[Comments]\/\/栈顶元素返回后将栈顶指针减1\r\n#}\r\n#[Comments]\/\/ 取栈顶元素\r\nDataType Top(SeqStack*S)\r\n{\r\n    #[Keywords]if#(IsEmpty(S))\r\n    #{\r\n        #printf(#[Fields]\"栈为空\"#);\r\n        #[Comments]\/\/下溢,退出运行\r\n        #exit(1);\r\n    #}\r\n    #[Keywords]return #S->data[S->top];\r\n#}\r\n#[Keywords]int #Hold(#[Keywords]int #c,int*minH,int*minS,SeqStack H[],#[Keywords]int #k,#[Keywords]int #n)\r\n{\r\n    #[Comments]\/\/ 在一个缓冲铁轨中放入车厢c\r\n    #[Comments]\/\/ 如果没有可用的缓冲铁轨，则返回0\r\n    #[Comments]\/\/ 如果空间不足，则引发异常N o M e m\r\n    #[Comments]\/\/ 否则返回1\r\n    #[Comments]\/\/ 为车厢c寻找最优的缓冲铁轨\r\n    #[Comments]\/\/ 初始化\r\n    #[Keywords]int #BestTrack=0,i ;\r\n    #[Comments]\/\/ 目前最优的铁轨\r\n    #[Keywords]int #BestTop=n+1 ;\r\n    #[Comments]\/\/ 最优铁轨上的头辆车厢\r\n    #[Keywords]int #x ;\r\n    #[Comments]\/\/ 车厢索引\r\n    #[Comments]\/\/扫描缓冲铁轨\r\n    #[Keywords]for#(i=1;i<=k;i++)\r\n    #[Keywords]if#(IsEmpty(&H[i]))\r\n    #{\r\n        #[Comments]\/\/ 铁轨i 不空\r\n        #x=Top(&H[i]);\r\n        #[Keywords]if#(c<x&&x<BestTop)\r\n        #{\r\n            #[Comments]\/\/铁轨i 顶部的车厢编号最小\r\n            #BestTop=x ;\r\n            #BestTrack=i ;\r\n        #}\r\n    #}\r\n    #[Comments]\/\/ 铁轨i 为空\r\n    #[Keywords]else #[Keywords]if#(!BestTrack)\r\n    #BestTrack=i ;\r\n    #[Keywords]if#(!BestTrack)\r\n    #[Keywords]return #0 ;\r\n    #[Comments]\/\/没有可用的铁轨\r\n    #[Comments]\/\/把车厢c 送入缓冲铁轨\r\n    #Push(&H[BestTrack],c);\r\n    #printf(#[Fields]\"Move car %d  from input to holding track %d\\n\"#,c,BestTrack);\r\n    #[Comments]\/\/必要时修改minH 和minS\r\n    #[Keywords]if#(c<*minH)\r\n    #{\r\n        #[Tags]*minH=c ;\r\n        #[Tags]*minS=BestTrack ;\r\n    #}\r\n    #[Keywords]return #1 ;\r\n#}\r\n#[Keywords]void #Output(int*minH,int*minS,SeqStack H[],#[Keywords]int #k,#[Keywords]int #n)\r\n{\r\n    #[Comments]\/\/把车厢从缓冲铁轨送至出轨处，同时修改m i n S和m i n H\r\n    #[Keywords]int #c,i ;\r\n    #[Comments]\/\/ 车厢索引\r\n    #[Comments]\/\/ 从堆栈m i n S中删除编号最小的车厢minH\r\n    #c=Pop(&H[*minS]);\r\n    #printf(#[Fields]\"Move car %d from holding track %d to output\\n\"#,*minH,*minS);\r\n    #[Comments]\/\/ 通过检查所有的栈顶，搜索新的m i n H和m i n S\r\n    #[Tags]*minH=n+2 ;\r\n    #[Keywords]for#(i=1;i<=k;i++)\r\n    #[Keywords]if#(!IsEmpty(&H[i])&&(c=Top(&H[i]))<*minH)\r\n    #{\r\n        #[Tags]*minH=c ;\r\n        #[Tags]*minS=i ;\r\n    #}\r\n#}\r\n#[Keywords]int #Railroad(#[Keywords]int #p[],#[Keywords]int #n,#[Keywords]int #k)\r\n{\r\n    #[Comments]\/\/ k个缓冲铁轨，车厢初始排序为p [1:n]\r\n    #[Comments]\/\/ 如果重排成功，返回1，否则返回0\r\n    #[Comments]\/\/ 如果内存不足，则引发异常NoMem 。\r\n    #[Comments]\/\/创建与缓冲铁轨对应的堆栈\r\n    #SeqStack*H ;\r\n    #[Keywords]int #NowOut=1 ;\r\n    #[Comments]\/\/下一次要输出的车厢\r\n    #[Keywords]int #minH=n+1 ;\r\n    #[Comments]\/\/缓冲铁轨中编号最小的车厢\r\n    #[Keywords]int #minS,i ;\r\n    #[Comments]\/\/minH号车厢对应的缓冲铁轨\r\n    #H=(SeqStack*)calloc((k+1),sizeof(SeqStack)*(k+1));\r\n    #[Comments]\/\/车厢重排\r\n    #[Keywords]for#(i=1;i<=n;i++)\r\n    #[Keywords]if#(p[i]==NowOut)\r\n    #{\r\n        #[Comments]\/\/ 直接输出t\r\n        #printf(#[Fields]\"移动车厢%d从出口到入口\"#,p[i]);\r\n        #NowOut++;\r\n        #[Comments]\/\/从缓冲铁轨中输出\r\n       #[Keywords] while#(minH==NowOut)\r\n        #{\r\n            #Output(&minH,&minS,H,k,n);\r\n            #NowOut++;\r\n        #}\r\n    #}\r\n    #[Keywords]else #\r\n    #{\r\n        #[Comments]\/\/ 将p[i] 送入某个缓冲铁轨\r\n        #[Keywords]if#(!Hold(p[i],&minH,&minS,H,k,n))\r\n        #[Keywords]return #0 ;\r\n    #}\r\n    #[Keywords]return #1 ;\r\n#}\r\n#[Keywords]void #main(void)\r\n{\r\n    #[Keywords]int #p[8]=\r\n    #{\r\n        #2,4,1,6,5,3,8,7\r\n    #}\r\n    #;\r\n    #Railroad(p,8,4);\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        132,
        "队列实例",
        "代码如下：\r\n[code=java]\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#define MAX 100\r\n#[Keywords]char #*p[MAX], *qretrieve(void);\r\n#[Keywords]int #spos = 0;\r\n#[Keywords]int #rpos = 0;\r\n#[Keywords]void #enter(void), qstore(#[Keywords]char #*q), review(void), delete_ap(void);\r\n#[Keywords]int #main(void)\r\n{\r\n\t#[Keywords]char #s[80];\r\n\t#register #[Keywords]int #t;\r\n\t#[Keywords]for#(t=0; t < MAX; ++t) p[t] = NULL; \/* init array to #[Keywords]null#s *\/\r\n\t#[Keywords]for#(;;) {\r\n\t\t#printf(#[Fields]\"Enter, List, Remove, Quit: \"#);\r\n\t\t#gets(s);\r\n\t\t#[Tags]*s = toupper(#[Tags]*s);\r\n\t\t\r\n\t\t#switch(*s) {\r\n\t\t#[Keywords]case ##[Fields]'E'#:\r\n\t\t\t#enter();\r\n\t\t\t#[Keywords]break#;\r\n\t\t#[Keywords]case ##[Fields]'L'#:\r\n\t\t\t#review();\r\n\t\t\t#[Keywords]break#;\r\n\t\t#[Keywords]case ##[Fields]'R'#:\r\n\t\t\t#delete_ap();\r\n\t\t\t#[Keywords]break#;\r\n\t\t#[Keywords]case ##[Fields]'Q'#:\r\n\t\t\t#exit(0);\r\n\t\t#}\r\n\t#}\r\n\t#[Keywords]return #0;\r\n#}\r\n#[Tags]\/* Enter appointments in queue. *\/\r\n#[Keywords]void #enter(void)\r\n{\r\n\t#[Keywords]char #s[256], *p;\r\n\t#[Keywords]do #{\r\n\t\t#printf(#[Fields]\"Enter appointment %d: \"#, spos+1);\r\n\t\t#gets(s);\r\n\t\t#[Keywords]if#(*s==0) #[Keywords]break#; \/* no en#[Keywords]try #*\/\r\n\t\t#p = (#[Keywords]char #*) malloc(strlen(s)+1);\r\n\t\t#[Keywords]if#(!p) {\r\n\t\t\t#printf(#[Fields]\"Out of memory.\\n\"#);\r\n\t\t\t#[Keywords]return#;#\r\n\t\t#}\r\n\t\t#strcpy(p, s);\r\n\t\t#[Keywords]if#(*s) qstore(p);\r\n\t#}#[Keywords] while#(*s);\r\n#}\r\n#[Tags]\/* See what#[Fields]'s in the queue. *\/\r\n#[Keywords]void #review(void)\r\n{\r\n\t#register #[Keywords]int #t;\r\n\t#[Keywords]for#(t=rpos; t < spos; ++t)\r\n\t\t#printf(#[Fields]\"%d. %s\\n\"#, t+1, p[t]);\r\n#}\r\n#[Tags]\/* Delete an appointment from the queue. *\/\r\n#[Keywords]void #delete_ap(void)\r\n{\r\n\t#[Keywords]char #*p;\r\n\t#[Keywords]if#((p=qretrieve())==NULL) #[Keywords]return#;#\r\n\t#printf(#[Fields]\"%s\\n\"#, p);\r\n#}\r\n#[Tags]\/* Store an appointment. *\/\r\n#[Keywords]void #qstore(#[Keywords]char #*q)\r\n{\r\n\t#[Keywords]if#(spos==MAX) {\r\n\t\t#printf(#[Fields]\"List Full\\n\"#);\r\n\t\t#[Keywords]return#;#\r\n\t#}\r\n\t#p[spos] = q;\r\n\t#spos++;\r\n#}\r\n#[Tags]\/* Retrieve an appointment. *\/\r\n#[Keywords]char #*qretrieve(void)\r\n{\r\n\t#[Keywords]if#(rpos==spos) {\r\n\t\t#printf(#[Fields]\"No more appointments.\\n\"#);\r\n\t\t#[Keywords]return #NULL;\r\n\t#}\r\n\t#rpos++;\r\n\t#[Keywords]return #p[rpos-1];\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        133,
        "K阶斐波那契序列",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#define  enoughsize 100  \r\n#[Comments]\/\/最大队列长度\r\ntypedef struct \r\n{\r\n    #int*base ;\r\n    #[Comments]\/\/初始化的动态分配存储空间\r\n    #[Keywords]int #front ;\r\n    #[Comments]\/\/头指针,若队列不空,指向队列头元素\r\n    #[Keywords]int #rear ;\r\n    #[Comments]\/\/尾指针,若队列不空,指向队列尾元素的下一个位置\r\n#}\r\nSqQueue ;\r\n#[Keywords]int #AddSum(#[Keywords]int #n,int*q)\r\n{\r\n    #[Keywords]int #sum=0 ;\r\n    #[Keywords]int #i ;\r\n    #[Keywords]for#(i=0;i<n;i++)sum+=q[i];\r\n    #[Keywords]return #sum ;\r\n#}\r\n#[Keywords]void #main()\r\n{\r\n    #SqQueue Q ;\r\n    #[Keywords]int #k,max,i,n,*store ;\r\n    #printf(#[Fields]\"请输入斐波那奇的阶数:\"#);\r\n    #scanf(#[Fields]\"%d\"#,&k);\r\n    #printf(#[Fields]\"请输入序列中允许的最大数:\"#);\r\n    #scanf(#[Fields]\"%d\"#,&max);\r\n    #Q.base=(int*)malloc(k*sizeof(#[Keywords]int#));\r\n    #store=(int*)malloc(enoughsize*sizeof(#[Keywords]int#));\r\n    #[Keywords]if#((!Q.base)||(!store))\r\n    #{\r\n        #printf(#[Fields]\"Error!\"#);\r\n        #[Keywords]return #;\r\n    #}\r\n    #[Keywords]for#(i=0;i<k;i++)\r\n    #{\r\n        #store[i]=0 ;\r\n        #Q.base[i]=0 ;\r\n    #}\r\n    #store[k-1]=1 ;\r\n    #Q.base[k-1]=1 ;\r\n    #[Comments]\/\/初始化fib序列\r\n    #store[k]=AddSum(k,Q.base);\r\n    #Q.front=0 ;\r\n    #Q.rear=k-1 ;\r\n    #n=k ;\r\n   #[Keywords] while#(store[n]<=max)\r\n    #{\r\n        #Q.rear=(Q.rear+1)%k ;\r\n        #Q.base[Q.rear]=store[n];\r\n        #n++;\r\n        #store[n]=AddSum(k,Q.base);\r\n    #}\r\n    #printf(#[Fields]\"The first %d%s%d%c%s\"#,n,#[Fields]\" numbers are less than \"#,max,#[Fields]'.'#,#[Fields]\"\\n\"#);\r\n    #printf(#[Fields]\"The numbers are:\\n\"#);\r\n    #[Keywords]for#(i=0;i<n;i++)printf(#[Fields]\"%d%c\"#,store[i],#[Fields]' '#);\r\n    #printf(#[Fields]\"\\n\"#);\r\n#}\r\n[\/code]",
        8,
        119,
        1
      ],
      [
        200,
        "数据结构篇",
        "",
        9,
        120,
        1
      ],
      [
        201,
        "绘制余弦曲线和直线的迭加",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#include<math.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]double #y ;\r\n    #[Keywords]int #x,m,n,yy ;\r\n    #clrscr();\r\n    #puts(#[Fields]\"========This program shows the curve of cos(x) and a line.========\"#);\r\n    #puts(#[Fields]\"        ******* f(x)=cos(x)    +++++++ g(x)=45*(y-1)+31\"#);\r\n    #\/*对于第一个y坐标进行计算并在一行中打印图形*\/\r\n    #[Keywords]for#(yy=0;yy<=20;yy++)\r\n    #{\r\n        #y=0.1*yy ;\r\n        #\/*y：屏幕行方向坐标*\/\r\n        #m=acos(1-y)*10 ;\r\n        #\/*m: cos(x)曲线上y点对应的屏幕列坐标*\/\r\n        #n=45*(y-1)+31 ;\r\n        #\/*n: 直线上y点对应的列坐标*\/\r\n        #\/*x: 屏幕列方向坐标*\/\r\n        #[Keywords]for#(x=0;x<=62;x++)#[Keywords]if#(x==m&&x==n)printf(#[Fields]\"+\"#);\r\n        #\/*直线与cos(x)相交时打印#[Fields]\"+\"#*\/\r\n        #[Keywords]else #[Keywords]if#(x==n)printf(#[Fields]\"+\"#);\r\n        #\/*打印不相交时的直线图形*\/\r\n        #[Keywords]else #[Keywords]if#(x==m||x==62-m)printf(#[Fields]\"*\"#);\r\n        #\/*打印不相交时的cos(x)图形*\/\r\n        #[Keywords]else #printf(#[Fields]\" \"#);\r\n        #\/*其它情况打印空格*\/\r\n        #printf(#[Fields]\"\\n\"#);\r\n    #}\r\n    #puts(#[Fields]\" Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        120,
        1
      ],
      [
        202,
        "计算高次方数的尾数",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #i,x,y,last=1 ;\r\n    #[Tags]\/*变量last保存求X的Y次方过程中的部分乘积的后三位*\/\r\n    #clrscr();\r\n    #puts(#[Fields]\"**********************************************************\"#);\r\n    #puts(#[Fields]\"*  This is a program to calculate the last 3 digits of   *\"#);\r\n    #puts(#[Fields]\"*              high order value, e.g., 13^15.            *\"#);\r\n    #puts(#[Fields]\"**********************************************************\"#);\r\n    #printf(#[Fields]\"\\n >> Input X and Y(X^Y): \"#);\r\n    #scanf(#[Fields]\"%d%d\"#,&x,&y);\r\n    #[Tags]\/*X自乘Y次*\/\r\n    #[Keywords]for#(i=1;i<=y;i++)last=last*x%1000 ;\r\n    #[Tags]\/*将last乘X后对1000取模，即求积的后三位*\/\r\n    #printf(#[Fields]\"\\n >> The last 3 digits of %d^%d is: %d\\n\"#,x,y,last%1000);\r\n    #[Tags]\/*打印结果*\/\r\n    #puts(#[Fields]\"\\n >> Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        120,
        1
      ],
      [
        203,
        "打鱼还是晒网",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\nstruct date{\r\n    #[Keywords]int #year;\r\n    #[Keywords]int #month;\r\n    #[Keywords]int #day;\r\n#};\r\n#[Keywords]int #days(struct date day);\r\n#[Keywords]void #main()\r\n{\r\n    #struct date today,term;\r\n    #[Keywords]int #yearday,year,day;\r\n\t#puts(#[Fields]\"◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇\"#);\r\n\t#puts(#[Fields]\"◇              打鱼还是晒网                        ◇\"#);\r\n\t#puts(#[Fields]\"◇    中国有句俗语叫【三天打鱼两天晒网】。          ◇\"#);\r\n\t#puts(#[Fields]\"◇某人20岁从1990年1月1日起开始【三天打鱼两天晒网】，◇\"#);\r\n\t#puts(#[Fields]\"◇问这个人在以后的某一天中是【打鱼】还是【晒网】？  ◇\"#);\r\n\t#puts(#[Fields]\"◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇\\n\"#);\r\n\t#[Keywords]while#(1)\r\n\t#{\r\n\t\t#printf(#[Fields]\" >> 请输入年\/月\/日【输入1990 1 1 退出】：\"#);\r\n\t\t#scanf(#[Fields]\"%d%d%d\"#,&today.year,&today.month,&today.day);  \/*输入日期*\/\r\n\t\t#[Keywords]if#(today.year<1990)\r\n\t\t#{\r\n\t\t\t#[Keywords]if#(today.year<1970)\r\n\t\t\t\t#puts(#[Fields]\" >> 对不起，那一年那还没出生呢！按任意键继续...\"#);\r\n\t\t\t#else\r\n\t\t\t\t#puts(#[Fields]\" >> 对不起，那一年他还没开始打鱼呢！按任意键继续...\"#);\r\n\t\t\t#getch();\r\n\t\t\t#[Keywords]continue#;\r\n\t\t#}\r\n\t\t#[Keywords]if#(today.year==1990&&today.month==1&&today.day==1)\r\n\t\t\t#[Keywords]break#;\r\n\t\t#term.month=12;      #[Tags]\/*设置变量的初始值：月*\/\r\n\t\t#term.day=31;        #[Tags]\/*设置变量的初始值：日*\/\r\n\t\t#[Keywords]for#(yearday=0,year=1990;year<today.year;year++)\r\n\t\t#{\r\n\t\t\t#term.year=year;\r\n\t\t\t#yearday+=days(term);   #[Tags]\/*计算从1990年至指定年的前一年共有多少天*\/\r\n\t\t#}\r\n\t\t#yearday+=days(today);      #[Tags]\/*加上指定年中到指定日期的天数*\/\r\n\t\t#day=yearday%5;             #[Tags]\/*求余数*\/\r\n\t\t#[Keywords]if#(day>0&&day<4) printf(#[Fields]\" >> %d年%d月%d日，他正在打鱼。\\n\"#,today.year,today.month,today.day);   #[Tags]\/*打印结果*\/\r\n\t\t#[Keywords]else #printf(#[Fields]\" >> %d年%d月%d日，他正在晒网。\\n\"#,today.year,today.month,today.day);\r\n\t\t\r\n\t#}\r\n\t#puts(#[Fields]\"\\n >>      请按任意键退出...\"#);\r\n\t#getch();\r\n#}\r\n#[Keywords]int #days(struct date day)\r\n{\r\n    #[Keywords]static #[Keywords]int #day_tab[2][13]=\r\n            #{{0,31,28,31,30,31,30,31,31,30,31,30,31,#},     #[Tags]\/*平均每月的天数*\/\r\n             #{0,31,29,31,30,31,30,31,31,30,31,30,31,#},\r\n    #};\r\n    #[Keywords]int #i,lp;\r\n    #lp=day.year%4==0&&day.year%100!=0||day.year%400==0;\r\n      #\/*判定year为闰年还是平年，lp=0为平年，非0为闰年*\/\r\n    #[Keywords]for#(i=1;i<day.month;i++)       #[Tags]\/*计算本年中自1月1日起的天数*\/\r\n        #day.day+=day_tab[lp][i];\r\n    #[Keywords]return #day.day;\r\n#}\r\n[\/code]",
        8,
        120,
        1
      ],
      [
        204,
        "怎样存钱以获取最大利息",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#include<math.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #i8,i5,i3,i2,i1,n8,n5,n3,n2,n1 ;\r\n    #[Keywords]float #max=0,term ;\r\n    #clrscr();\r\n    #[Tags]\/*穷举所有可能的存款方式*\/\r\n    #[Keywords]for#(i8=0;i8<3;i8++)#[Keywords]for#(i5=0;i5<=(20-8*i8)\/5;i5++)\r\n    #[Keywords]for#(i3=0;i3<=(20-8*i8-5*i5)\/3;i3++)\r\n    #[Keywords]for#(i2=0;i2<=(20-8*i8-5*i5-3*i3)\/2;i2++)\r\n    #{\r\n        #i1=20-8*i8-5*i5-3*i3-2*i2 ;\r\n        #term=2000.0*pow((double)(1+0.0063*12),(double)i1)\r\n        #[Tags]*pow((double)(1+2#[Tags]*0.0063#[Tags]*12),(double)i2)\r\n        #[Tags]*pow((double)(1+3#[Tags]*0.0069#[Tags]*12),(double)i3)\r\n        #[Tags]*pow((double)(1+5#[Tags]*0.0075#[Tags]*12),(double)i5)\r\n        #[Tags]*pow((double)(1+8#[Tags]*0.0084#[Tags]*12),(double)i8);\r\n        #[Tags]\/*计算到期时的本利合计*\/\r\n        #[Keywords]if#(term>max)\r\n        #{\r\n            #max=term ;\r\n            #n1=i1 ;\r\n            #n2=i2 ;\r\n            #n3=i3 ;\r\n            #n5=i5 ;\r\n            #n8=i8 ;\r\n        #}\r\n    #}\r\n    #printf(#[Fields]\"For maxinum profit,he should so save his money in a bank:\\n\"#);\r\n    #printf(#[Fields]\"   made fixed deposit #[Keywords]for #8 year: %d times\\n\"#,n8);\r\n    #printf(#[Fields]\"   made fixed deposit #[Keywords]for #5 year: %d times\\n\"#,n5);\r\n    #printf(#[Fields]\"   made fixed deposit #[Keywords]for #3 year: %d times\\n\"#,n3);\r\n    #printf(#[Fields]\"   made fixed deposit #[Keywords]for #2 year: %d times\\n\"#,n2);\r\n    #printf(#[Fields]\"   made fixed deposit #[Keywords]for #1 year: %d times\\n\"#,n1);\r\n    #printf(#[Fields]\"                            Toal: %.2f\\n\"#,max);\r\n    #[Tags]\/*输出存款方式*\/\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        120,
        1
      ],
      [
        205,
        "阿姆斯特朗数",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#define MAX 255\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #i,j,t,k,m,a[MAX];\r\n    #[Keywords]long #n ;\r\n    #clrscr();\r\n    #puts(#[Fields]\"     This program will find the Armstrong number.\\n\"#);\r\n    #printf(#[Fields]\" >> Please input the range you want to find (2~n):\\n >> \"#);\r\n    #scanf(#[Fields]\"%ld\"#,&n);\r\n    #m=n ;\r\n    #j=10 ;\r\n   #[Keywords] while#(m>=10)\r\n    #{\r\n        #m=m\/10 ;\r\n        #j*=10 ;\r\n    #}\r\n    #printf(#[Fields]\" >> There are follwing Armstrong number smaller than %d:\\n\"#,n);\r\n    #[Tags]\/*穷举要判定的数i的取值范围2~1000*\/\r\n    #[Keywords]for#(i=2;i<n;i++)\r\n    #{\r\n        #[Tags]\/*截取整数i的各位(从高向低位)*\/\r\n        #[Keywords]for#(t=0,k=10;k<=j;t++)\r\n        #{\r\n            #a[t]=(i%k)\/(k\/10);\r\n            #[Tags]\/*分别赋于a[0]~a[2#}*\/\r\n            #k*=10 ;\r\n        #}\r\n        #[Keywords]for#(m=0,t--;t>=0;t--)\r\n        #m+=a[t]*a[t]*a[t];\r\n        #[Keywords]if#(m==i)\r\n        #[Tags]\/*判断i是否为阿姆斯特朗数*\/\r\n        #printf(#[Fields]\"%5d\"#,i);\r\n        #[Tags]\/*若满足条件，则输出*\/\r\n        \r\n    #}\r\n    #printf(#[Fields]\"\\n Press any key to quit...\\n\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        120,
        1
      ],
      [
        206,
        "亲密数",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #a,i,b,n,m ;\r\n    #clrscr();\r\n    #printf(#[Fields]\"================================================================\\n\"#);\r\n    #printf(#[Fields]\"     This is a program to find friendly numbers pair.\\n\"#);\r\n    #printf(#[Fields]\"   Which means the sum of integer A#[Fields]'s all factors (except A)\\n\"#);\r\n    #printf(#[Fields]\"    equals to the sum of integer B#[Fields]'s all factors (except B).\\n\"#);\r\n    #printf(#[Fields]\"     < e.g. sum of integer 6#[Fields]'s all factors are:1+2+3=6 >\\n\"#);\r\n    #printf(#[Fields]\"================================================================\\n\"#);\r\n    #printf(#[Fields]\"\\n Please input the scale you want to find n: \"#);\r\n    #scanf(#[Fields]\"%d\"#,&n);\r\n    #printf(#[Fields]\"\\n There are following friendly--numbers pair smaller than %d:\\n\"#,n);\r\n    #[Tags]\/*穷举1000以内的全部整数*\/\r\n    #[Keywords]for#(a=1;a<n;a++)\r\n    #{\r\n        #[Tags]\/*计算数a的各因子，各因子之和存放于b*\/\r\n        #[Keywords]for#(b=0,i=1;i<=a\/2;i++)#[Keywords]if#(!(a%i))b+=i ;\r\n        #[Tags]\/*计算b的各因子，各因子之和存于m*\/\r\n        #[Keywords]for#(m=0,i=1;i<=b\/2;i++)\r\n        #[Keywords]if#(!(b%i))m+=i ;\r\n        #[Keywords]if#(m==a&&a<b)\r\n        #printf(#[Fields]\"%4d..%4d    \"#,a,b);\r\n        #[Tags]\/*若n=a，则a和b是一对亲密数，输出*\/\r\n    #}\r\n    #puts(#[Fields]\"\\n\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        120,
        1
      ],
      [
        207,
        "自守数",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]long #mul,number,k,ll,kk,n ;\r\n    #clrscr();\r\n    #puts(#[Fields]\"============================================================\"#);\r\n    #puts(#[Fields]\"||    This program will find the automorphic numbers.     ||\"#);\r\n    #puts(#[Fields]\"|| The defination of a automorphic number is: the mantissa||\"#);\r\n    #puts(#[Fields]\"||     of a natural number#[Fields]'s square equals to itself.     ||\"#);\r\n    #puts(#[Fields]\"||       e.g., 25^2=625, 76^2=5776, 9376^2=87909376.      ||\"#);\r\n    #puts(#[Fields]\"============================================================\"#);\r\n    #printf(#[Fields]\"\\n >> Please input the scale n you want to find : \"#);\r\n    #scanf(#[Fields]\"%ld\"#,&n);\r\n    #printf(#[Fields]\"\\n >> The automorphic numbers small than %ld are:\\n\\n\"#,n);\r\n    #[Keywords]for#(number=0;number<n;number++)\r\n    #{\r\n        #[Keywords]for#(mul=number,k=1;(mul\/=10)>0;k*=10);\r\n        #[Tags]\/*由number的位数确定截取数字进行乘法时的系数k*\/\r\n        #kk=k*10 ;\r\n        #[Tags]\/*kk为截取部分积时的系数*\/\r\n        #mul=0 ;\r\n        #[Tags]\/*积的最后n位*\/\r\n        #ll=10 ;\r\n        #[Tags]\/*ll为截取乘数相应位时的系数*\/\r\n       #[Keywords] while#(k>0)\r\n        #{\r\n            #mul=(mul+(number%(k*10))*(number%ll-number%(ll\/10)))%kk ;\r\n            #[Tags]\/*(部分积+截取被乘数的后N位*截取乘数的第M位)，%kk再截取部分积*\/\r\n            #k\/=10 ;\r\n            #[Tags]\/*k为截取被乘数时的系数*\/\r\n            #ll*=10 ;\r\n        #}\r\n        #[Tags]\/*判断若为自守数则输出*\/\r\n        #[Keywords]if#(number==mul)printf(#[Fields]\"%ld   \"#,number);\r\n    #}\r\n    #puts(#[Fields]\"\\n\\n >> Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        120,
        1
      ],
      [
        208,
        "具有abcd=(ab+cd)2性质的数",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #n,a,b ;\r\n    #clrscr();\r\n    #puts(#[Fields]\"==========================================================\"#);\r\n    #puts(#[Fields]\"||  This program will find the four figures which have  ||\"#);\r\n    #puts(#[Fields]\"||     the characteristic as follows: abcd=(ab+cd)^2.   ||\"#);\r\n    #puts(#[Fields]\"||            e.g., 3025=(30+25)*(30+25).               ||\"#);\r\n    #puts(#[Fields]\"==========================================================\"#);\r\n    #printf(#[Fields]\"\\n >> There are following numbers with satisfied condition:\\n\\n\"#);\r\n    #[Tags]\/*四位数N的取值范围1000~9999*\/\r\n    #[Keywords]for#(n=1000;n<10000;n++)\r\n    #{\r\n        #a=n\/100 ;\r\n        #[Tags]\/*截取N的前两位数存于a*\/\r\n        #b=n%100 ;\r\n        #[Tags]\/*截取N的后两位存于b*\/\r\n        #[Tags]\/*判断N是否为符合题目所规定的性质的四位数*\/\r\n        #[Keywords]if#((a+b)*(a+b)==n)printf(#[Fields]\" %d  \"#,n);\r\n    #}\r\n    #puts(#[Fields]\"\\n\\n >> Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        8,
        120,
        1
      ],
      [
        209,
        "验证歌德巴赫猜想",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#include<math.h>\r\n#[Keywords]int #fflag(#[Keywords]int #n);\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #i,j,n ;\r\n    #[Keywords]long #max ;\r\n    #clrscr();\r\n    #puts(#[Fields]\"============================================================\"#);\r\n    #puts(#[Fields]\"||       This program will verify the Goldbach Guess.     ||\"#);\r\n    #puts(#[Fields]\"|| That is any positive even number can be broken up into ||\"#);\r\n    #puts(#[Fields]\"||               the sum of two prime numbers.            ||\"#);\r\n    #puts(#[Fields]\"||       e.g., 4=2+2, 6=3+3, 8=3+5, 10=3+7, 12=5+7,...    ||\"#);\r\n    #puts(#[Fields]\"============================================================\"#);\r\n    #printf(#[Fields]\"\\n >> Please input the scale n you want to verify : \"#);\r\n    #scanf(#[Fields]\"%ld\"#,&max);\r\n    #printf(#[Fields]\"\\n >> Now the program starts to verify the even number\\n\"#);\r\n    #printf(#[Fields]\" >> less than %ld equals to sum of two prime numbers.\\n\\n\"#,max);\r\n    #[Keywords]for#(i=4,j=0;i<=max;i+=2)\r\n    #{\r\n        #[Tags]\/*将偶数i分解为两个整数*\/\r\n        #[Tags]\/*分别判断两个整数是否均为素数*\/\r\n        #[Keywords]for#(n=2;n<i;n++)#[Keywords]if#(fflag(n))#[Keywords]if#(fflag(i-n))\r\n        #{\r\n            #printf(#[Fields]\"%4d=%2d+%2d \"#,i,n,i-n);\r\n            #[Tags]\/*若均是素数则输出*\/\r\n            #j++;\r\n            #[Keywords]if#(j==5)\r\n            #{\r\n                #printf(#[Fields]\"\\n\"#);\r\n                #j=0 ;\r\n            #}\r\n            #[Keywords]break# ;\r\n        #}\r\n        #[Keywords]if#(n==i)printf(#[Fields]\"error %d\\n\"#,i);\r\n    #}\r\n    #puts(#[Fields]\"\\n >> Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n#[Tags]\/*判断是否为素数*\/\r\n#[Keywords]int #fflag(#[Keywords]int #i)\r\n{\r\n    #[Keywords]int #j ;\r\n    #[Keywords]if#(i<=1)#[Keywords]return #0 ;\r\n    #[Keywords]if#(i==2)#[Keywords]return #1 ;\r\n    #[Keywords]if#(!(i%2))#[Keywords]return #0 ;\r\n    #\/*#[Keywords]if #no,#[Keywords]return #0*\/\r\n    #[Keywords]for#(j=3;j<=(#[Keywords]int#)(sqrt((double)i)+1);j+=2)\r\n    #[Keywords]if#(!(i%j))#[Keywords]return #0 ;\r\n    #[Keywords]return #1 ;\r\n    #\/*#[Keywords]if #yes,#[Keywords]return #1*\/\r\n#}\r\n[\/code]",
        8,
        120,
        1
      ],
      [
        210,
        "素数幻方",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#include<math.h>\r\n#[Keywords]int #number[210][5];\r\n#[Tags]\/*存放可逆素数及素数分解后的各位数字*\/\r\n#[Keywords]int #select[110];\r\n#[Tags]\/*可以放在矩阵第一行和最后一行的素数的下标*\/\r\n#[Keywords]int #array[4][5];\r\n#[Tags]\/*4X4的矩阵，每行0号元素存可逆素数对应的数组下标*\/\r\n#[Keywords]int #count ;\r\n#[Tags]\/*可逆素数的数目*\/\r\n#[Keywords]int #selecount ;\r\n#[Tags]\/*可以放在矩阵第一行和最后一行的可逆素数的数目*\/\r\n#[Keywords]int #larray[2][200];\r\n#[Tags]\/*存放素数前二、三位数的临时数组所对应的数量计数器*\/\r\n#[Keywords]int #lcount[2];\r\n#[Keywords]int #num(#[Keywords]int #number);\r\n#[Keywords]int #ok(#[Keywords]int #number);\r\n#[Keywords]void #process(#[Keywords]int #i);\r\n#[Keywords]void #copy_num(#[Keywords]int #i);\r\n#[Keywords]int #comp_num(#[Keywords]int #n);\r\n#[Keywords]int #find1(#[Keywords]int #i);\r\n#[Keywords]int #find2(void);\r\n#[Keywords]int #find0(#[Keywords]int #num);\r\n#[Keywords]void #p_array(void);\r\nFILE*fp ;\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #i,k,flag,cc=0,i1,i4 ;\r\n    #clrscr();\r\n    #[Keywords]if#((fp=fopen(#[Fields]\"Exa70data.dat\"#,#[Fields]\"w+\"#))==NULL)\r\n    #{\r\n        #printf(#[Fields]\"\\n Can#[Fields]'t create file Exa70data.dat !\\n\"#);\r\n        #exit(0);\r\n    #}\r\n    #printf(#[Fields]\"there are magic squares with invertable primes as follw:\\n\"#);\r\n    #\/*求满足条件的可逆素数*\/\r\n    #[Keywords]for#(i=1001;i<9999;i+=2)\r\n    #{\r\n        #k=i\/1000 ;\r\n        #\/*若可逆素数的第一位不是偶数或5*\/\r\n        #[Keywords]if#(k%2!=0&&k!=5&&num(i))\r\n        #{\r\n            #number[count][0]=i ;\r\n            #\/*存入数组*\/\r\n            #process(count++);\r\n            #\/*分解素数的各位数字*\/\r\n            #\/*若可逆素数满足放在矩阵第一行*\/\r\n            #\/*和最后一行的条件，记录可逆素数的*\/\r\n            #\/*下标，计数器加1*\/\r\n            #[Keywords]if#(number[count-1][2]%2!=0&&number[count-1][3]%2!=0&&number[count-1][2]!=5&&number[count-1][3]!=5)\r\n            #select[selecount++]=count-1 ;\r\n        #}\r\n    #}\r\n    #larray[0][lcount[0]++]=number[0][0]\/100 ;\r\n    #\/*临时数组的第一行存前二位*\/\r\n    #larray[1][lcount[1]++]=number[0][0]\/10 ;\r\n    #\/*临时数组的第二行存前三位*\/\r\n    #\/*将素数不重复的前二、三位存入临时数组中*\/\r\n    #[Keywords]for#(i=1;i<count;i++)\r\n    #{\r\n        #[Keywords]if#(larray[0][lcount[0]-1]!=number[i][0]\/100)\r\n        #larray[0][lcount[0]++]=number[i][0]\/100 ;\r\n        #[Keywords]if#(larray[1][lcount[1]-1]!=number[i][0]\/10)\r\n        #larray[1][lcount[1]++]=number[i][0]\/10 ;\r\n    #}\r\n    #\/*在第一行允许的汇聚围内穷举*\/\r\n    #[Keywords]for#(i1=0;i1<selecount;i1++)\r\n    #{\r\n        #array[0][0]=select[i1];\r\n        #[Tags]\/*取对应的素数下标*\/\r\n        #copy_num(0);\r\n        #[Tags]\/*复制分解的素数*\/\r\n        #[Tags]\/*穷举第二行*\/\r\n        #[Keywords]for#(array[1][0]=0;array[1][0]<count;array[1][0]++)\r\n        #{\r\n            #copy_num(1);\r\n            #[Tags]\/*复制分解的数字*\/\r\n            #[Keywords]if#(!comp_num(2))\r\n            #[Keywords]continue# ;\r\n            #[Tags]\/*若每列的前两位的组成与素数相矛盾，则试探下一个数*\/\r\n            #[Tags]\/*穷举第三行*\/\r\n            #[Keywords]for#(array[2][0]=0;array[2][0]<count;array[2][0]++)\r\n            #{\r\n                #copy_num(2);\r\n                #[Tags]\/*复制分解的数字*\/\r\n                #[Keywords]if#(!comp_num(3))\r\n                #[Keywords]continue# ;\r\n                #[Tags]\/*若每列的前三位的组成与素数相矛盾，则试探下一个数*\/\r\n                #[Tags]\/*在最后一行允许的范围内穷举*\/\r\n                #[Keywords]for#(i4=0;i4<selecount;i4++)\r\n                #{\r\n                    #array[3][0]=select[i4];\r\n                    #copy_num(3);\r\n                    #[Tags]\/*复制分解的数字*\/\r\n                    #[Tags]\/*判断每列是否可逆素数*\/\r\n                    #[Keywords]for#(flag=1,i=1;flag&&i<=4;i++)#[Keywords]if#(!find1(i))flag=0 ;\r\n                    #[Tags]\/*判断对角线是否为可逆素数*\/\r\n                    #[Keywords]if#(flag&&find2())\r\n                    #{\r\n                        #printf(#[Fields]\"No.%d\\n\"#,++cc);\r\n                        #fprintf(fp,#[Fields]\"No.%d\\n\"#,cc);\r\n                        #p_array();\r\n                    #}\r\n                    #[Tags]\/*输出幻方矩阵*\/\r\n                #}\r\n            #}\r\n        #}\r\n    #}\r\n    #fclose(fp);\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n#[Tags]\/*判断是否可逆素数*\/\r\n#[Keywords]int #num(#[Keywords]int #number)\r\n{\r\n    #[Keywords]int #j ;\r\n    #[Keywords]if#(!ok(number))#[Keywords]return #0 ;\r\n    #[Tags]\/*将素数变为反序数*\/\r\n    #[Keywords]for#(j=0;number>0;number\/=10)j=j*10+number%10 ;\r\n    #[Keywords]if#(!ok(j))#[Keywords]return #0 ;\r\n    #[Tags]\/*判断反序数是否为素数*\/\r\n    #[Keywords]return #1 ;\r\n#}\r\n#[Tags]\/*判断是否为素数*\/\r\n#[Keywords]int #ok(#[Keywords]int #number)\r\n{\r\n    #[Keywords]int #i,j ;\r\n    #[Keywords]if#(number%2==0)#[Keywords]return #0 ;\r\n    #j=sqrt((double)number)+1 ;\r\n    #[Keywords]for#(i=3;i<=j;i+=2)\r\n    #[Keywords]if#(number%i==0)#[Keywords]return #0 ;\r\n    #[Keywords]return #1 ;\r\n#}\r\n#[Tags]\/*将第i个整数分解为数字并存入数组*\/\r\n#[Keywords]void #process(#[Keywords]int #i)\r\n{\r\n    #[Keywords]int #j,num ;\r\n    #num=number[i][0];\r\n    #[Keywords]for#(j=4;j>=1;j--,num\/=10)\r\n    #number[i][j]=num%10 ;\r\n#}\r\n#[Tags]\/*将array[i][0]指向的素数的各位数字复制到array[i]中*\/\r\n#[Keywords]void #copy_num(#[Keywords]int #i)\r\n{\r\n    #[Keywords]int #j ;\r\n    #[Keywords]for#(j=1;j<=4;j++)\r\n    #array[i][j]=number[array[i][0]][j];\r\n#}\r\n#[Tags]\/*判断array中每列的前n位是否与可逆素数允许的前n位矛盾*\/\r\n#[Keywords]int #comp_num(#[Keywords]int #n)\r\n{\r\n    #[Keywords]static #[Keywords]int #ii ;\r\n    #[Tags]\/*用内部静态变量保存前一次查找到的元素下标*\/\r\n    #[Keywords]static #[Keywords]int #jj ;\r\n    #[Tags]\/*ii:前一次查找前二位的下标，jj:前一次查找前三位的下标*\/\r\n    #[Keywords]int #i,num,k,*p ;\r\n    #[Tags]\/*p:指向对应的要使用的前一次下标ii或jj*\/\r\n    #int*pcount ;\r\n    #[Tags]\/*pcount:指向要使用的临时数组数量的计数器*\/\r\n    #switch(n)\r\n    #{\r\n        #[Tags]\/*根据n的值选择对应的一组控制变量*\/\r\n        #[Keywords]case #2 :\r\n        #pcount=&lcount[0];\r\n        #p=&ii ;\r\n        #[Keywords]break# ;\r\n        #[Keywords]case #3 :\r\n        #pcount=&lcount[1];\r\n        #p=&jj ;\r\n        #[Keywords]break# ;\r\n        #default :\r\n        #[Keywords]return #0 ;\r\n    #}\r\n    #[Tags]\/*对四列分别进行处理*\/\r\n    #[Keywords]for#(i=1;i<=4;i++)\r\n    #{\r\n        #[Tags]\/*计算前n位数字代表的数值*\/\r\n        #[Keywords]for#(num=0,k=0;k<n;k++)num=num*10+array[k][i];\r\n        #[Tags]\/*与前一次最后查找到的元素进行比较*\/\r\n        #[Keywords]if#(num<=larray[n-2][*p])#[Keywords]for#(;*p>=0&&num<larray[n-2][*p];(*p)--);\r\n        #[Tags]\/*若前次查找到的元素大，则向前找*\/\r\n        #[Keywords]else #\r\n        #[Keywords]for#(;p<pcount&&num>larray[n-2][*p];(*p)++);\r\n        #[Tags]\/*否则向后找*\/\r\n        #[Keywords]if#(*p<0||*p>=*pcount)\r\n        #{\r\n            #[Tags]*p=0 ;\r\n            #[Keywords]return #0 ;\r\n        #}\r\n        #[Keywords]if#(num!=larray[n-2][*p])\r\n        #[Keywords]return #0 ;\r\n        #[Tags]\/*前n位不是可逆素数允许的值则返回0*\/\r\n    #}\r\n    #[Keywords]return #1 ;\r\n#}\r\n#[Tags]\/*判断列方向是否是可逆素数*\/\r\n#[Keywords]int #find1(#[Keywords]int #i)\r\n{\r\n    #[Keywords]int #num,j ;\r\n    #[Keywords]for#(num=0,j=0;j<4;j++)\r\n    #num=num*10+array[j][i];\r\n    #[Keywords]return #find0(num);\r\n#}\r\n#[Tags]\/*判断对角线方向是否是可逆素数*\/\r\n#[Keywords]int #find2(void)\r\n{\r\n    #[Keywords]int #num1,num2,i,j ;\r\n    #[Keywords]for#(num1=0,j=0;j<4;j++)\r\n    #num1=num1*10+array[j][j+1];\r\n    #[Keywords]for#(num2=0,j=0,i=4;j<4;j++,i--)\r\n    #num2=num2*10+array[j][i];\r\n    #[Keywords]if#(find0(num1))return(find0(num2));\r\n    #[Keywords]else #[Keywords]return #0 ;\r\n#}\r\n#[Tags]\/*查找是否为满足要求的可逆素数*\/\r\n#[Keywords]int #find0(#[Keywords]int #num)\r\n{\r\n    #[Keywords]static #[Keywords]int #j ;\r\n    #[Keywords]if#(num<=number[j][0])#[Keywords]for#(;j>=0&&num<number[j][0];j--);\r\n    #[Keywords]else #[Keywords]for#(;j<count&&num>number[j][0];j++);\r\n    #[Keywords]if#(j<0||j>=count)\r\n    #{\r\n        #j=0 ;\r\n        #[Keywords]return #0 ;\r\n    #}\r\n    #[Keywords]if#(num==number[j][0])#[Keywords]return #1 ;\r\n    #[Keywords]else #[Keywords]return #0 ;\r\n#}\r\n#[Tags]\/*输出矩阵*\/\r\n#[Keywords]void #p_array(void)\r\n{\r\n    #[Keywords]int #i,j ;\r\n    #[Keywords]for#(i=0;i<4;i++)\r\n    #{\r\n        #[Keywords]for#(j=1;j<=4;j++)\r\n        #{\r\n            #printf(#[Fields]\"%d \"#,array[i][j]);\r\n            #fprintf(fp,#[Fields]\"%d \"#,array[i][j]);\r\n        #}\r\n        #printf(#[Fields]\"\\n\"#);\r\n        #fprintf(fp,#[Fields]\"\\n\"#);\r\n    #}\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        211,
        "百钱百鸡问题",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #x,y,z,j=0 ;\r\n    #clrscr();\r\n    #puts(#[Fields]\"************************************************\"#);\r\n    #puts(#[Fields]\"*      This program is to solve Problem of     *\"#);\r\n    #puts(#[Fields]\"*           Hundred Yuan Hundred Fowls.        *\"#);\r\n    #puts(#[Fields]\"*  Which is presented by Zhang Qiujiang,       *\"#);\r\n    #puts(#[Fields]\"* a Chinese ancient mathematician, in his work *\"#);\r\n    #puts(#[Fields]\"* Bible of Calculation: 5 Yuan can buy 1 cock, *\"#);\r\n    #puts(#[Fields]\"* 3 Yuan can buy 1 hen, 1 Yuan buy 3 chickens, *\"#);\r\n    #puts(#[Fields]\"* now one has 100 Yuan to buy 100 fowls, the   *\"#);\r\n    #puts(#[Fields]\"* question is how many cocks, hens, chickens   *\"#);\r\n    #puts(#[Fields]\"* to buy?                                      *\"#);\r\n    #puts(#[Fields]\"************************************************\"#);\r\n    #printf(#[Fields]\"\\n The possible plans to buy 100 fowls with 100 Yuan are:\\n\\n\"#);\r\n    #[Tags]\/*外层循环控制鸡翁数*\/\r\n    #[Tags]\/*内层循环控制鸡母数y在0~33变化*\/\r\n    #[Keywords]for#(x=0;x<=20;x++)#[Keywords]for#(y=0;y<=33;y++)\r\n    #{\r\n        #z=100-x-y ;\r\n        #[Tags]\/*内外层循环控制下，鸡雏数z的值受x,y的值的制约*\/\r\n        #[Keywords]if#(z%3==0&&5*x+3*y+z\/3==100)\r\n        #[Tags]\/*验证取z值的合理性及得到一组解的合理性*\/\r\n        #printf(#[Fields]\"%2d: cock=%2d hen=%2d chicken=%2d\\n\"#,++j,x,y,z);\r\n    #}\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        212,
        "爱因斯坦的数学题",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #i=1 ;\r\n    #[Tags]\/*i为所设的阶梯数*\/\r\n    #clrscr();\r\n    #puts(#[Fields]\"**************************************************\"#);\r\n    #puts(#[Fields]\"*        This program is to solve                *\"#);\r\n    #puts(#[Fields]\"*     Einstein#[Fields]'s interesting math question,      *\"#);\r\n    #puts(#[Fields]\"*   which is presented by Albert Einstein,       *\"#);\r\n    #puts(#[Fields]\"*       a famous theoretical physicist.          *\"#);\r\n    #puts(#[Fields]\"* The Problem is as follows: there is a #[Keywords]long #    *\"#);\r\n    #puts(#[Fields]\"* ladder, #[Keywords]if #one step strides 2 stages, 1 stages *\"#);\r\n    #puts(#[Fields]\"* left, #[Keywords]if #one step strides 3 stages, 2 stages   *\"#);\r\n    #puts(#[Fields]\"* left, #[Keywords]if #one step strides 5 stages, 4 stages   *\"#);\r\n    #puts(#[Fields]\"* left, #[Keywords]if #one step strides 7 stages, 0 stages   *\"#);\r\n    #puts(#[Fields]\"* left, the question is, how many stages has     *\"#);\r\n    #puts(#[Fields]\"* the ladder?                                    *\"#);\r\n    #puts(#[Fields]\"**************************************************\"#);\r\n   #[Keywords] while#(!((i%2==1)&&(i%3==2)&&(i%5==4)&&(i%6==5)&&(i%7==0)))\r\n    #++i ;\r\n    #[Tags]\/*满足一组同余式的判别*\/\r\n    #printf(#[Fields]\"\\n >> The ladder has %d stages.\\n\"#,i);\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        213,
        "三色球问题",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #i,j,count=0;\r\n    #clrscr();\r\n    #puts(#[Fields]\"****************************************************************\"#);\r\n    #puts(#[Fields]\"*     This program is to solve Problem of Three Color Ball.    *\"#);\r\n    #puts(#[Fields]\"* The Problem is as follows: There are 12 balls in the pocket. *\"#);\r\n    #puts(#[Fields]\"* Amony them, 3 balls are red,3 balls are white and 6 balls    *\"#);\r\n    #puts(#[Fields]\"* are black. Now take out any 8 balls from the pocket,how      *\"#);\r\n    #puts(#[Fields]\"* many color combinations are there?                           *\"#);\r\n    #puts(#[Fields]\"****************************************************************\"#);\r\n    #puts(#[Fields]\" >> The solutions are:\"#);\r\n    #printf(#[Fields]\"  No.     RED BALL  WHITE BALL   BLACK BALL\\n\"#);\r\n    #printf(#[Fields]\"-----------------------------------------------------\\n\"#);\r\n    #[Keywords]for#(i=0;i<=3;i++)           #[Tags]\/*循环控制变量i控制任取红球个数0￣3*\/\r\n        #[Keywords]for#(j=0;j<=3;j++)       #[Tags]\/*循环控制变量j控制任取白球个数0￣3*\/\r\n            #[Keywords]if#((8-i-j)<=6)\r\n\t\t#printf(#[Fields]\" %2d    |     %d     |    %d    |     %d\\n\"#,++count,i,j,8-i-j);\r\n\r\n    #printf(#[Fields]\"-----------------------------------------------------\\n\"#);\r\n    #printf(#[Fields]\" Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        214,
        "马克思手稿中的数学题",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #x,y,z,count=0 ;\r\n    #clrscr();\r\n    #puts(#[Fields]\"****************************************************************\"#);\r\n    #puts(#[Fields]\"*  This program is to solve an interesting math question in    *\"#);\r\n    #puts(#[Fields]\"*                  Karl Marx#[Fields]'s manuscript.                     *\"#);\r\n    #puts(#[Fields]\"* The Problem is as follows: 30 persons spent 50 yuan in a     *\"#);\r\n    #puts(#[Fields]\"* restaurant, amony them, each man spent 3 yuan, each woman    *\"#);\r\n    #puts(#[Fields]\"* spent 2 yuan, and each child spent 1 yuan. The question is   *\"#);\r\n    #puts(#[Fields]\"* how many men, women and children are there?                  *\"#);\r\n    #puts(#[Fields]\"****************************************************************\"#);\r\n    #puts(#[Fields]\" >> The solutions are:\"#);\r\n    #printf(#[Fields]\"   No.        Men       Women     Children\\n\"#);\r\n    #printf(#[Fields]\"---------------------------------------------\\n\"#);\r\n    #[Keywords]for#(x=0;x<=10;x++)\r\n    #{\r\n        #y=20-2*x ;\r\n        #[Tags]\/*x定值据(3)式求y*\/\r\n        #z=30-x-y ;\r\n        #[Tags]\/*由(1)式求z*\/\r\n        #[Tags]\/*当前得到的一组解是否满足式(2)*\/\r\n        #[Keywords]if#(3*x+2*y+z==50)printf(#[Fields]\" <%2d>    |    %2d    |    %2d    |    %2d\\n\"#,++count,x,y,z);\r\n    #}\r\n    #printf(#[Fields]\"---------------------------------------------\\n\"#);\r\n    #printf(#[Fields]\" Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        215,
        "配对新郎和新娘",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #x,y,z;\r\n    #clrscr();\r\n    #puts(#[Fields]\"****************************************************************\"#);\r\n    #puts(#[Fields]\"*  This program is to solve Problem of Bridegroom and Bride.   *\"#);\r\n    #puts(#[Fields]\"* The Problem is as follows: Someone goes to 3 couples lovers#[Fields]' *\"#);\r\n    #puts(#[Fields]\"* wedding. The bridegrooms are A,B,C and the brides are X,Y,Z. *\"#);\r\n    #puts(#[Fields]\"* He wants to know who marries who and asks them. A says he    *\"#);\r\n    #puts(#[Fields]\"* will marry to X, X says her fiance is C, C says he will marry*\"#);\r\n    #puts(#[Fields]\"* to Z. The man knows that they are all kidding. What they said*\"#);\r\n    #puts(#[Fields]\"* is not #[Keywords]true#. So #[Keywords]try #to find who will marry to who?           *\"#);\r\n    #puts(#[Fields]\"****************************************************************\"#);\r\n    #puts(#[Fields]\" >> The solutions are:\"#);\r\n    #printf(#[Fields]\"---------------------------------------------\\n\"#);\r\n    #[Keywords]for#(x=1;x<=3;x++)          #[Tags]\/*穷举x的全部可能配偶*\/\r\n        #[Keywords]for#(y=1;y<=3;y++)      #[Tags]\/*穷举y的全部可能配偶*\/\r\n            #[Keywords]for#(z=1;z<=3;z++)    #[Tags]\/*穷举z的全部可能配偶*\/\r\n                #[Keywords]if#(x!=1&&x!=3&&z!=3&&x!=y&&x!=z&&y!=z)  #[Tags]\/*判断配偶是否满足题意*\/\r\n                #{\r\n\t\t    #printf(#[Fields]\" X will marry to %c.\\n\"#,#[Fields]'A'#+x-1);    #[Tags]\/*打印判断结果*\/\r\n\t\t    #printf(#[Fields]\" Y will marry to %c.\\n\"#,#[Fields]'A'#+y-1);\r\n\t\t    #printf(#[Fields]\" Z will marry to %c.\\n\"#,#[Fields]'A'#+z-1);\r\n                #}\r\n    #printf(#[Fields]\"---------------------------------------------\\n\"#);\r\n    #printf(#[Fields]\" Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        216,
        "约瑟夫问题",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #x,y,z;\r\n    #clrscr();\r\n    #puts(#[Fields]\"****************************************************************\"#);\r\n    #puts(#[Fields]\"*  This program is to solve Problem of Bridegroom and Bride.   *\"#);\r\n    #puts(#[Fields]\"* The Problem is as follows: Someone goes to 3 couples lovers#[Fields]' *\"#);\r\n    #puts(#[Fields]\"* wedding. The bridegrooms are A,B,C and the brides are X,Y,Z. *\"#);\r\n    #puts(#[Fields]\"* He wants to know who marries who and asks them. A says he    *\"#);\r\n    #puts(#[Fields]\"* will marry to X, X says her fiance is C, C says he will marry*\"#);\r\n    #puts(#[Fields]\"* to Z. The man knows that they are all kidding. What they said*\"#);\r\n    #puts(#[Fields]\"* is not #[Keywords]true#. So #[Keywords]try #to find who will marry to who?           *\"#);\r\n    #puts(#[Fields]\"****************************************************************\"#);\r\n    #puts(#[Fields]\" >> The solutions are:\"#);\r\n    #printf(#[Fields]\"---------------------------------------------\\n\"#);\r\n    #[Keywords]for#(x=1;x<=3;x++)          #[Tags]\/*穷举x的全部可能配偶*\/\r\n        #[Keywords]for#(y=1;y<=3;y++)      #[Tags]\/*穷举y的全部可能配偶*\/\r\n            #[Keywords]for#(z=1;z<=3;z++)    #[Tags]\/*穷举z的全部可能配偶*\/\r\n                #[Keywords]if#(x!=1&&x!=3&&z!=3&&x!=y&&x!=z&&y!=z)  #[Tags]\/*判断配偶是否满足题意*\/\r\n                #{\r\n\t\t    #printf(#[Fields]\" X will marry to %c.\\n\"#,#[Fields]'A'#+x-1);    #[Tags]\/*打印判断结果*\/\r\n\t\t    #printf(#[Fields]\" Y will marry to %c.\\n\"#,#[Fields]'A'#+y-1);\r\n\t\t    #printf(#[Fields]\" Z will marry to %c.\\n\"#,#[Fields]'A'#+z-1);\r\n                #}\r\n    #printf(#[Fields]\"---------------------------------------------\\n\"#);\r\n    #printf(#[Fields]\" Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        217,
        "邮票组合",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#define M 255\r\n#[Keywords]int #a[M];\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #i,j,k,s,n=0;\r\n    #clrscr();\r\n    #puts(#[Fields]\"****************************************************************\"#);\r\n    #puts(#[Fields]\"*    This program is to solve Problem of Stamp Combination.    *\"#);\r\n    #puts(#[Fields]\"* The Problem is as follows. John has 4 stamps with value of 3 *\"#);\r\n    #puts(#[Fields]\"* cents and 3 stamps with value of 5 cents. Use one or more of *\"#);\r\n    #puts(#[Fields]\"* these stamps, how many kinds of postages can John provide?   *\"#);\r\n    #puts(#[Fields]\"****************************************************************\"#);\r\n    #puts(#[Fields]\"\\n >> The solution is: \\n\"#);\r\n    #printf(#[Fields]\"---------------------------------------------\\n\\n\"#);\r\n    #[Keywords]for#(i=0;i<=4;i++)           #[Tags]\/*i:取三分邮票的张数*\/\r\n        #[Keywords]for#(j=0;j<=3;j++)       #[Tags]\/*j:取5分邮票的张数*\/\r\n        #{\r\n            #s=i*3+j*5;        #[Tags]\/*计算组成的邮票面值*\/\r\n            #[Keywords]for#(k=0;a[k];k++)     #[Tags]\/*查找是否有相同的邮资*\/\r\n                #[Keywords]if#(s==a[k])#[Keywords]break#;\r\n            #[Keywords]if#(!a[k]&&s)         #[Tags]\/*没有找到相同的邮资则满足要求存入数组*\/\r\n            #{\r\n                #a[k]=s; n++;\r\n            #}\r\n        #}\r\n    #printf(#[Fields]\" >> There are %d kinds of postages:\\n\\n\"#,n);      #[Tags]\/*输出结果*\/\r\n    #[Keywords]for#(k=0;a[k];k++)\r\n\t#printf(#[Fields]\" %d\"#,a[k]);\r\n    #printf(#[Fields]\"\\n\"#);\r\n    #printf(#[Fields]\"\\n---------------------------------------------\\n\"#);\r\n    #printf(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        218,
        "分糖果",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #print(#[Keywords]int #s[]);\r\n#[Keywords]int #judge(#[Keywords]int #c[]);\r\n#[Keywords]int #j=0;\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]static #[Keywords]int #sweet[10]={10,2,8,22,16,4,10,6,14,20#};   #[Tags]\/*初始化数组数据*\/\r\n    #[Keywords]int #i,t[10],l;\r\n    #clrscr();\r\n    #printf(#[Fields]\"  Child No.    1   2   3   4   5   6   7   8   9   10\\n\"#);\r\n    #printf(#[Fields]\"------------------------------------------------------\\n\"#);\r\n    #printf(#[Fields]\"  Round No.|\\n\"#);\r\n    #print(sweet);         #[Tags]\/*输出每个人手中糖的块数*\/\r\n   #[Keywords] while#(judge(sweet))      #[Tags]\/*若不满足要求则继续进行循环*\/\r\n    #{\r\n        #[Keywords]for#(i=0;i<10;i++)    #[Tags]\/*将每个人手中的糖分成一半*\/\r\n            #[Keywords]if#(sweet[i]%2==0)     #[Tags]\/*若为偶数则直接分出一半*\/\r\n                #t[i]=sweet[i]=sweet[i]\/2;\r\n            #[Keywords]else #              #[Tags]\/*若为奇数则加1后再分出一半*\/\r\n                #t[i]=sweet[i]=(sweet[i]+1)\/2;\r\n        #[Keywords]for#(l=0;l<9;l++)         #[Tags]\/*将分出的一半糖给右(后)边的孩子*\/\r\n            #sweet[l+1]=sweet[l+1]+t[l];\r\n        #sweet[0]+=t[9];\r\n        #print(sweet);             #[Tags]\/*输出当前每个孩子中手中的糖数*\/\r\n    #}\r\n    #printf(#[Fields]\"------------------------------------------------------\\n\"#);\r\n    #printf(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n#[Keywords]int #judge(#[Keywords]int #c[])\r\n{\r\n    #[Keywords]int #i;\r\n    #[Keywords]for#(i=0;i<10;i++)          #[Tags]\/*判断每个孩子手中的糖是否相同*\/\r\n        #[Keywords]if#(c[0]!=c[i]) #[Keywords]return #1;          #[Tags]\/*不相同返回 1*\/\r\n    #[Keywords]return #0;\r\n#}\r\n#[Keywords]void #print(#[Keywords]int #s[])      #[Tags]\/*输出数组中每个元素的值*\/\r\n{\r\n    #[Keywords]int #k;\r\n    #printf(#[Fields]\"      <%2d> | \"#,j++);\r\n    #[Keywords]for#(k=0;k<10;k++)   printf(#[Fields]\"%4d\"#,s[k]);\r\n    #printf(#[Fields]\"\\n\"#);\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        219,
        "波瓦松的分酒趣题",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #getti(#[Keywords]int #a,#[Keywords]int #y,#[Keywords]int #z);\r\n#[Keywords]int #i;           \/*最后需要分出的重量*\/\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #a,y,z;\r\n    #clrscr();\r\n    #puts(#[Fields]\"***************************************************************\"#);\r\n    #puts(#[Fields]\"*  This program is to solve Problem of Poisson Beer Division. *\"#);\r\n    #puts(#[Fields]\"* The Problem is as follows: Someone has a bottle of 12 pints *\"#);\r\n    #puts(#[Fields]\"* beer. He wants to get 6 pints, but he does not has a bottle *\"#);\r\n    #puts(#[Fields]\"* of 6 pints. He only has a bottle of 8 pints and a bottle of *\"#);\r\n    #puts(#[Fields]\"* 5 pints. So how can he get 6 pints?                         *\"#);\r\n    #puts(#[Fields]\"***************************************************************\"#);\r\n    #printf(#[Fields]\" >> Input Full bottle a,Empty b,c, and Get volumes:\\n\"#); #[Tags]\/*a 满瓶的容量  y:第一个空瓶的容量  z:第二个空瓶的容量*\/\r\n    #printf(#[Fields]\" >> \"#);\r\n    #scanf(#[Fields]\"%d%d%d%d\"#,&a,&y,&z,&i);\r\n    #getti(a,y,z);           #[Tags]\/*按a -> y -> z -> a的操作步骤*\/\r\n    #\/*getti(a,z,y);           #[Tags]\/*按a -> z -> y -> a的步骤*\/\r\n    #printf(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n#[Keywords]void #getti(#[Keywords]int #a,#[Keywords]int #y,#[Keywords]int #z)   #[Tags]\/*a:满瓶的容量  y:第一个空瓶的容量  z:第二个空瓶的容量*\/\r\n{\r\n   #[Keywords]int #b=0,c=0,j=0;           #[Tags]\/* b:第一瓶实际的重量  c:第二瓶实际的重量 j: 倒的步数*\/\r\n   #puts(#[Fields]\" >> The division steps are as follows.\\n\"#);\r\n\r\n   #printf(#[Fields]\" Bottle:    a<%d> b<%d> c<%d>\\n\"#,a,y,z);\r\n   #printf(#[Fields]\"-----------------------------\\n\"#);\r\n   #printf(#[Fields]\" Step No.|\\n\"#);\r\n   #printf(#[Fields]\"   <%d>   | %4d %4d %4d\\n\"#,j++,a,b,c);\r\n\r\n  #[Keywords] while#(a!=i||b!=i&&c!=i)      #[Tags]\/*当满瓶!=i或另两瓶都!=i*\/\r\n   #{\r\n      #[Keywords]if#(!b)\r\n      #{  a-=y; b=y;#}    #[Tags]\/*如果第一瓶为空，则将满瓶倒入第一瓶中*\/\r\n      #[Keywords]else #[Keywords]if#(c==z)\r\n      #{  a+=z; c=0;#}    #[Tags]\/*如果第二瓶满，则将第二瓶倒入满瓶中*\/\r\n      #[Keywords]else #[Keywords]if#(b>z-c)    #[Tags]\/*如果第一瓶的重量>第二瓶的剩余空间*\/\r\n      #{ b-=(z-c);c=z;#}    #[Tags]\/*则将装满第二瓶，第一瓶中保留剩余部分*\/\r\n     #[Keywords] else#{ c+=b; b=0;#}   #[Tags]\/*否则，将第一瓶全部倒入第二瓶中*\/\r\n      #printf(#[Fields]\"   <%d>   | %4d %4d %4d\\n\"#,j++,a,b,c);\r\n   #}\r\n   #printf(#[Fields]\"-----------------------------\\n\"#);\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        220,
        "求π的近似值",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#include<math.h>\r\n#include<time.h>\r\n#include<stdlib.h>\r\n#define N 30000\r\n#[Keywords]void #main()\r\n{\r\n   #[Keywords]double #e=0.1,b=0.5,c,d;\r\n   #[Keywords]long #[Keywords]int #i;         #[Tags]\/*i: 正多边形边数*\/\r\n   #[Keywords]float #x,y;\r\n   #[Keywords]int #c2=0,d2=0;\r\n   #clrscr();\r\n   #puts(#[Fields]\"***********************************************************\"#);\r\n   #puts(#[Fields]\"*      This program is to calculate PI approximatively    *\"#);\r\n   #puts(#[Fields]\"*                    in two methods.                      *\"#);\r\n   #puts(#[Fields]\"*       One method is Regular Polygon Approximating,      *\"#);\r\n   #puts(#[Fields]\"*          the other is Random Number Method.             *\"#);\r\n   #puts(#[Fields]\"***********************************************************\"#);\r\n   #puts(#[Fields]\"\\n >> Result of Regular Polygon Approximating:\"#);\r\n   #[Keywords]for#(i=6;;i*=2)         #[Tags]\/*正多边形边数加倍*\/\r\n   #{\r\n      #d=1.0-sqrt(1.0-b*b);    #[Tags]\/*计算圆内接正多边形的边长*\/\r\n      #b=0.5*sqrt(b*b+d*d);\r\n      #[Keywords]if#(2*i*b-i*e<1e-15) #[Keywords]break#;    #[Tags]\/*精度达1e-15则停止计算*\/\r\n      #e=b;    #[Tags]\/*保存本次正多边形的边长作为下一次精度控制的依据*\/\r\n   #}\r\n   #printf(#[Fields]\"---------------------------------------------------------\\n\"#);\r\n   #printf(#[Fields]\" >> pi=%.15lf\\n\"#,2*i*b);       \/*输出π值和正多边形的边数*\/\r\n   #printf(#[Fields]\" >> The number of edges of required polygon:%ld\\n\"#,i);\r\n   #printf(#[Fields]\"---------------------------------------------------------\\n\"#);\r\n   #randomize();\r\n  #[Keywords] while#(c2++<=N)\r\n   #{\r\n        #x=random(101);      #[Tags]\/*x:坐标。产生0到100之间共101个的随机数*\/\r\n        #y=random(101);      #[Tags]\/*y:坐标。产生0到100之间共101个的随机数*\/\r\n        #[Keywords]if#(x*x+y*y<=10000)     #[Tags]\/*利用圆方程判断点是否落在圆内*\/\r\n            #d2++;\r\n   #}\r\n   #puts(#[Fields]\"\\n >> Result of Random Number Method:\"#);\r\n   #printf(#[Fields]\"---------------------------------------------------------\\n\"#);\r\n   #printf(#[Fields]\" >> pi=%f\\n\"#,4.*d2\/N);    #[Tags]\/*输出求出的π值*\/\r\n   #printf(#[Fields]\"---------------------------------------------------------\\n\"#);\r\n   #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n   #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        221,
        "奇数平方的有趣性质",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]long #[Keywords]int #a,n=0;\r\n    #clrscr();\r\n    #puts(#[Fields]\"***********************************************************\"#);\r\n    #puts(#[Fields]\"*      >>      This program is to verify       <<         *\"#);\r\n    #puts(#[Fields]\"*      >>     odd number#[Fields]'s characteristic.     <<         *\"#);\r\n    #puts(#[Fields]\"* That is square of an odd number larger than 1000 minus  *\"#);\r\n    #puts(#[Fields]\"* 1 can be divided exactly by 8.                          *\"#);\r\n    #puts(#[Fields]\"* For example, 2001^2-1=4004000=500500*8.                 *\"#);\r\n    #puts(#[Fields]\"***********************************************************\"#);\r\n   #[Keywords] while#(n<1001)\r\n    #{\r\n    \t#printf(#[Fields]\" >> Please input the range you want to verify: \"#);\r\n    \t#scanf(#[Fields]\"%ld\"#,&n);\r\n    #}\r\n    #puts(#[Fields]\" >> Now start to verify:\"#);\r\n    #[Keywords]for#(a=1001;a<=n;a+=2)\r\n    #{\r\n        #printf(#[Fields]\"%ld:\"#,a);       #[Tags]\/*输出奇数本身*\/\r\n        #printf(#[Fields]\"(%ld*%ld-1)\/8\"#,a,a);      #[Tags]\/*输出(奇数的平方减1)\/8*\/\r\n        #printf(#[Fields]\"=%ld\"#,(a*a-1)\/8);        #[Tags]\/*输出被8除后的商*\/\r\n        #printf(#[Fields]\"+%ld\\n\"#,(a*a-1)%8);      #[Tags]\/*输出被8除后的余数*\/\r\n    #}\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        222,
        "角谷猜想",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #n=1,count=0;\r\n    #clrscr();\r\n    #puts(#[Fields]\"*********************************************************\"#);\r\n    #puts(#[Fields]\"*      >> This program is to verify Jiaogu Guess  <<    *\"#);\r\n    #puts(#[Fields]\"* That is given any natural number, #[Keywords]if #it is an even,   *\"#);\r\n    #puts(#[Fields]\"* divides 2, #[Keywords]if #it is an odd, multiple 3 and add 1, the *\"#);\r\n    #puts(#[Fields]\"* result #[Keywords]continue#s to be calculated analogously. After  *\"#);\r\n    #puts(#[Fields]\"* some times, the result is always 1.                   *\"#);\r\n    #puts(#[Fields]\"*********************************************************\"#);\r\n   #[Keywords] while#(n!=0)\r\n    #{\r\n\t    #printf(#[Fields]\" >> Please input a number to verify(0 to quit): \"#);\r\n\t    #scanf(#[Fields]\"%d\"#,&n);      #[Tags]\/*输入任一整数*\/\r\n\t    #[Keywords]if#(n==0)\r\n\t\t#[Keywords]break#;\r\n\t    #printf(#[Fields]\" >> ------ Results of verification: ------------\\n\"#);\r\n\t    #do{\r\n\t        #[Keywords]if#(n%2)\r\n\t        #{\r\n\t            #n=n*3+1;           #[Tags]\/*若为奇数，n乘3加1*\/\r\n\t\t    #printf(#[Fields]\" >> Step No.%d: %d*3+1=%d\\n\"#,++count,(n-1)\/3,n);\r\n\t        #}\r\n\t       #[Keywords] else#\r\n\t        #{\r\n\t            #n\/=2;          #[Tags]\/*若为偶数n除以2*\/\r\n\t\t    #printf(#[Fields]\" >> Step No.%d: %d\/2=%d\\n\"#,++count,2*n,n);\r\n\t        #}\r\n\t    #}#[Keywords]while#(n!=1);             #[Tags]\/*n不等于1则继续以上过程*\/\r\n\t    #printf(#[Fields]\" >> ---------------------------------------------\\n\"#);\r\n    #}\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        223,
        "四方定理",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #verify_four_squares(#[Keywords]int #number)\r\n{\r\n    #[Keywords]int #i,j,k,l;\r\n    #[Keywords]for#(i=1;i<number\/2;i++)         #[Tags]\/*试探法。试探i,j,k,k的不同值*\/\r\n\t        #[Keywords]for#(j=0;j<=i;j++)\r\n\t            #[Keywords]for#(k=0;k<=j;k++)\r\n\t                #[Keywords]for#(l=0;l<=k;l++)\r\n\t                    #[Keywords]if#(number==i*i+j*j+k*k+l*l)    #[Tags]\/*若满足定理要求则输出结果*\/\r\n\t                    #{\r\n\t\t\t\t#printf(#[Fields]\" >> %d=%d*%d+%d*%d+%d*%d+%d*%d\\n\"#,number,i,i,j,j,k,k,l,l);\r\n\t\t\t\t#[Keywords]return#;#\r\n\t                    #}\r\n#}\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #number=1;\r\n\r\n    #clrscr();\r\n    #puts(#[Fields]\"*****************************************************\"#);\r\n    #puts(#[Fields]\"* This program is to verify Theorem of Four Squares.*\"#);\r\n    #puts(#[Fields]\"* That is all natural numbers can be represented as *\"#);\r\n    #puts(#[Fields]\"* sum of no more than 4 squares of the numbers.     *\"#);\r\n    #puts(#[Fields]\"*****************************************************\"#);\r\n   #[Keywords] while#(number!=0)\r\n    #{\r\n\t    #printf(#[Fields]\" >> Please input a number to verify(0 to quit): \"#);\r\n\t    #scanf(#[Fields]\"%d\"#,&number);      #[Tags]\/*输入任一整数*\/\r\n\t    #[Keywords]if#(number==0)\r\n\t\t#[Keywords]break#;\r\n\t    #printf(#[Fields]\" >> ------ Results of verification: ------------\\n\"#);\r\n\t    #verify_four_squares(number);\r\n\t    #printf(#[Fields]\" >> ---------------------------------------------\\n\"#);\r\n    #}\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        224,
        "卡布列克常数",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #vr6174(#[Keywords]int#);\r\n#[Keywords]void #parse_sort(#[Keywords]int #num,#[Keywords]int #*each);\r\n#[Keywords]void #max_min(#[Keywords]int #*each,#[Keywords]int #*max,#[Keywords]int #*min);\r\n#[Keywords]void #parse_sort(#[Keywords]int #num,#[Keywords]int #*each);\r\n#[Keywords]int #count=0;\r\n#[Keywords]void #main()\r\n{\r\n\r\n    #[Keywords]int #n=1;\r\n    #clrscr();\r\n    #puts(#[Fields]\"**************************************************************\"#);\r\n    #puts(#[Fields]\"*         This program is to verify Comgrich Content.        *\"#);\r\n    #puts(#[Fields]\"* That is any 4-digit number whose digitals are not the same *\"#);\r\n    #puts(#[Fields]\"* has the rule: (1) range the 4 digits to get the maximum    *\"#);\r\n    #puts(#[Fields]\"* 4-digit number, (2) range the 4 digits to get the minimum  *\"#);\r\n    #puts(#[Fields]\"* 4-digit number, (3) get the difference of these two numbers*\"#);\r\n    #puts(#[Fields]\"* that is a #[Keywords]new #4-digit number. Continute to calculate with  *\"#);\r\n    #puts(#[Fields]\"* (1)-(3),the result in the end is 6174,the Comgrich Content.*\"#);\r\n    #puts(#[Fields]\"**************************************************************\"#);\r\n   #[Keywords] while#(n!=0)\r\n    #{\r\n\t    #printf(#[Fields]\" >> Please input a 4-digit number to verify(0 to quit): \"#);\r\n\t    #scanf(#[Fields]\"%d\"#,&n);      #[Tags]\/*输入任一整数*\/\r\n\t    #[Keywords]if#(n==0)\r\n\t\t#[Keywords]break#;\r\n\t    #printf(#[Fields]\" >> ------ Results of verification: ------------\\n\"#);\r\n\t    #count=0;\r\n\t    #vr6174(n);           #[Tags]\/*调用函数进行验证*\/\r\n\t    #printf(#[Fields]\" >> ---------------------------------------------\\n\"#);\r\n    #}\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n#[Keywords]void #vr6174(#[Keywords]int #num)\r\n{\r\n    #[Keywords]int #each[4],max,min;\r\n    #[Keywords]if#(num!=6174&&num)    #[Tags]\/*若不等于74且不等于0则进行卡布列克运算*\/\r\n    #{\r\n        #parse_sort(num,each);         #[Tags]\/*将整数分解，数字存入each数组中*\/\r\n        #max_min(each,&max,&min);      #[Tags]\/*求数字组成的最大值和最小值*\/\r\n        #num=max-min;          #[Tags]\/*求最大值和最小值的差*\/\r\n        #printf(#[Fields]\" >> Step No.%d:  %d-%d=%d\\n\"#,++count,max,min,num); \/*输出该步计算过程*\/\r\n        #vr6174(num);         #[Tags]\/*递归调用自身继续进行卡布列克运算*\/\r\n    #}\r\n#}\r\n#[Keywords]void #parse_sort(#[Keywords]int #num,#[Keywords]int #*each)\r\n{\r\n    #[Keywords]int #i,*j,*k,temp;\r\n    #[Keywords]for#(i=0;i<=4;i++)         #[Tags]\/*将NUM分解为数字*\/\r\n    #{\r\n        #j=each+3-i;\r\n        #[Tags]*j=num%10;\r\n        #num\/=10;\r\n    #}\r\n    #[Keywords]for#(i=0;i<3;i++)     #[Tags]\/*对各保数字从小到大进行排序*\/\r\n        #[Keywords]for#(j=each,k=each+1;j<each+3-i;j++,k++)\r\n            #[Keywords]if#(*j>*k) { temp=*j;*j=*k;*k=temp;#}\r\n    #[Keywords]return#;#\r\n#}\r\n#[Keywords]void #max_min(#[Keywords]int #*each,#[Keywords]int #*max,#[Keywords]int #*min)    \r\n#[Tags]\/*将分解的数字还原为最大整数和最小整数*\/\r\n{\r\n    #[Keywords]int #*i;\r\n    #[Tags]*min=0;\r\n    #[Keywords]for#(i=each;i<each+4;i++)     #[Tags]\/*还原为最小的整数*\/\r\n        #[Tags]*min=#[Tags]*min#[Tags]*10+#[Tags]*i;\r\n    #[Tags]*max=0;\r\n    #[Keywords]for#(i=each+3;i>=each;i--)    #[Tags]\/*还原为最大的整数*\/\r\n        #[Tags]*max=#[Tags]*max#[Tags]*10+#[Tags]*i;\r\n    #[Keywords]return#;#\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        225,
        "尼科彻斯定理",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #vrNico(#[Keywords]int #a)\r\n{\r\n    #[Keywords]int #b,c,d;\r\n    #b=a*a*a;         #[Tags]\/*求整数的三次方*\/\r\n    #printf(#[Fields]\" >> %d*%d*%d=%d=\"#,a,a,a,b);\r\n    #[Keywords]for#(d=0,c=0;c<a;c++)     #[Tags]\/*输出数列，首项为a*a-a+1,等差值为2*\/\r\n    #{\r\n        #d+=a*a-a+1+c*2;     #[Tags]\/*求数列的前a项的和*\/\r\n        #printf(c?#[Fields]\"+%d\"#:#[Fields]\"%d\"#,a*a-a+1+c*2);\r\n    #}\r\n    #[Keywords]if#(d==b)printf(#[Fields]\" Satisfy!\\n\"#);    #[Tags]\/*若条件满足则输出#[Fields]\"Y\"#*\/\r\n    #[Keywords]else #printf(#[Fields]\" Dissatisfy!\\n\"#);    #[Tags]\/*否则输出#[Fields]\"N\"#*\/\r\n#}\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]int #n=1;\r\n    #clrscr();\r\n    #puts(#[Fields]\"******************************************************\"#);\r\n    #puts(#[Fields]\"*    This program is to verify Theorem of Nicoqish.  *\"#);\r\n    #puts(#[Fields]\"* That is the cube of any integer can be represented *\"#);\r\n    #puts(#[Fields]\"* as the sum of some #[Keywords]continue# odd numbers.           *\"#);\r\n    #puts(#[Fields]\"* For example, 8^3=512=57+58+59+61+63+65+67+69+71.   *\"#);\r\n    #puts(#[Fields]\"******************************************************\"#);\r\n   #[Keywords] while#(n!=0)\r\n    #{\r\n\t    #printf(#[Fields]\" >> Please input a integer to verify(0 to quit): \"#);\r\n\t    #scanf(#[Fields]\"%d\"#,&n);    #[Tags]\/*输入任一整数*\/\r\n\t    #[Keywords]if#(n==0)\r\n\t\t#[Keywords]break#;\r\n\t    #printf(#[Fields]\" >> ------ Results of verification: ------------\\n\"#);\r\n\t    #vrNico(n);        #[Tags]\/*调用函数进行验证*\/\r\n\t    #printf(#[Fields]\" >> ---------------------------------------------\\n\"#);\r\n    #}\r\n    #puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        226,
        "扑克牌自动发牌",
        "代码如下：\r\n[code=java]\r\n#include<stdlib.h>\r\n#include<stdio.h>\r\n#[Keywords]int #comp(const #[Keywords]void #*j,const #[Keywords]void #*i);\r\n#[Keywords]void #p(#[Keywords]int #p,#[Keywords]int #b[],#[Keywords]char #n[]);\r\n#[Keywords]void #main()\r\n{\r\n    #[Keywords]static #[Keywords]char #n[]={#[Fields]'2'#,#[Fields]'3'#,#[Fields]'4'#,#[Fields]'5'#,#[Fields]'6'#,#[Fields]'7'#,#[Fields]'8'#,#[Fields]'9'#,#[Fields]'T'#,#[Fields]'J'#,#[Fields]'Q'#,#[Fields]'K'#,#[Fields]'A'##};\r\n    #[Keywords]int #a[53],b1[13],b2[13],b3[13],b4[13];\r\n    #[Keywords]int #b11=0,b22=0,b33=0,b44=0,t=1,m,flag,i;\r\n    #clrscr();\r\n    #puts(#[Fields]\"******************************************************\"#);\r\n    #puts(#[Fields]\"*      This is an Automatic Dealing Card program!    *\"#);\r\n    #puts(#[Fields]\"*  In one game, 52 cards are divided into 4 groups.  *\"#);\r\n    #puts(#[Fields]\"******************************************************\"#);\r\n    #printf(#[Fields]\" >> ----- Each person#[Fields]'s cards are as follows. -------\"#);\r\n   #[Keywords] while#(t<=52)      #[Tags]\/*控制发52张牌*\/\r\n    #{     m=random(52);      #[Tags]\/*产生0到51之间的随机数*\/\r\n          #[Keywords]for#(flag=1,i=1;i<=t&&flag;i++)   #[Tags]\/*查找新产生的随机数是否已经存在*\/\r\n            #[Keywords]if#(m==a[i]) flag=0;     #[Tags]\/*flag=1:产生的是新的随机数\r\n                                        #[Tags]#flag=0:新产生的随机数已经存在*\/\r\n          #[Keywords]if#(flag)\r\n          #{\r\n             #a[t++]=m;       #[Tags]\/*如果产生了新的随机数，则存入数组*\/\r\n             #[Keywords]if#(t%4==0) b1[b11++]=a[t-1];        #[Tags]\/*根据t的模值，判断当前*\/\r\n             #[Keywords]else #[Keywords]if#(t%4==1) b2[b22++]=a[t-1];   #[Tags]\/*的牌应存入哪个数组中*\/\r\n             #[Keywords]else #[Keywords]if#(t%4==2) b3[b33++]=a[t-1];\r\n             #[Keywords]else #[Keywords]if#(t%4==3) b4[b44++]=a[t-1];\r\n          #}\r\n      #}\r\n      #qsort(b1,13,sizeof(#[Keywords]int#),comp);      #[Tags]\/*将每个人的牌进行排序*\/\r\n      #qsort(b2,13,sizeof(#[Keywords]int#),comp);\r\n      #qsort(b3,13,sizeof(#[Keywords]int#),comp);\r\n      #qsort(b4,13,sizeof(#[Keywords]int#),comp);\r\n      #p(1,b1,n); p(2,b2,n); p(3,b3,n); p(4,b4,n);     #[Tags]\/*分别打印每个人的牌*\/\r\n      #printf(#[Fields]\" >> ----------- Press any key to quit... ------------\"#);\r\n      #getch();\r\n#}\r\n#[Keywords]void #p(#[Keywords]int #p,#[Keywords]int #b[],#[Keywords]char #n[])\r\n{\r\n   #[Keywords]int #i;\r\n   #printf(#[Fields]\"\\n   Person No.%d   \\006 \"#,p);     #[Tags]\/*打印黑桃标记*\/\r\n   #[Keywords]for#(i=0;i<13;i++)      #[Tags]\/*将数组中的值转换为相应的花色*\/\r\n      #[Keywords]if#(b[i]\/13==0) printf(#[Fields]\" %c\"#,n[b[i]%13]);  #[Tags]\/*该花色对应的牌*\/\r\n   #printf(#[Fields]\"\\n                 \\003 \"#);      #[Tags]\/*打印红桃标记*\/\r\n   #[Keywords]for#(i=0;i<13;i++)\r\n      #[Keywords]if#((b[i]\/13)==1) printf(#[Fields]\" %c\"#,n[b[i]%13]);\r\n   #printf(#[Fields]\"\\n                 \\004 \"#);     #[Tags]\/*打印方块标记*\/\r\n   #[Keywords]for#(i=0;i<13;i++)\r\n      #[Keywords]if#(b[i]\/13==2) printf(#[Fields]\" %c\"#,n[b[i]%13]);\r\n   #printf(#[Fields]\"\\n                 \\005 \"#);     #[Tags]\/*打印梅花标记*\/\r\n   #[Keywords]for#(i=0;i<13;i++)\r\n      #[Keywords]if#(b[i]\/13==3||b[i]\/13==4) printf(#[Fields]\" %c\"#,n[b[i]%13]);\r\n   #printf(#[Fields]\"\\n\"#);\r\n#}\r\n#[Keywords]int #comp(const #[Keywords]void #*j,const #[Keywords]void #*i)  #[Tags]\/*qsort调用的排序函数*\/\r\n{\r\n   #return(*(int*)i-*(int*)j);\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        227,
        "常胜将军",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n   #[Keywords]int #a=21,i;\r\n   #clrscr();\r\n   #puts(#[Fields]\"*****************************************************\"#);\r\n   #puts(#[Fields]\"*            This is a Matchstick Taken Game.       *\"#);\r\n   #puts(#[Fields]\"* There are 21 machsticks, two persons take them in *\"#);\r\n   #puts(#[Fields]\"* turn. Each one each time takes 1 to 4 sticks. The *\"#);\r\n   #puts(#[Fields]\"* one who takes the last stick will lose the game.  *\"#);\r\n   #puts(#[Fields]\"*****************************************************\"#);\r\n   #printf(#[Fields]\" >> --------------- Game Begin ---------------------\\n\"#);\r\n  #[Keywords] while#(a>0)\r\n   #{\r\n      #do{\r\n         #printf(#[Fields]\" >> How many sticks #[Keywords]do #you wish to take(1~%d)?\"#,a>4?4:a);\r\n         #scanf(#[Fields]\"%d\"#,&i);\r\n      #}#[Keywords]while#(i>4||i<1||i>a);      #[Tags]\/*接收正在确的输入*\/\r\n      #[Keywords]if#(a-i>0) printf(#[Fields]\" >> %d stick left in the pile.\\n\"#,a-i);\r\n      #[Keywords]if#((a-i)<=0)\r\n      #{\r\n         #printf(#[Fields]\" >> You have taken the last stick.\\n\"#);\r\n         #printf(#[Fields]\" >> ******* You lose! ******* \\n\"#);     #[Tags]\/*输出取胜标记*\/\r\n         #printf(#[Fields]\" >> --------------- Game Over! ---------------------\\n\"#);\r\n         #[Keywords]break#;\r\n      #}\r\n     #[Keywords] else#\r\n         #printf(#[Fields]\" >> Compute take %d stick.\\n\"#,5-i);    #[Tags]\/*输出计算机取的子数*\/\r\n      #a-=5;\r\n      #printf(#[Fields]\" >> %d stick left in the pile.\\n\"#,a);\r\n   #}\r\n   #printf(#[Fields]\"\\n Press any key to quit...\"#);\r\n   #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        228,
        "搬山游戏",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n   #[Keywords]int #n,k,x,y,cc,pc,g;\r\n   #clrscr();\r\n   #puts(#[Fields]\"*******************************************************\"#);\r\n   #puts(#[Fields]\"*            This is a Mountain Moveing Game.         *\"#);\r\n   #puts(#[Fields]\"* There are n mountains, two persons move them in     *\"#);\r\n   #puts(#[Fields]\"* turn. Each one each time moves 1 to k mountains, the*\"#);\r\n   #puts(#[Fields]\"* one who takes the last stick will lose the game.    *\"#);\r\n   #puts(#[Fields]\"*******************************************************\"#);\r\n   #printf(#[Fields]\" >> --------------- Game Begin ---------------------\\n\"#);\r\n   #pc=cc=0;\r\n   #g=1;\r\n   #[Keywords]for#(;;)\r\n   #{\r\n      #printf(#[Fields]\" >> No.%2d game \\n\"#,g++);\r\n   #printf(#[Fields]\" >> ---------------------------------------\\n\"#);\r\n   #printf(#[Fields]\" >> How many mountains are there? \"#);\r\n   #scanf(#[Fields]\"%d\"#,&n);\r\n   #[Keywords]if#(!n) #[Keywords]break#;\r\n   #printf(#[Fields]\" >> How many mountains are allowed to each time? \"#);\r\n   #do{\r\n      #scanf(#[Fields]\"%d\"#,&k);\r\n      #[Keywords]if#(k>n||k<1) printf(#[Fields]\" >> Repeat again!\\n\"#);\r\n   #}#[Keywords]while#(k>n||k<1);\r\n   #do{\r\n      #printf(#[Fields]\" >> How many mountains #[Keywords]do #you wish move ? \"#);\r\n      #scanf(#[Fields]\"%d\"#,&x);\r\n      #[Keywords]if#(x<1||x>k||x>n)      #[Tags]\/*判断搬山数是否符合要求*\/\r\n      #{\r\n         #printf(#[Fields]\" >> Illegal,again please!\\n\"#);\r\n         #[Keywords]continue#;\r\n      #}\r\n      #n-=x;\r\n      #printf(#[Fields]\" >> There are %d mountains left now.\\n\"#,n);\r\n      #[Keywords]if#(!n)\r\n      #{\r\n         #printf(#[Fields]\" >> ---- I win. You are failure.----------\\n\\n\"#);cc++;\r\n      #}\r\n     #[Keywords] else#\r\n      #{\r\n         #y=(n-1)%(k+1);      #[Tags]\/*求出最佳搬山数*\/\r\n         #[Keywords]if#(!y) y=1;\r\n         #n-=y;\r\n         #printf(#[Fields]\" >> Copmputer move %d mountains away.\\n\"#,y);\r\n         #[Keywords]if#(n) printf(#[Fields]\" >> There are %d mountains left now.\\n\"#,n);\r\n        #[Keywords] else#\r\n         #{\r\n\t    #printf(#[Fields]\" >> ---- I am failure. You win.-----------\\n\\n\"#);\r\n            #pc++;\r\n         #}\r\n      #}\r\n   #}#[Keywords]while#(n);\r\n\r\n   #}\r\n   #printf(#[Fields]\" >> Games in total have been played %d.\\n\"#,cc+pc);\r\n   #printf(#[Fields]\" >> You score is win %d,lose %d.\\n\"#,pc,cc);\r\n   #printf(#[Fields]\" >> My score is win %d,lose %d.\\n\"#,cc,pc);\r\n   #printf(#[Fields]\" >> --------------- Game Over! ---------------------\\n\"#);\r\n   #printf(#[Fields]\"\\n Press any key to quit...\"#);\r\n   #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        229,
        "兔子产子（菲波那契数列）",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]void #main()\r\n{\r\n   #[Keywords]int #n,i,j,un1,un2,un;\r\n   #clrscr();\r\n   #puts(#[Fields]\"********************************************************\"#);\r\n   #puts(#[Fields]\"*   This is a program to Calculate Rabbits Numbers.    *\"#);\r\n   #puts(#[Fields]\"* There is a rabbit couple procreats 2 rabbits 1 month,*\"#);\r\n   #puts(#[Fields]\"* and the young rabbits group and can procreats in the *\"#);\r\n   #puts(#[Fields]\"* end of the second month. In #[Keywords]this# way,how many rabbits*\"#);\r\n   #puts(#[Fields]\"* are there after n generations?                       *\"#);\r\n   #puts(#[Fields]\"********************************************************\"#);\r\n   #[Keywords]for#(n=2;n<3;)\r\n   #{\r\n      #printf(#[Fields]\" >> Please input number of generations (n>2): \"#);\r\n      #scanf(#[Fields]\"%d\"#,&n);\r\n      #[Keywords]if#(n<3) printf(#[Fields]\"\\n >> Input error!\\n\"#);    #[Tags]\/*控制输入正确的N值*\/\r\n   #}\r\n   #un=un2=1;\r\n   #printf(#[Fields]\" >> The numbers of rabbits in first %d generation are as follows:\\n\"#,n);\r\n   #printf(#[Fields]\" l\\t l\\t\"#);\r\n\r\n   #[Keywords]for#(i=3,j=0;i<=n;i++)\r\n   #{\r\n      #un1=un2;\r\n      #un2=un;\r\n      #un=un1+un2;     #[Tags]\/*利用通项公式求解N项的值*\/\r\n      #printf(   i%8?#[Fields]\" %d\\t\"#:#[Fields]\"%d\\n\"#,un);\r\n   #}\r\n   #printf(#[Fields]\"\\n\"#);\r\n   #printf(#[Fields]\"\\n Press any key to quit...\"#);\r\n   #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        230,
        "数字移动",
        "代码如下：\r\n[code=java]\r\n#include<stdio.h>\r\n#[Keywords]int #a[]={0,1,2,5,8,7,6,3#};    #[Tags]\/*指针数组.依次存入矩阵中构成环的元素下标*\/\r\n#[Keywords]int #b[9];              #[Tags]\/*表示3X3矩阵,b[4]为空格*\/\r\n#[Keywords]int #c[9];              #[Tags]\/*确定1所在的位置后,对环进行调整的指针数组*\/\r\n#[Keywords]int #count=0;           #[Tags]\/*数字移动步数计数器*\/\r\n#[Keywords]void #main()\r\n{\r\n   #[Keywords]int #i,j,k,t;\r\n   #[Keywords]void #print();\r\n   #clrscr();\r\n   #puts(#[Fields]\"*****************************************************\"#);\r\n   #puts(#[Fields]\"*         This is a program to Move Numbers.        *\"#);\r\n   #puts(#[Fields]\"*****************************************************\"#);\r\n   #printf(#[Fields]\" >> Please enter original order of digits 1~8: \"#);\r\n   #[Keywords]for#(i=0;i<8;i++)\r\n      #scanf(#[Fields]\"%d\"#,&b[a[i]]);\r\n               #\/*顺序输入矩阵外边的8个数字,矩阵元素的顺序由指针数组的元素a[i]控制*\/\r\n   #printf(#[Fields]\"The sorting process is as felow:\\n\"#);\r\n   #print();\r\n   #[Keywords]for#(t=-1,j=0;j<8&&t==-1;j++)     #[Tags]\/*确定数字1所在的位置*\/\r\n      #[Keywords]if#(b[a[j]]==1) t=j;           #[Tags]\/*t:记录数字1所在的位置*\/\r\n   #[Keywords]for#(j=0;j<8;j++)     #[Tags]\/*调整环的指针数组,将数字1所在的位置定为环的首*\/\r\n      #c[j]=a[(j+t)%8];\r\n   #[Keywords]for#(i=2;i<9;i++)         #[Tags]\/*从2开始依次调整数字的位置*\/\r\n                        #\/*i:正在处理的数字,i对应在环中应当的正确位置就是i-1*\/\r\n      #[Keywords]for#(j=i-1;j<8;j++)     #[Tags]\/*从i应处的正确位置开始顺序查找*\/\r\n\t #[Keywords]if#(b[c[j]]==i&&j!=i-1)      #[Tags]\/*若i不在正确的位置*\/\r\n         #{\r\n            #b[4]=i;          #[Tags]\/*将i移到中心的空格中*\/\r\n\t    #b[c[j]]=0;print();     #[Tags]\/*空出i原来所在的位置,输出*\/\r\n            #[Keywords]for#(k=j;k!=i-1;k--)    #[Tags]\/*将空格以前到i的正确位置之间的数字依次向后移动一格*\/\r\n            #{\r\n\t       #b[c[k]]=b[c[k-1]];    #[Tags]\/*数字向后移动*\/\r\n\t       #b[c[k-1]]=0;\r\n               #print();\r\n            #}\r\n\t    #b[c[k]]=i;         #[Tags]\/*将中间的数字i移入正确的位置*\/\r\n            #b[4]=0;            #[Tags]\/*空出中间的空格*\/\r\n            #print();\r\n            #[Keywords]break#;\r\n         #}\r\n\t #[Keywords]else #[Keywords]if#(b[c[j]]==i) #[Keywords]break#;       #[Tags]\/*数字i在正确的位置*\/\r\n    #printf(#[Fields]\"\\n Press any key to quit...\"#);\r\n    #getch();\r\n#}\r\n#[Keywords]void #print(void)        #[Tags]\/*按格式要求输出矩阵*\/\r\n{\r\n   #[Keywords]int #c;\r\n   #printf(#[Fields]\" >> Step No.%2d  \"#,count++);\r\n   #[Keywords]for#(c=0;c<9;c++)\r\n      #[Keywords]if#(c%3==2) printf(#[Fields]\"%2d  \"#,b[c]);\r\n      #[Keywords]else # printf(#[Fields]\"%2d\"#,b[c]);\r\n   #printf(#[Fields]\"\\n\"#);\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        231,
        "多项式乘法",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#include <math.h>\r\n#define MAX 50\r\n#[Tags]\/* 下面的两个数组可以根据具体要求解的多项式来决定其值*\/\r\n#[Keywords]static #[Keywords]double #p[6]={4,-6,3,1,-1,5#};\t#[Tags]\/*表示多项式4x^5 - 6x^4 + 3x^3 + x^2 - x + 5 *\/\r\n#[Keywords]static #[Keywords]double #q[4]={3,2,-5,1#};\t\t#[Tags]\/*表示多项式3x^3 + 2x^2 - 5x + 1 *\/\r\n#[Keywords]static #[Keywords]double #result[9]={0,0,0,0,0,0,0,0,0#};\t\t#[Tags]\/*存放乘积多项式*\/\r\n#[Keywords]void #npmul(p,m,q,n,s)\r\n#[Keywords]int #m,n;\r\n#[Keywords]double #p[],q[],s[];\r\n{\r\n\t#[Keywords]int #i,j;\r\n\t#[Keywords]for #(i=0; i<=m-1; i++)\r\n\t#[Keywords]for #(j=0; j<=n-1; j++)\r\n\t\t#s[i+j]=s[i+j]+p[i]*q[j];\t\t\/*迭带计算各项系数*\/\r\n\t#[Keywords]return#;#\r\n#}\r\n#[Keywords]double #compute(s,k,x)\t#[Tags]\/*计算所给多项式的值*\/\r\n#[Keywords]double #s[];\r\n#[Keywords]int #k;\r\n#[Keywords]float #x;\r\n{\r\n\t#[Keywords]int #i;\r\n\t#[Keywords]float #multip = 1;\r\n\t#[Keywords]double #sum = 0;\r\n\t#[Keywords]for #(i=0;i<k;i++)\r\n\t\t#multip = multip * x;\t\t\t#[Tags]\/*先求出x的最高次项的值*\/\r\n\t#[Keywords]for #(i=k-1;i>=0;i--)\r\n\t#{\r\n\t\t#sum = sum + s[i] * multip;\t\t#[Tags]\/*依次从高到低求出相对应次项的值*\/\r\n\t\t#[Keywords]if #(x!=0)\r\n\t\t#multip = multip \/ x;\r\n\t#}\r\n\t#[Keywords]return #sum;\r\n#}\r\n#[Keywords]void #main()\r\n{\r\n\t#[Keywords]int #i,j,m,n;\r\n\t#[Keywords]double # px[MAX],qx[MAX],rx[MAX];\r\n\t#[Keywords]float #x;\r\n\t#clrscr();\r\n\t#[Keywords]for#(i=0;i<MAX;i++)\r\n\t\t#rx[i]=0;\r\n\t#puts(#[Fields]\"      This is a polynomial multiplication program.\"#);\r\n\t#puts(#[Fields]\"It calculate the product of two polynomials: P(x) and Q(x)\"#);\r\n\t#puts(#[Fields]\"       P(x)=Pm-1*x^(m-1)+Pm-2*x^(m-2)+...+P1*x+P0\"#);\r\n\t#puts(#[Fields]\"       Q(x)=Qn-1*x^(n-1)+Qn-2*x^(n-2)+...+Q1*x+Q0\"#);\r\n\t#printf(#[Fields]\"\\n >> Please input m (>=1): \"#);\r\n\t#scanf(#[Fields]\"%d\"#,&m);\r\n\t#printf(#[Fields]\" >> Please input P%d, P%d, ... P1, P0 one by one:\\n\"#,m-1,m-2);\r\n\t#[Keywords]for#(i=0;i<m;i++)\r\n\t\t#scanf(#[Fields]\"%f\"#,&px[i]);\r\n\t#printf(#[Fields]\"\\n >> Please input n (>=1): \"#);\r\n\t#scanf(#[Fields]\"%d\"#,&n);\r\n\t#printf(#[Fields]\" >> Please input Q%d, Q%d, ... Q1, Q0 one by one:\\n\"#,n-1,n-2);\r\n\t#[Keywords]for#(i=0;i<n;i++)\r\n\t\t#scanf(#[Fields]\"%f\"#,&qx[i]);\r\n\t#npmul(p,m,q,n,rx);\r\n\t#printf(#[Fields]\"\\nThe product of two polynomials R(x) is :\\n\"#);\r\n\t#[Keywords]for #(i=m+n-1,j=0;i>=1;i--)\t\t#[Tags]\/*逐行逐项打印出结果多项式*\/\r\n\t#{\r\n\t\t#printf(#[Fields]\" (%f*x^%d) + \"#,rx[m+n-1-i],i-1);\r\n\t\t#[Keywords]if#(j==2)\r\n\t\t#{\r\n\t\t\t#printf(#[Fields]\"\\n\"#);\r\n\t\t\t#j=0;\r\n\t\t#}\r\n\t\t#else\r\n\t\t\t#j++;\r\n\t#}\r\n\t#printf(#[Fields]\"\\n\"#);\r\n\t#printf(#[Fields]\"Input the value of x: \"#);\r\n\t#scanf(#[Fields]\"%f\"#,&x);\r\n\t#printf(#[Fields]\"\\nThe value of the R(%f) is: %13.7f\"#,x,compute(rx,m+n-1,x));\r\n\t#puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        232,
        "产生随机数",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/* 在BC31下编译 *\/\r\n#[Tags]\/* compile under Borland C++ 3.1 *\/\r\n#include <stdio.h>\r\n#include <sys\\timeb.h>\r\n#define Alpha 3.90\r\n#[Keywords]double #initvalue();\r\n#[Keywords]double #random(void)#[Tags]\/*返回一个(0,1)之间的随机数*\/\r\n{\r\n    #[Keywords]static #[Keywords]double #f=-1.0;\r\n    #[Keywords]double #initvlaue();\r\n    #[Keywords]if#(f==-1.0) f=initvalue();\r\n    #[Keywords]else #f=Alpha*f*(1.0-f);\r\n    #[Keywords]return #f;\r\n#}\r\n#[Keywords]double #initvalue()#[Tags]\/*返回随机数序列初值*\/\r\n{\r\n    #[Keywords]double #f0;\r\n    #struct timeb *pr;\r\n    #[Keywords]for#(;;){\r\n\t\t#ftime(pr);\r\n\t\t#f0=pr->millitm*0.9876543*0.001;\r\n\t\t#[Keywords]if#(f0<0.001) #[Keywords]continue#;\r\n\t\t#[Keywords]break#;\r\n    #}\r\n    #[Keywords]return #f0;\r\n#}\r\n#[Keywords]void #main()\r\n{\r\n\t#[Keywords]double #test;\r\n\t#[Keywords]int #i;\r\n\t#clrscr();\r\n\t#puts(#[Fields]\"This is a random number generator.\"#);\r\n\t#puts(#[Fields]\"\\n The random number are: \"#);\r\n\t#[Keywords]for #( i = 0; i < 3; i++ )\r\n\t#{\r\n\t\t#test = random();\r\n\t\t#printf ( #[Fields]\" >> rand%d:%f\\n\"#, i, test );\r\n\t#}\r\n\t#puts(#[Fields]\"\\n Press any key to quit...\"#);\r\n\t#getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        233,
        "堆栈四则运算",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/* 在BC31下编译 或VC6.0*\/\r\n#[Tags]\/* compile under Borland C++ 3.1 or Visual C++ 6.0*\/\r\n#[Tags]\/*#include #[Fields]\"stdafx.h\"#*\/\r\n#include #[Fields]\"stdio.h\r\n#include #[Fields]\"string.h\r\n#include #[Fields]\"stdlib.h\r\n#include #[Fields]\"conio.h\r\n#define TRUE 1\r\n#define FALSE 0\r\n#define STACK_INIT_SIZE 100#[Tags]\/*存储空间初始分配量*\/\r\n#define STACKINCREMENT 20#[Tags]\/*存储空间分配增量*\/\r\ntypedef struct\r\n{\r\n\t#[Keywords]int #*pBase;#[Tags]\/*在构造之前和销毁之后,base的值为NULL*\/\r\n\t#[Keywords]int #*pTop;#[Tags]\/*栈顶指针*\/\r\n\t#[Keywords]int #StackSize;#[Tags]\/*当前已分配的存储空间,以元素为单位*\/\r\n#}Stack;\r\ntypedef #[Keywords]int #BOOLEAN;\r\n#[Keywords]char #Operator[8]=#[Fields]\"+-*\/()#\"#;#[Tags]\/*合法的操作符存储在字符串中*\/\r\n#[Keywords]char #Optr;#[Tags]\/*操作符*\/\r\n#[Keywords]int #Opnd=-1;#[Tags]\/*操作符*\/\r\n#[Keywords]int #Result;#[Tags]\/*操作结果*\/\r\n#[Tags]\/*算符间的优先关系*\/\r\n#[Keywords]char #PriorityTable[7][7]=\r\n{\r\n\t#{#[Fields]'>'#,#[Fields]'>'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'>'#,#[Fields]'>'##},\r\n\t#{#[Fields]'>'#,#[Fields]'>'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'>'#,#[Fields]'>'##},\r\n\t#{#[Fields]'>'#,#[Fields]'>'#,#[Fields]'>'#,#[Fields]'>'#,#[Fields]'<'#,#[Fields]'>'#,#[Fields]'>'##},\r\n\t#{#[Fields]'>'#,#[Fields]'>'#,#[Fields]'>'#,#[Fields]'>'#,#[Fields]'<'#,#[Fields]'>'#,#[Fields]'>'##},\r\n\t#{#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'='#,#[Fields]'o'##},\r\n\t#{#[Fields]'>'#,#[Fields]'>'#,#[Fields]'>'#,#[Fields]'>'#,#[Fields]'o'#,#[Fields]'>'#,#[Fields]'>'##},\r\n\t#{#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'o'#,#[Fields]'='##},\r\n#};\r\n#[Comments]\/\/数据对象的操作方法\r\n#[Comments]\/\/构造一个空栈,如果返回值为0,则表示初始化失败\r\nStack InitStack()\/*这是个效率低的方法*\/\r\n{\r\n\t#Stack S;\r\n\t#S.pBase=(int*)malloc(STACK_INIT_SIZE*sizeof(#[Keywords]int#));\r\n\t#[Keywords]if#(!S.pBase)\r\n\t#{#[Tags]\/*内存分配失败*\/\r\n\t\t#printf(#[Fields]\"内存分配失败,程序中止运行\\n\"#);\r\n\t\t#exit(-1);\r\n\t#}\r\n\t#else\r\n\t#{\r\n\t\t#S.pTop=S.pBase;\r\n\t\t#S.StackSize=STACK_INIT_SIZE;\r\n\t#}\r\n\t#[Keywords]return #S;\r\n#}\r\n#[Comments]\/\/销毁栈S,S不再存在\r\n#[Keywords]void #DestoryStack(Stack *S)\r\n{\r\n\t#[Keywords]if#(S->pBase)\r\n\t#{\r\n\t\t#free(S->pBase);\r\n\t\t#S->pTop=S->pBase=NULL;\r\n        \r\n\t#}\r\n#}\r\n#[Comments]\/\/若栈不空,则用e返回S的栈顶元素\r\n#[Comments]\/\/注:由于应用的特殊,可以不检查栈是否为空\r\n#[Keywords]int #GetTop(Stack S)\r\n{\r\n\t#[Keywords]return #*(S.pTop-1);\r\n#}\r\n#[Comments]\/\/插入元素e为新的栈顶元素,如果成功则返回1,否则返回0\r\n#[Keywords]int #Push(Stack *S,#[Keywords]int #e)\r\n{\r\n\t#[Keywords]if#(S->pTop-S->pBase==S->StackSize)\r\n\t#{#[Comments]\/\/栈满,追加存储空间\r\n\t\t#S->pBase=(int*)realloc(S->pBase,S->StackSize+STACKINCREMENT*sizeof(#[Keywords]int#));\r\n\t\t#[Keywords]if#(!S->pBase)\r\n\t\t\t#[Keywords]return #0;#[Comments]\/\/存储分配失败\r\n\t\t#S->pTop=S->pBase+S->StackSize;\r\n\t\t#S->StackSize+=STACKINCREMENT;\r\n\t#}\r\n\t#[Tags]*(S->pTop++)=e;\r\n\t#[Keywords]return #1;\r\n#}\r\n#[Keywords]int #Pop(Stack *S,#[Keywords]int #*e)\r\n{#[Comments]\/\/若栈不空,则删除S的栈顶元素,用e 返回其值,并返回1;否则返回0\r\n\t#[Keywords]if#(S->pTop==S->pBase)\r\n\t\t#[Keywords]return #0;\r\n\t#[Tags]*e=#[Tags]*--(S->pTop);\r\n\t#[Keywords]return #1;\r\n\r\n#}\r\n#[Comments]\/\/主函数及其它函数的实现\r\n#[Comments]\/\/比较两个数学符号operator_1,operator_2的计算优先权,在算符优先关系表中查找相应的关系并返回'<','=',或'>'\r\n#[Keywords]char #CheckPriority(#[Keywords]char #operator_1,#[Keywords]char #operator_2)\r\n{\r\n\t#[Keywords]int #i,j;#[Comments]\/\/用来查询算符间优先关系表的下标\r\n\t#[Comments]\/\/char *ptr;\r\n\t#i=strchr(Operator,operator_1)-Operator;#[Comments]\/\/找到传入操作符在字符串Operators中的相对位置\r\n\t#j=strchr(Operator,operator_2)-Operator;\r\n\t#[Comments]\/\/返回算符优先关系表中相应值\r\n\t#[Keywords]return #PriorityTable[i][j];\r\n#}\r\nBOOLEAN IsOperator(#[Keywords]char #ch)\r\n{#[Comments]\/\/判断一个字符是否为打操作符\r\n\t#[Keywords]if#(strchr(Operator,ch))\r\n\t\t#[Keywords]return #TRUE;\r\n\t#[Keywords]else #\r\n\t\t#[Keywords]return #FALSE;\r\n\r\n#}\r\n#[Comments]\/\/从键盘获得输入\r\n#[Keywords]void #GetInput(void)\r\n{\r\n\t#[Keywords]char #Buffer[20];#[Comments]\/\/键盘输入缓冲区,用来处理输入多位数的情况\r\n\t#[Keywords]char #ch;#[Comments]\/\/存放键盘输入\r\n\t#[Keywords]int #index;#[Comments]\/\/存放Buffer的下标\r\n\t#index=0;\r\n\t#ch=getch();#[Comments]\/\/从键盘读入一个字符\r\n\t#[Keywords]while#(ch!=13&&!IsOperator(ch))\r\n\t#{#[Comments]\/\/如果输入的字符是回车符或是操作符,循环结束\r\n\t\t#[Keywords]if#(ch>=#[Fields]'0'#&&ch<=#[Fields]'9'#)\r\n\t\t#{#[Comments]\/\/将字符回显到屏幕\r\n\t\t\t#printf(#[Fields]\"%c\"#,ch);\r\n\t\t\t#Buffer[index]=ch;\r\n\t\t\t#index++;\r\n\r\n\t\t#}\r\n\t\t#ch=getch();\r\n\t#}\r\n\t#[Keywords]if#(ch==13)\r\n\t\t#Optr=#[Fields]'#'#;#[Comments]\/\/输入的表达式以回车符结束\r\n\t#else\r\n\t#{\r\n\t\t#Optr=ch;\r\n\t\t#printf(#[Fields]\"%c\"#,ch);\r\n\r\n\t#}\r\n\t#[Keywords]if#(index>0)\r\n\t#{\r\n\t\t#Buffer[index]=#[Fields]'\\0'#;\r\n\t\t#Opnd=atoi((Buffer));\r\n\t#}\r\n\t#else\r\n\t\t#Opnd=-1;#[Comments]\/\/程序不支持输入负数,当Opnd为负数时,表示输入的字符为操作符\r\n#}\r\n#[Comments]\/\/计算形如a+b之类的表达式,theta为操作符,a,b为操作数\r\n#[Keywords]int #Calc(#[Keywords]int #a,#[Keywords]char #theta,#[Keywords]int #b)\r\n{\r\n\t#switch(theta)\r\n\t#{\r\n\t#[Keywords]case ##[Fields]'+'#:\r\n\t\t#[Keywords]return #a+b;\r\n\t#[Keywords]case ##[Fields]'-'#:\r\n\t\t#[Keywords]return #a-b;\r\n\t#[Keywords]case ##[Fields]'*'#:\r\n\t\t#[Keywords]return #a*b;\r\n\t#[Keywords]default#:\r\n\t\t#[Keywords]if#(b==0)#[Comments]\/\/除数为零的情况\r\n\t\t#{\r\n\t\t\t#printf(#[Fields]\"除数不能为\"#);\r\n\t\t\t#[Keywords]return #0;#[Comments]\/\/返回0用以显示\r\n\t\t#}\r\n\t\t#else\r\n\t\t\t#[Keywords]return #a\/b;\r\n\t#}\r\n#}\r\n#[Tags]\/*表达式求值*\/\r\nBOOLEAN EvaluateExpression()\r\n{\r\n\t#[Keywords]int #temp;#[Comments]\/\/临时变量\r\n\t#[Keywords]char #theta;#[Comments]\/\/存放操作符的变量\r\n\t#[Keywords]int #itheta;#[Comments]\/\/存放出栈的操作符的变量add by me\r\n\t#[Keywords]int #a,b;#[Comments]\/\/存放表达式运算时的中间值\r\n\t#[Keywords]int #topOpnd;#[Comments]\/\/栈顶操作数\r\n\t#[Keywords]char #topOptr;#[Comments]\/\/栈顶操作符\r\n\t\r\n\t#Stack OPTR=InitStack();#[Comments]\/\/操作符栈\r\n\t#Stack OPND=InitStack();#[Comments]\/\/操作数栈\r\n\r\n\t#[Keywords]if#(!Push(&OPTR,#[Fields]'#'#))#[Comments]\/\/操作符栈中的第一个为#字符\r\n\t\t#[Keywords]return #FALSE;\r\n\r\n\t#GetInput();#[Comments]\/\/从键盘获得输入\r\n\r\n\t#[Keywords]while#(Optr!=#[Fields]'#'#||GetTop(OPTR)!=#[Fields]'#'#)\r\n\t#{#[Comments]\/\/如果Optr>=0,表示有操作数输入\r\n\t\t#[Keywords]if#(Opnd>=0)Push(&OPND,Opnd);\r\n\t\t#switch(CheckPriority(GetTop(OPTR),Optr))\r\n\t\t#{\r\n\t\t#[Keywords]case ##[Fields]'<'#:#[Comments]\/\/栈顶元素优先权低\r\n\t\t\t#[Keywords]if#(!Push(&OPTR,Optr))#[Keywords]return #FALSE;\r\n\t\t\t\t#GetInput();\r\n\t\t\t#[Keywords]break#;\r\n\t\t#[Keywords]case ##[Fields]'='#:#[Comments]\/\/脱括号并接收键盘输入\r\n\t\t\t#Pop(&OPTR,&temp);GetInput();\r\n\t\t\t#[Keywords]break#;\r\n\t\t#[Keywords]case ##[Fields]'>'#:#[Comments]\/\/退栈并将运算结果入栈\r\n\t\t\t#[Comments]\/\/先用itheta得到操作符在赋给theta\r\n\t\t\t#Pop(&OPTR,&itheta);\r\n\t\t\t#Pop(&OPND,&b);\r\n\t\t\t#Pop(&OPND,&a);\r\n\t\t\t#theta = (char)( itheta );\r\n\t\t\t#Push(&OPND,Calc(a,itheta,b));\r\n\t\t\t#Opnd=-1;\r\n\t\t\t#[Keywords]break#;\r\n\r\n\t\t#}\r\n\t#}\r\n\t#[Comments]\/\/本算法中,当输入只有一个操作数然后就输入回车符时,\r\n\t#[Comments]\/\/OPND.pTop==OPND.pBase\r\n\t#[Comments]\/\/如果OPND.pTop==OPND.pBase并且Opnd<0,则说明用户\r\n\t#[Comments]\/\/未输入任何操作和操作符而直接输入[回车],程序直接\r\n\t#[Comments]\/\/退出运行\r\n\t#[Keywords]if#(OPND.pTop==OPND.pBase&&Opnd<0)\r\n\t#{\r\n\t\t#printf(#[Fields]\"\\n\\n感谢使用!\\n\"#);\r\n\t\t#exit(1);\r\n\r\n\t#}\r\n\t#[Keywords]else #[Keywords]if#(OPND.pTop==OPND.pBase)\r\n\t\t#Result=Opnd;\r\n\t#else\r\n\t#{\r\n\t\t#Result=GetTop(OPND);\r\n\t\t#DestoryStack(&OPND);\r\n\t\t#DestoryStack(&OPTR);\r\n\t#}\r\n\t#[Keywords]return #TRUE;\r\n\r\n#}\r\n\r\n#[Keywords]void #Message(void)\r\n{\r\n\t#printf(#[Fields]\"\\n四则运算表达式求值演示\\n\"#);\r\n\t#printf(#[Fields]\"-------------------------------\\n\"#);\r\n\t#printf(#[Fields]\"使用方法:请从键盘上直接输入表达式,以回车键结束.如45*(12-2)[回车]\\n\"#);\r\n\t#printf(#[Fields]\"注0:不输入任何数而直接按[回车]键,将退出程序.\\n\"#);\r\n\t#printf(#[Fields]\"注1:本程序暂时不接受除数字键及四则运算符之外的任何其它键盘输入.\\n\"#);\r\n\t#printf(#[Fields]\"注2:本程序暂时只能处理正确的表达式,不支持输入负数.\\n\"#);\r\n\t#printf(#[Fields]\"-------------------------------\\n\\n\"#);\r\n#}\r\n#[Keywords]void #main(void)\r\n{\r\n\t#[Keywords]int #i;#[Comments]\/\/用来一些说明性信息\r\n\t#Message();\r\n\t#[Keywords]for#(i=1;;i++)\r\n\t#{\r\n\t\t#printf(#[Fields]\"表达式%d:\"#,i);\r\n\t\t#[Keywords]if#(EvaluateExpression())\r\n\t\t\t#printf(#[Fields]\"=%d\\n\"#,Result);\r\n\t\t#else\r\n\t\t\t#printf(#[Fields]\"计算中遇到错误\\n\"#);\r\n\t\t\r\n\t#}\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        234,
        "递归整数四则运算",
        "代码如下：\r\n[code=java]\r\n#[Tags]\/* 在BC31下编译 *\/\r\n#[Tags]\/* compile under Borland C++ 3.1 *\/\r\n#[Tags]\/*\r\n#[Tags]对四则混合运算所提取的形式化表达式(生成式)\r\n#[Tags]<exp> -> <term> { <addop> <term> #}\r\n#[Tags]<addop> -> + | -\r\n#[Tags]<term> -> <factor> { <mulop> <factor> #}\r\n#[Tags]<mulop> -> * | \/\r\n#[Tags]<factor> -> ( <exp> ) | Number\r\n#[Tags]*\/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#[Keywords]char #token; #[Tags]\/*全局标志变量*\/\r\n#[Tags]\/*递归调用的函数原型*\/\r\n#[Keywords]int #exp( #[Keywords]void #);\r\n#[Keywords]int #term( #[Keywords]void #);\r\n#[Keywords]int #factor( #[Keywords]void #);\r\n#[Keywords]void #error( #[Keywords]void #) \/*报告出错信息的函数*\/\r\n{\r\n\t#fprintf( stderr, #[Fields]\"错误\\n\"#);\r\n\t#exit( 1 );\r\n#}\r\n#[Keywords]void #match( #[Keywords]char #expectedToken ) #[Tags]\/*对当前的标志进行匹配*\/\r\n{\r\n\t#[Keywords]if#( token == expectedToken ) token = getchar(); #[Tags]\/*匹配成功，获取下一个标志*\/\r\n\t#[Keywords]else #error(); #[Tags]\/*匹配不成功，报告错误*\/\r\n#}\r\n#[Keywords]void #Message(void)\r\n{\r\n\t#printf(#[Fields]\"================================================================\\n\"#);\r\n\t#printf(#[Fields]\"*               递归实现的四则运算表达式求值程序               *\\n\"#);\r\n\t#printf(#[Fields]\"****************************************************************\\n\"#);\r\n\t#printf(#[Fields]\"使用方法:请从键盘上直接输入表达式,以回车键结束.如45*(12-2)[回车]\\n\"#);\r\n\t#printf(#[Fields]\"*****************************************************************\\n\\n\"#);\r\n#}\r\nmain()\r\n{\r\n\t#[Keywords]int #result;  #[Tags]\/*运算的结果*\/\r\n\t#Message();\r\n\t#printf(#[Fields]\" >> 请输入表达式: \"#);\r\n\t#token = getchar(); #[Tags]\/*载入第一个符号*\/\r\n\t\r\n\t#result = exp(); #[Tags]\/*进行计算*\/\r\n\t#[Keywords]if#( token == #[Fields]'\\n'# ) #[Tags]\/* 是否一行结束 *\/\r\n\t\t#printf( #[Fields]\" >> 表达式的计算结果为 : %d\\n\"#, result );\r\n\t#[Keywords]else #error(); #[Tags]\/* 出现了例外的字符 *\/\r\n\t#puts(#[Fields]\"\\n\\n                  请按任意键退出 ...\\n\"#);\r\n\t#getch();\r\n\t#[Keywords]return #0;\r\n#}\r\n#[Keywords]int #exp( #[Keywords]void #)\r\n{\r\n\t#[Keywords]int #temp = term(); \/*计算比加减运算优先级别高的部分*\/\r\n\t#[Keywords]while#(( token == #[Fields]'+'# ) || ( token == #[Fields]'-'# ))\r\n\t\t#switch( token ) {\r\n\t\t#[Keywords]case ##[Fields]'+'#: match(#[Fields]'+'#);     \/*加法*\/\r\n\t\t\t  #temp += term();\r\n\t\t\t  #[Keywords]break#;\r\n\t\t#[Keywords]case ##[Fields]'-'#: match(#[Fields]'-'#);\r\n\t\t\t  #temp -= term(); #[Tags]\/*减法*\/\r\n\t\t\t  #[Keywords]break#;\r\n\t\t#}\r\n\t#[Keywords]return #temp;\r\n#}\r\n#[Keywords]int #term( #[Keywords]void #)\r\n{\r\n\t#[Keywords]int #div; #[Tags]\/*除数*\/\r\n\t#[Keywords]int #temp = factor();   #[Tags]\/*计算比乘除运算优先级别高的部分*\/\r\n\t#[Keywords]while#(( token == #[Fields]'*'# ) || ( token == #[Fields]'\/'# ))\r\n\t\t#switch( token ) {\r\n\t\t#[Keywords]case ##[Fields]'*'#: match(#[Fields]'*'#);  #[Tags]\/*乘法*\/\r\n\t\t\t  #temp *= factor();\r\n\t\t\t  #[Keywords]break#;\r\n\t\t#[Keywords]case ##[Fields]'\/'#: match(#[Fields]'\/'#);   #[Tags]\/*除法*\/\r\n\t\t\t  #div = factor();\r\n\t\t\t  #[Keywords]if#( div == 0 ) #[Tags]\/*需要判断除数是否为0*\/\r\n\t\t\t  #{\r\n\t\t\t  \t#fprintf( stderr, #[Fields]\"除数为0.\\n\"# );\r\n\t\t\t  \t#exit(1);\r\n\t\t\t  #}\r\n\t\t\t  #temp \/= div;\r\n\t\t\t  #[Keywords]break#;\r\n\t\t#}\r\n\t#[Keywords]return #temp;\r\n#}\r\n#[Keywords]int #factor( #[Keywords]void #)\r\n{\r\n\t#[Keywords]int #temp; \r\n\t#[Keywords]if#( token == #[Fields]'('# ) #[Tags]\/*带有括号的运算*\/\r\n\t#{\r\n\t\t#match( #[Fields]'('# );\r\n\t\t#temp = exp();\r\n\t\t#match(#[Fields]')'#);\r\n\t#}\r\n\t#[Keywords]else #[Keywords]if #( isdigit( token )) #[Tags]\/*实际的数字*\/\r\n\t#{\r\n\t\t#ungetc( token, stdin ); #[Tags]\/*将读入的字符退还给输入流*\/\r\n\t\t#scanf( #[Fields]\"%d\"#, &temp ); #[Tags]\/*读出数字*\/\r\n\t\t#token = getchar();  #[Tags]\/*读出当前的标志*\/\r\n\t#}\r\n\t#[Keywords]else #error(); #[Tags]\/*不是括号也不是数字*\/\r\n\t#[Keywords]return #temp;\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        235,
        "复平面作图",
        "代码如下：\r\n[code=java]\r\n#include <stdio.h>\r\n#include <math.h>\r\n#[Keywords]void #oplot(n,x,y) #[Tags]\/*作图函数，这里使用DOS的文本模式画图*\/\r\n#[Keywords]int #n;\r\n#[Keywords]double #x[],y[];\r\n{\r\n\t#[Keywords]int #i, j;\r\n\t#[Keywords]char #screen[25][80]; #[Tags]\/*声明一个字符型数组，用来表示屏幕的输出*\/\r\n\t#memset(screen, #[Fields]' '#, 25*80);  #[Tags]\/*将数组整体赋值为空格*\/\r\n\t#\/*画x轴*\/\r\n\t#[Keywords]for#( i = 0; i <79; i++)\r\n\t\t#screen[10][i] = #[Fields]'-'#;\r\n\t#screen[10][79] = #[Fields]'X'#;\r\n\t#\/*画y轴*\/\r\n\t#[Keywords]for#( i = 1; i <25; i++)\r\n\t\t#screen[i][40] = #[Fields]'|'#;\r\n\t#screen[0][40] = #[Fields]'Y'#;\r\n\t#\/*将符合条件的点(x,y)赋值成星号*\/\r\n\t#[Keywords]for#( i = 0; i < n; i++)\r\n\t\t#screen[(#[Keywords]int#)(x[i]+10)][(#[Keywords]int#)(y[i]*2+40)] = #[Fields]'*'#;\r\n\t#\/*输出数组，在屏幕上画图*\/\r\n\t#[Keywords]for#( i = 0; i < 25; i++)\r\n\t\t#[Keywords]for#( j = 0; j <80; j++)\r\n\t\t\t#printf(#[Fields]\"%c\"#, screen[i][j] );\r\n#}\r\nmain()\r\n{\r\n    #[Keywords]int #points,k;\r\n    #[Keywords]double #x[50], y[50], angle, portion;\r\n    #clrscr();\r\n\t#points = 40; #[Tags]\/*一共画40个点*\/\r\n\t#portion = 4.0 * M_PI \/ points; #[Tags]\/*将720度分成40份。*\/\r\n\t#\/*下边是求点的计算*\/\r\n\t#[Keywords]for #(k=0; k<points; k++)\r\n\t#{\r\n\t\t#angle=k * portion; #[Tags]\/*求出角度*\/\r\n\t\t#x[k]=2.0+angle*cos(angle); #[Tags]\/*x，也就是复数的实部*\/\r\n\t\t#y[k]=angle*sin(angle); #[Tags]\/*y，即复数的虚部*\/\r\n\t#}\r\n    #oplot(points,x,y); #[Tags]\/*对所求出的点作图*\/\r\n    #getch();\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ],
      [
        236,
        "绘制彩色抛物线",
        "代码如下：\r\n[code=java]\r\n#include <graphics.h>\r\n#include <math.h>\r\n#[Tags]\/*画抛物线的子函数spara()*\/\r\n#[Tags]\/*row,col代表抛物线顶点的坐标，x1,y1是抛物线起点相对顶点的坐标*\/\r\n#[Tags]\/*t为抛物线绕顶点旋转的角度*\/\r\n#[Keywords]void #spara(row,col,x1,y1,t,color)  \r\n#[Keywords]int #row,col,x1,y1,t,color;\r\n{   \r\n  #[Keywords]int #n,dx,dy,x,y,x2,y2;\r\n  #[Keywords]double #ct,st;\r\n  #[Keywords]double #f,fx,fy,b,a,rx;\r\n  #st=(double)t*3.1415926\/180.0;\t\t#[Tags]\/*把角度转化为弧度*\/\r\n  #ct=cos(st); st=sin(st);\r\n  #n=abs(x1)+abs(y1); n=n+n;\r\n  #dx=1; dy=1; f=0.0;\t\t\t\t#[Tags]\/*初始化工作*\/\r\n  #[Keywords]if #(x1>0) dx=-1;\r\n  #[Keywords]if #(y1>0) dy=-1;\r\n  #a=y1; b=x1; b=b*b;\r\n  #rx=-a-a; fx=2.0*x1*dx+1.0;\r\n  #fx=-a*fx; fy=b;\r\n  #[Keywords]if #(dy<0) fy=-fy;\r\n  #x=x1; y=y1;\r\n  #x2=(double)x*ct-(double)y*st+2000.5;\r\n  #y2=(double)x*st+(double)y*ct+2000.5;\r\n  #x2=x2-2000; y2=y2-2000;\r\n  #putpixel(row-y2,col+x2,color);\r\n  #[Keywords]while #(n>0)\t\t#[Tags]\/*具体的运算法则见上面的公式*\/\r\n    #{ n=n-1;\r\n\t  #[Keywords]if #(f>=0.0)\r\n\t  #{ x=x+dx;\r\n\t    #x2=(double)x*ct-(double)y*st+2000.5;\r\n\t    #y2=(double)x*st+(double)y*ct+2000.5;\r\n\t    #x2=x2-2000; y2=y2-2000;\r\n\t    #putpixel(row-y2,col+x2,color);\r\n\t    #[Keywords]if #(fx>0.0) f=f-fx;\r\n\t    #[Keywords]else #f=f+fx;\r\n\t    #fx=fx+rx;\r\n\t    #[Keywords]if #(fx==0.0||(fx<0.0&&fx-rx>0.0)||(fx>0.0&&fx-rx<0.0))\r\n\t      #{ dy=-dy; fy=-fy; f=-f;#}\r\n\t  #}\r\n\t#else\r\n\t  #{ y=y+dy;\r\n\t    #x2=(double)x*ct-(double)y*st+2000.5;\r\n\t    #y2=(double)x*st+(double)y*ct+2000.5;\r\n\t    #x2=x2-2000; y2=y2-2000;\r\n\t    #putpixel(row-y2,col+x2,color);\r\n\t    #[Keywords]if #(fy>0.0) f=f+fy;\r\n\t    #[Keywords]else #f=f-fy;\r\n\t  #}\r\n    #}\r\n  #[Keywords]return#;#\r\n#}\r\n#[Keywords]void #main()\r\n{\r\n  #[Keywords]int #i,color;\r\n  #[Keywords]int #gdriver = DETECT , gmode;\r\n  #color = 1;\r\n  #registerbgidriver(EGAVGA_driver);\r\n  #initgraph(&gdriver,&gmode,#[Fields]\"..\\\\bgi\"#);\t\t#[Tags]\/*初始化图形界面*\/\r\n  #[Keywords]for #(i=1;i<=4;i++)\t\t\t\t\t\t#[Tags]\/*先画出四个互成90度的抛物线*\/\r\n  #{\r\n    #spara(200,200,100,100,i*90,color);\r\n    #color+=3;\r\n    #getch();\r\n  #}\r\n  #color = 1;\r\n  #[Keywords]for #(i=1;i<=11;i++)\t\t#[Tags]\/*再画12个互成30度的抛物线*\/\r\n  #{\r\n    #spara(200,200,100,100,i*30,color);\r\n    #color++;\r\n  #}\r\n  #getch();\r\n  #closegraph();\r\n  #[Keywords]return#;#\r\n#}\r\n[\/code]",
        0,
        120,
        1
      ]
    ]
  }
]